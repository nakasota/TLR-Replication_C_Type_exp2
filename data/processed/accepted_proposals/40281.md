=== Fetching Proposal: MDU6SXNzdWU2NjAwOTA5MTE= ===
Issue URL: https://github.com/golang/go/issues/40281

==== [Issue Title] ====
reflect: back out multiple keys in key:value pair in struct tag

==== [Issue Body] ====
Hello ðŸ‘‹ 

I'm actually boring to set the same value for multiple key in my struct tag. Maybe I missed something but here is the boring thing:
```go
type MyStruct struct {
  Field1 string `json:"field_1,omitempty" bson:"field_1,omitempty" xml:"field_1,omitempty" form:"field_1,omitempty" other:"value"`
}
```
What I'm proposing is:
```go
type MyStruct struct {
  Field1 string `json,bson,xml,form:"field_1,omitempty" other:"value"`
}
```

Thanks ðŸ‘ 

==== [Comments] ====

--- Comment #1 by ianlancetaylor ---
Just noting that this would mean that struct tag keys cannot contain a comma character.  The current documentation at https://golang.org/pkg/reflect/#StructTag is "Each key is a non-empty string consisting of non-control characters other than space (U+0020 ' '), quote (U+0022 '"'), and colon (U+003A ':')."  So this would be a change.  Of course, it's fairly unlikely that anybody is using a tag key with a comma.

--- Comment #2 by scorsi ---
It could be a breaking change of course. 

--- Comment #3 by rsc ---
I have a large corpus of Go code that I can scan at some point to see if anyone uses , in tag names in practice.
Will try to do that before next week.


--- Comment #4 by rsc ---
What if we use a space-separated list instead of a comma-separated one?

```
type MyStruct struct {
  Field1 string `json bson xml form:"field_1,omitempty" other:"value"`
}
```

The spaces form is more analogous to what happens in Go argument lists:
in `x int, y int, z int`, you can remove the repeated ` int`, leaving `x, y, z int`.
If we do the same here, then
in `json:"x" bson:"x" xml:"x"`, you can remove the repeated `:"x"`, leaving `json bson xml:"x"`.
If we inserted commas during this step, you'd need to explain where they came from
(they weren't there before!).

The space form is also quite a bit less of a wall of text and thus easier to skim. Compare:

    Field1 string `json bson xml form:"field_1,omitempty" other:"value"`
    Field1 string `json,bson,xml,form:"field_1,omitempty" other:"value"`

And unlike comma, spaces cannot appear in valid tags today,
so we would not be redefining technically valid syntax to mean
something slightly different.

--- Comment #5 by cristaloleg ---
Space-separated is much better and it indeed looks like Go argument list.

Regarding proposal: I haven't use more than 1 file tag (json or yaml) before, but last week have played with different config files and leaving all this verbose repetitions (`field1` for JSON, also for YAML, also for TOML, also for ...) will make multi-tags much easier to use.

--- Comment #6 by scorsi ---
I must admit that space separated could be a good idea which wonâ€™t break anything. 

Personally I feel it less comprehensible than comma separated and in go we have comma between arguments (~~we donâ€™t write `a b c int` so comma is more go in fact lol~~ ok i did understand why space is more go in fact) but a choice have to be made and donâ€™t belongs to me :) 

Even with space separated, the main issue is resolved so itâ€™s ok to me ! ;) 

--- Comment #7 by rsc ---
OK, so with the syntax I suggested last Thursday (space-separated instead of comma-separated keys), there is no concern about backwards compatibility. There hasn't been much discussion otherwise.

I did make some progress analyzing tags in my Go corpus last week, and I found that 0.06% of tags have commas in keys (outside quoted values). All of those are mistakes. So we could plausibly use comma and not break things, but the space is more in keeping with the current syntax anyway.

Based on the discussion above, this seems like a **likely accept** (with spaces, not commas).

To be clear, the new syntax would be:

```
type MyStruct struct {
  Field1 string `json bson xml form:"field_1,omitempty" other:"value"`
}
```

--- Comment #8 by rsc ---
No change in consensus, so accepted.


--- Comment #9 by bynov ---
Hi! I would like to work on that feature. Is it possible? :)

--- Comment #10 by rsc ---
Sure, go ahead.



--- Comment #11 by gopherbot ---
Change https://golang.org/cl/248341 mentions this issue: `reflect: added multiple keys support for struct tags`

--- Comment #12 by deven96 ---
Hello @bynov . Are you still working on this?

--- Comment #13 by bynov ---
Hi, @deven96 
I have already sent PR on Gerrit. It's in review now :)

--- Comment #14 by deven96 ---
Lol... darn it 
Goodluck mate @bynov 

--- Comment #15 by scorsi ---
Hello, into which version of go this feature will be available ?

--- Comment #16 by cristaloleg ---
@scorsi probably Feb 2021, when Go 1.16 will be released.

--- Comment #17 by gopherbot ---
Change https://golang.org/cl/274448 mentions this issue: `reflect: document multiple keys in struct tags`

--- Comment #18 by fatih ---
I'm trying to add this new syntax to one of my tools `gomodifytags` which is used in many editors (i.e: VSCode, Vim, etc..). It allows one to add or remove struct tags in an easy way. You can find more details here: https://github.com/fatih/gomodifytags

One particular edge case I've found is, assuming the user wants to add a new tag to an existing field for the same value. 

```go
type T struct {
	Server string `json:"server"`
}
```

Adding the new key in the old format would produce:

```go
type T struct {
	Server string `json:"server" xml:"server"`
}
```

But in the new format, the tool need to output it in:

```go
type T struct {
	Server string `json xml:"server"`
}
```

So the problem I see here is, how should I, as a tool owner know which format is the correct one for the user? Outputting in the new format would mean that we should assume the application is built with the latest (i.e: `1.16`) Go version. But if they run it in an older version, the new format won't work and it'll break their applications.

One can say that outputting in the old format should work and hence the tool always should output in the old format for backwards compatibility. If I choose this approach, then some other use cases arise. Assume the user _already_ uses the new format:

```go
type T struct {
	Server string `json xml:"server"`
}
```

If the user adds a new tag, because the tool outputs in the old format, suddenly it changes to something that the user didn't intended to use:

```go
type T struct {
	Server string `json:"server" xml:"server" bson:"server"`
}
```

I think this is the only approach I can use for now. But then, I wonder how I can make it easier for the user to use this new syntax. I feel like there is a compromise I need to consider and whether this change would cause disruptions in the future because not a lot of services might run with the old versions. It looks like a ticking bomb waiting to explode and I hope we can reconsider the syntax due the reasons listed here. 

--- Comment #19 by uluyol ---
@fatih Isn't this what the go language version in the go.mod file is for? Can't you just use the new style if version â‰¥ 1.16, and otherwise stick with the old one?

--- Comment #20 by marwan-at-work ---
@uluyol I used to think the same thing but I don't believe that's true. A go.mod file declaring 1.16 can still be compiled by 1.15 or lower. 

--- Comment #21 by ianlancetaylor ---
If the go.mod files says `go 1.16`, that means that the files in the module may use constructs introduced in language version 1.16.  A person using a Go 1.15 or earlier compiler can still attempt to compile the module.  That is not prohibited.  But if an error occurs while compiling, the go tool will report "note: module requires Go 1.16".

So in general it is OK for a transformation tool to use Go 1.16 language constructs if `go 1.16` appears in the go.mod file.

--- Comment #22 by mvdan ---
I fully agree with @ianlancetaylor; a tool should use the go.mod language version for this decision. In this case it's slightly trickier, as an older version of Go would fail only when using vet/test to parse the struct field tag, and not at compile time, as I'm pretty sure struct field tags are not fully parsed at compile time.

But I still think that is okay. If a module declares Go 1.16 as the language version, and a downstream user insists on using Go 1.14 or 1.15, I argue it's up to them to be extra careful that their software still works even after it builds. A Go program/module building on an older version of Go does not mean that it will work fine. Fully vetting/testing it will the older Go version is the only way to be sure.

--- Comment #23 by mvdan ---
> I argue it's up to them to be extra careful that their software still works even after it builds

I should clarify, however, that I think this might end up being a problem with people installing Go programs via go get/install following README instructions. Those people are likely not Go experts, and they might be using the Go version that came with their system, often an older version. If their program install works, they would have no reason to think that the program might not work properly.

That said, I still think that is a problem with Go builds in general; this change just adds another way to end up in this weird spot.

--- Comment #24 by rogpeppe ---
> But if an error occurs while compiling, the go tool will report "note: module requires Go 1.16".

This heuristic works well for language changes that break existing syntax, but not so well for changes like this one that change behaviour but don't result in errors when using an old compiler version.

For example, say some third party package changes to use this feature, and I (still using go 1.15) update to use the new version. My code is now broken with no indication of the fact. `go vet` would pick this up, but it's uncommon for people to run `go vet` on third-party code (doing so very often spews out a raft of false positives).

When using an older Go compiler, it's common to import modules that declare newer Go versions, because any newly created module declares the current compiler version even if isn't using new language features, so seeing that happen isn't an instant red flag (aside: `go list -f '{{.Path}} {{.GoVersion}}' -m all` isn't _hard_ to type, but isn't obvious either, if you want to check this).

I worry that in larger ecosystems, this change might end up with significant non-obvious brokenness that only emerges after things break in production.

I don't currently see an easy way around it.

--- Comment #25 by ianlancetaylor ---
> This heuristic works well for language changes that break existing syntax, but not so well for changes like this one that change behaviour but don't result in errors when using an old compiler version.

Yes.  This is discussed in detail at https://go.googlesource.com/proposal/+/refs/heads/master/design/28221-go2-transitions.md .

This isn't quite a redefinition, as the new code generates a runtime error with pre-1.16 versions of the standard library, but you're right that it's problematic in that it doesn't generate a compile time error.

So I think I agree with you: although as I said above using the new syntax is in some sense permitted for Go 1.16 or later, full safety suggests not using the new syntax until Go 1.15 and earlier are no longer supported.

--- Comment #26 by rogpeppe ---
> This isn't quite a redefinition, as the new code generates a runtime error with pre-1.16 versions of the standard library

I don't see a runtime error when running [this code](https://play.golang.org/p/HnqRxVhyFoc) under Go 1.15,
so it seems like it actually is a redefinition.


--- Comment #27 by ianlancetaylor ---
You're right.  I was mistaken.

--- Comment #28 by gopherbot ---
Change https://golang.org/cl/277092 mentions this issue: `go/analysis/passes/structtag: recognize multiple keys per tag`

--- Comment #29 by gopherbot ---
Change https://golang.org/cl/277076 mentions this issue: `cmd/vet: vendor in x/tools, update structtag vet check`

--- Comment #30 by leitzler ---
@ianlancetaylor just to sort out any confusion, is the decision here to include this change in Go 1.16 even though it indeed is a redefinition?

As I read https://go.googlesource.com/proposal/+/master/design/28221-go2-transitions.md#language-redefinitions it looks like redefinitions should be avoided:

> I think the only feasible safe approach is to not permit language redefinitions.

I do understand that there might be exceptions for critical changes, but do this feature really falls into that category?
