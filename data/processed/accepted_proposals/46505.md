=== Fetching Proposal: MDU6SXNzdWU5MDg3ODk3MjU= ===
Issue URL: https://github.com/golang/go/issues/46505

==== [Issue Title] ====
spec: allow conversion from slice to array

==== [Issue Body] ====
I recently tried to use the new #395 feature (for converting a slice to an array pointer: https://golang.org/cl/216424) in:

https://go-review.googlesource.com/c/go/+/322329

But in review, it was pointed out that it was a little ugly, as what I wanted to return was an array, which required a dereference:

```go
	return *(*[Size224]byte)(sum[:Size224])
```

It would've been nicer if I could've just converted to an array instead:

```go
	return ([Size224]byte)(sum[:Size224])
```

Talking to @ianlancetaylor and @griesemer, we couldn't remember great reasons for not also allowing this as part of #395. It does mean there's an subtle copy, but arguably the `*` dereference above is also a somewhat subtle copy.

Could we also add support for converting to the array?

/cc @katiehockman @josharian @rogpeppe  @mdempsky 

==== [Comments] ====

--- Comment #1 by randall77 ---
Note the `[:Size224]` is unnecessary. There, I saved you more characters than the 2 `*`s you were worried about!

I think the decision to omit direct-to-array casts was just to keep the feature change minimal. We need the cast-to-pointer regardless to support aliasing to the same backing store, and cast-to-array is easily implemented using cast-to-pointer.


--- Comment #2 by zigo101 ---
Some like https://github.com/golang/go/issues/36890

--- Comment #3 by mdempsky ---
I don't immediately see anything wrong with allowing slice to array conversions, but I feel like saving two asterisks in an already rather niche feature doesn't justify the extra complexity on compilers and tooling.

--- Comment #4 by bcmills ---
Since this conversion would do a copy anyway, would we also add a conversion from `string` to `[N]byte` for consistency?

--- Comment #5 by rsc ---

This proposal has been added to the [active column](https://golang.org/s/proposal-status#active) of the proposals project
and will now be reviewed at the weekly proposal review meetings.
â€” rsc for the proposal review group


--- Comment #6 by rogpeppe ---
FWIW I didn't propose this originally because it could easily be implemented, even prior to #395, by using `copy`, albeit not quite so concisely.

I'm not entirely convinced that it's worth it tbh, especially given the possibility for the expression to panic.

--- Comment #7 by katiehockman ---
Question: is it possible to make changes to `copy()` so that it is equally performant to the `*(*array)(slice)` conversion? Then we don't need to support this additional conversion at all, and it can just be common practice to use `copy` in such situations.

FWIW I'm a lot less concerned about a few extra characters in the line than I am about readability. I was pretty confused as a reader to see a conversion in the form `*(*array)(slice)`. I read it as "Cast a slice to a pointer to an array, then dereference this array", which felt more like a hack than a best practice. But maybe I just need to get used to it.

--- Comment #8 by mdempsky ---
> Question: is it possible to make changes to copy() so that it is equally performant to the *(*array)(slice) conversion? Then we don't need to support this additional conversion at all, and it can just be common practice to use copy in such situations.

Probably. I don't think there's any fundamental reason they'd perform differently. Can you file an issue with examples of code that you think should perform equivalently, and we can look into it for Go 1.18?

> I was pretty confused as a reader to see a conversion in the form *(*array)(slice). I read it as "Cast a slice to a pointer to an array, then dereference this array"

Assuming you meant "dereference this [pointer to] array", that description is pretty much how I think of it, though arguably it's more of a (checked) "assertion" (as in type assertions), as conversions generally can't fail. A slice is a pointer + dynamic length (and capacity). The conversion here is changing it to a pointer + static length, with a runtime check to ensure the lengths are compatible.

--- Comment #9 by katiehockman ---
> Can you file an issue with examples of code that you think should perform equivalently, and we can look into it for Go 1.18?

Brad wrote a little benchmark that demonstrated some of the performance differences which probably shouldn't be different: https://play.golang.org/p/BkYM9Gbi4t2. He got the following results:

```
BenchmarkNamed-8        201051339                6.263 ns/op
BenchmarkCopy-8         172203873                6.071 ns/op
BenchmarkPointer-8      1000000000               1.031 ns/op
```

You can also check out the Sum functions in https://go-review.googlesource.com/c/go/+/322329 which are good examples of code that should perform ~equivalently.

--- Comment #10 by mdempsky ---
@katiehockman Thanks, filed #46529.

As noted in that issue, the first two functions have different semantics than the last function when `len(b) < Size256`. I suspect that doesn't matter for your use case, but the compiler would need some way to discern that can't happen before it can optimize them identically.

--- Comment #11 by kortschak ---
ISTM that the need for a dereference is a nice visual signal to an author that `*(*[n]T)(s[:n])` is more costly than `(*[n]T)(s[:n])`. As it is it's reasonably common the users are surprised that an array expression results in a copy of the array (for example in a range over an array value).

--- Comment #12 by bcmills ---
> ISTM that the need for a dereference is a nice visual signal to an author

I am personally unlikely to notice that signal among the line-noise of the rest of the expression.
Also note that `([]byte)(s)` for a string `s`, or `string(b)` for a slice `b`, has no such visual signal â€” the destination type is in some sense â€œgood enoughâ€.

> As it is it's reasonably common the users are surprised that an array expression results in a copy

Sure, but the ship has already sailed on that one. ðŸ˜… Given that we _already have_ array values, it doesn't seem particularly _more_ confusing to allow conversions to them.

--- Comment #13 by bcmills ---
> I am personally unlikely to noticed that signal among the line-noise of the rest of the expression.

Looking at this again, I'm not sure why the slice part of the expression is needed at all.
@bradfitz, could you not have written that as
```go
	return *(*[Size224]byte)(sum)
```
?

And then the direct-conversion alternative becomes
```go
	return ([Size224]byte)(sum)
```
which reads a lot cleaner to me. (Without the redundant slice expression, those redundant `*` tokens are a larger fraction of the noise.)

--- Comment #14 by kortschak ---
>Given that we already have array values, it doesn't seem particularly more confusing to allow conversions to them.

It's not a matter of confusion in this case, but signalling that there is more work being done; the pointer conversion is essentially free. WRT the signalling for `string`/`[]byte`, the difference there is that they are clearly distinct types, in this situation it is potentially a single character that makes the difference. between behaviours under the proposal.

--- Comment #15 by rsc ---
Strictly speaking this is unnecessary. You can always write

    *(*[10]int)(x)

instead of the proposed

    [10]int(x)

That said, copying data out from a slice into a fixed-size array is pretty common when using fixed-size arrays (like checksums etc), so I don't really see the harm in making that less star-full.

/cc @robpike 

--- Comment #16 by rsc ---
Any objections to adding this?


--- Comment #17 by randall77 ---
I'm leaning against. I don't think adding a new conversion case is worth saving two `*`s.


--- Comment #18 by mdempsky ---
I'm also leaning against.

We've had a string of fixes to x/tools to update code for slice-to-array-pointer conversions. None of the CLs have been very involved, but just cases where we forgot to update it. I don't think this feature is going to be so frequently used to justify forcing tools authors to support both forms.

--- Comment #19 by rsc ---
Does anyone want to make an argument in favor? 


--- Comment #20 by Splizard ---
> Does anyone want to make an argument in favor?

I believe that this proposal would result in improved discoverability around this kind of type conversion, when I first started writing Go (~8 years ago) I recall at one point wondering why I couldn't convert a slice to an array just like this. This seemed like the obvious way to do it.
```go
[10]int(x)
```
At the time (even if #395 existed), it would never have occurred to me that I could do something like this:
```go
*(*[10]int)(x)
```
I had previously been using languages without pointers and I wasn't familiar with the semantics around dereferencing or how slices relate to them.

It's the kind of small thing as a beginner you don't even bother looking into when the compiler throws an error and you simply write it another way until you find out months or years later when you see it somewhere and/or learn more about pointer semantics and realise that this is possible.

IE. somebody who starts learning about pointer semantics in Go can infer that `*(*[10]int)(x)` is possible if they are already familiar with `[10]int(x)` but if this proposal is declined then beginners in Go are locked out from benefiting from #395 until they learn more about the language (and this is hindered further if they come from languages without pointers).

Instead of framing this proposal around "saving two asterisks", I would argue that it helps discoverability around #395 because it is an obvious way to convert from a slice to an array. 


--- Comment #21 by zephyrtronium ---
> Instead of framing this proposal around "saving two asterisks", I would argue that it helps discoverability around #395 because it is an obvious way to convert from a slice to an array.

I think this is an excellent point. However, as someone who teaches Go, I would prefer arrays in general to be as un-discoverable to beginners as possible. In almost every case, especially for new users, just sticking with slices is the correct choice.

--- Comment #22 by bcmills ---
@zephyrtronium, given that arrays exist and are easy to discover anyway, I would expect an introduction to Go to cover them (very briefly) and advise new Go users to stick to slices instead.

If you already know whether an array is the right tool for the job, then you're going to write the appropriate code either way.

If you've decided prematurely to use an array, you're probably just as likely to end up with a tangle of pointers and conversions copied from the Web as to arrive at the correct solution of â€œstick to slicesâ€. So maybe it's better to confine the user's confusion to â€œarray or slice?â€ and not _also_ throw pointers into the mix..?

--- Comment #23 by rsc ---
I found @Splizard's point pretty compelling. We've removed gratuitous stars from Go syntax in the past, and this seems like another case where we could. Arrays do exist, and if you want a [10]byte of a 10-long []byte, [10]byte(x) is the obvious thing to try.


--- Comment #24 by mdempsky ---
I'm still leaning against as unneeded, but I don't feel strongly about it. To respond to @Splizard 's points:

> IE. somebody who starts learning about pointer semantics in Go can infer that `*(*[10]int)(x)` is possible if they are already familiar with `[10]int(x)`

There are no other cases in Go where `T(x)` and `*(*T)(x)` are both validâ€ , much less where they both mean the same thing. I don't see any reason why users would infer the latter is possible from the former. If anything, it would seem to now lead them to *incorrectly* infer other conversions should be valid or equivalent or to misunderstand how pointers work.

â€  Edit: If `x` is an `unsafe.Pointer`, it can be converted to either `uintptr` or `*uintptr`, but `uintptr(x)` and `*(*uintptr)(x)` mean different things.

> but if this proposal is declined then beginners in Go are locked out from benefiting from #395 until they learn more about the language (and this is hindered further if they come from languages without pointers).

I see arrays as an optimization, and one whose proficient use depends on understanding pointer semantics already. I think beginner Go programmers are better served by sticking to slices. Adding slice-to-array conversions to help users that aren't yet familiar with pointers seems like a trap that will encourage them to (mis)use arrays more.

I'm not convinced the extra burden on Go tools authors is justified. While this burden is small, the benefit doesn't seem any larger.

--- Comment #25 by deefdragon ---
> as a beginner you don't even bother looking into when the compiler throws an error and you simply write it another way until you find out months or years later when you see it somewhere and/or learn more about pointer semantics and realise that this is possible

_As_ said newer programmer, I can say that I have recently attempted to do `[10]int(x)`, only to find it not possible. This surprised me a bit at the time given it matched the format. I just chose to move on and re-write a good chunk of code to use slices instead. It didn't look as good, but it worked, so I shrugged and moved on.

I am in favor of the suggested change.

--- Comment #26 by mdempsky ---
> I just chose to move on and re-write a good chunk of code to use slices instead. It didn't look as good, but it worked, so I shrugged and moved on.

Can you elaborate on why "it didn't look as good"? You say this as though it's objectively true, but that's an inherently subjective statement; and the only subject in your example is a self-proclaimed newer programmer (i.e., you). It seems plausible to me that more experienced Go programmers would think the slice form looks as good if not better.

I'm not contesting that new programmers might try and expect slice-to-array conversions to work. Just that I'm not convinced allowing those conversions would lead new programmers to write idiomatic Go code.

--- Comment #27 by deefdragon ---
I was decoding [BC1/DXT1](https://docs.microsoft.com/en-us/windows/win32/direct3d10/d3d10-graphics-programming-guide-resources-block-compression#bc1), part of which requires generating 4 colors to then use as a pallet to decode the block of pixels. I was expecting `[4]color.Color` from my generator function because it felt right to be explicit there. 

Due to not knowing the current trick (or having any reason to expect it existed to begin with), I couldn't convert in the generator function and had to refactor. When refactoring I could have moved the generating function to work with an array internally (so its not a perfect example), or switch to using slices everywhere. I chose the latter because "just use slices".

The loss of that explicit size for the colors made the code messier. It was a minor thing, but minor things add up. Similarly, the excess stars & inconsistency with the all other conversions are minor, but they add up. 

I stand by my surprise that you can not convert slices to arrays via the proposed form, and that it should be added.

--- Comment #28 by rsc ---

Based on the discussion above, this proposal seems like a **[likely accept](https://golang.org/s/proposal-status#likely-accept)**.
â€” rsc for the proposal review group


--- Comment #29 by ianlancetaylor ---
I just noticed a use case for this at https://go-review.googlesource.com/c/website/+/328213/5/internal/gitfs/fs.go#30.

--- Comment #30 by mdempsky ---
@deefdragon Thanks. Can you elaborate though on why you needed to convert from `[]color.Color` to `[4]color.Color`? Why wasn't the slice type either `[][4]color.Color` or just `[4]color.Color`? Is the code available to view somewhere?

@ianlancetaylor Using Go 1.17, that code could already be written `return *(*Hash)(x), nil`. It still seems like a very minor win that users could write `return Hash(x), nil` and save 4 characters instead.
