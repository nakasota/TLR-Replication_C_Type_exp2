=== Fetching Proposal: MDU6SXNzdWU4NTM4NTM1MDY= ===
Issue URL: https://github.com/golang/go/issues/45453

==== [Issue Title] ====
all: add GOAMD64 environment variable

==== [Issue Body] ====
This proposal is to add a GOAMD64 environment variable, with the initial options of "baseline" (default), "v2", and "v3".

Most Go architectures support a GO[arch] environment variable to control architecture-specific options: GO386, GOARM, GOMIPS, GOMIPS64, GOPPC64, GOWASM. However, the AMD64 port (presumably the most common architecture Go is deployed on) still limits itself to the original, now-20-year-old instruction set, with some occasional runtime CPUID detection when the savings is significant enough to merit it. (For comparison, GOPPC64 supports optimizing for power9, which only became available in 2017.)

This is further complicated by x86-64 having accumulated many, many instruction set extensions, with each processor revision having a different set of supported extensions. Making users responsible for deciding what set of extensions to enable doesn't feel very Go-like.

However, in 2020, the x86-64 psABI added four named microarchitecture levels to help group the extensions: "x86-64 (baseline)", "x86-64-v2", "x86-64-v3", and "x86-64-v4". See https://en.wikipedia.org/wiki/X86-64#Microarchitecture_levels or https://developers.redhat.com/blog/2021/01/05/building-red-hat-enterprise-linux-9-for-the-x86-64-v2-microarchitecture-level/ for further details.

The "baseline" corresponds to what Go already supports, while "v2" and "v3" each add some new instructions that could be useful for Go programs (e.g., POPCNT in v2, BMI1/BMI2 in v3).

v2 CPUs appear commonplace today. E.g., RHEL9 will only support v2, per the above blog post; all GCE CPUs support v2, and I believe all AWS and Azure CPUs too.

v3 CPUs are also increasingly common. E.g., only GCE's Ivy Bridge and Sandy Bridge CPUs are limited to v2; Haswell (launched 2013) and newer support v3.

On issue #25489, I reported results from two optimization attempts at using Haswell's BMI instructions (PEXT for varint decoding, LZCNT and a couple others for scanobject). These are optimizations that could benefit from targeting v3 CPUs specifically, but probably wouldn't be worthwhile if they needed to rely on runtime CPUID detection.

It's also been suggested that at process startup, the Go runtime should throw if it's been compiled to assume instruction set extensions that aren't available on the CPU. I think that's a good idea.

Questions:

- Are "baseline", "v2", and "v3" the best names? "v1" would perhaps be better than "baseline", but the psABI doesn't formally name it that. We could suggest that though?

- Should we add "v4" too? This only adds AVX512 instructions, which the Go compiler/runtime don't immediately have any use for, and which seem a bit contentious about whether to use them on current processors anyway.

==== [Comments] ====

--- Comment #1 by ianlancetaylor ---
Since v4 is defined I would be inclined to say that we should accept v4 as a valid `GOAMD64` value but treat it as v3.

--- Comment #2 by mdempsky ---
> Since v4 is defined I would be inclined to say that we should accept v4 as a valid GOAMD64 value but treat it as v3.

I think it's okay if we accept GOAMD64=v4 and don't actually use any of the AVX512 instructions. But then I think the runtime should probably still check that they're available at runtime, so if we decide to start using AVX512 in the future we won't have to worry about users erroneously running v4 binaries on v3 CPUs.

--- Comment #3 by martisch ---
I would like to note that the Pentium and Celerons (often used in low tier laptops, NUCs and NAS devices) do not support AVX/AVX2 and while based on Haswell and newer (and are categorized with the same architecture names) are v2 and not v3. So for server farms where performance matters v3 is likely a good choice but for general computing even on newer chips v2 is still relevant.


--- Comment #4 by mvdan ---
I think it's also worth noting that some mainstream Linux distros are looking at adopting the same microarchitecture levels for their binary packages. For example, Arch will add v3 to their mirrors on top of the existing "baseline": https://gitlab.archlinux.org/archlinux/rfcs/-/merge_requests/2/diffs

Assuming they ship this soon, I imagine any packages building with GCC or LLVM would benefit, and Go packages would be left behind without this proposal.

--- Comment #5 by rsc ---
It's nice to see Intel and AMD coalescing on fewer configuration knobs.


--- Comment #6 by rsc ---
"baseline" is an unfortunate name because it sounds like "Go's default".
(Compare with the mentions of baseline in discussions of GOEXPERIMENT.)
It does seem like "v1" is the obvious choice for the base configuration.
Maybe someone can suggest that to Intel?


--- Comment #7 by rsc ---

This proposal has been added to the [active column](https://golang.org/s/proposal-status#active) of the proposals project
and will now be reviewed at the weekly proposal review meetings.
â€” rsc for the proposal review group


--- Comment #8 by beoran ---
While I agree that adding support for different API levels of the Go AMD64 port, I would like v1 to stay the default for Go applications and for the Go compiler itself at least for the next 10 years. My family and I use old refurbished computers with Linux, since that still works fine, and I think there must be many others around the world who are in the situation of not having access to recent hardware.

--- Comment #9 by rsc ---
@beoran, what the default or minimum requirements are for Go would be different proposals. As I understand it, no one is proposing to change the default or the minimum requirement away from v1 in this issue. This is just about adding an architecture setting similar to GOARM and others.



--- Comment #10 by rsc ---
If we can call the current baseline "v1" instead of "baseline" then it seems like everyone is on board.
Do I have that right?



--- Comment #11 by rsc ---

Based on the discussion above, this proposal seems like a **[likely accept](https://golang.org/s/proposal-status#likely-accept)**.
â€” rsc for the proposal review group


--- Comment #12 by rsc ---

No change in consensus, so **[accepted](https://golang.org/s/proposal-status#accepted)**. ðŸŽ‰
This issue now tracks the work of implementing the proposal.
â€” rsc for the proposal review group


--- Comment #13 by gopherbot ---
Change https://golang.org/cl/349595 mentions this issue: `cmd/go: add GOAMD64 environment variable`

--- Comment #14 by gopherbot ---
Change https://golang.org/cl/351130 mentions this issue: `cmd/compile: use BMI1 instructions for GOAMD64=v3 and higher`

--- Comment #15 by gopherbot ---
Change https://golang.org/cl/351191 mentions this issue: `runtime: check a microarchitecture level at startup`

--- Comment #16 by mvdan ---
I see that if I use `GOAMD64=v3 ./make.bash`, then that value sticks as the default for that Go install's `go env` and its subsequent builds. That seems fair enough.

I was initially confused as to whether `go env -w GOAMD64=v3` would also work for `make.bash`; it seems like it would not, since `cmd/dist` simply does an `os.Getenv`. Maybe this should be clarified in the documentation before the final release. From the output of `go help environment`, it's not clear which of the variables are sometimes used via `os.Getenv`, e.g. while building Go itself.

I also wonder if the default could be made a bit smarter. Right now, `cmd/dist` seems to look at `os.Getenv`, and otherwise fall back to `v1`. It would be nice if it looked at the bootstrap toolchain's `go env GOAMD64`. If I'm bootstrapping with `GOAMD64=v3`, then I'd hope that the new toolchain would inherit that, just like building a toolchain with `GOAMD64=v3` makes its future `go build` invocations default to that value too.

This last suggestion would also help in cases where a distribution installs with v3 as it detects newer hardware, and the user builds tip by simply running `cd src && ./make.bash`; they should not need to remember to repeat GOAMD64 to get the same benefit.

--- Comment #17 by beoran ---
@mvdan 

I disagree. It is not because you have AMD v3 hardware that you also want to build v3 binaries. This would lead people on newer hardware to build binaries that people on older AMD hardware, like myself, are unable to run, *without warning*. As I said above the default for GOAMD64 should be v1 almost everywhere. Buidling v3 binaries should only be done on explicit request.

--- Comment #18 by mvdan ---
@beoran I assume you're referencing this bit from my comment:

> just like building a toolchain with `GOAMD64=v3` makes its future `go build` invocations default to that value too.

This is how it currently works. It seems correct to me; when I run my cross-build script for open source releases, I explicitly set it back to `GOAMD64=v1` now.  The default should match the local machine, just like GOOS/GOARCH and CGO_ENABLED.

> people on older AMD hardware, like myself, are unable to run, _without warning_

Note that https://go-review.googlesource.com/c/go/+/351191/ should make that pretty obvious. If a release was built with the wrong parameters, you would be able to notice quickly and notify upstream.

--- Comment #19 by mvdan ---
The alternative would be for the toolchain's `GOAMD64` to not stick with future `go build` invocations. In that case, I imagine most people (myself included) would just do `go env -w GOAMD64=v3` to set up a global default, so it's the same end result - just with more hoops :)

--- Comment #20 by beoran ---
`If a release was built with the wrong parameters, you would be able to notice quickly and notify upstream.`

That is actually something I was hoping to avoid. I will probably end up reporting to X open source Go projects where they do not know this is in effect, or do not care, and release an amd v3 binary as a generic "amd" binary. Or have to compile everything myself. Where X will probably be getting larger as time goes by.

`so it's the same end result - just with more hoops :)`

In this case the hoop does have its use: to remind developers to also make a v1 build. But for consistency's sake, I do have to concede this: it does make perfect sense that for a compiler built on platform P the default binaries it produces are for platform P. So for consistency's sake, I will concede that point.

In stead, I would like to push that this is amply documented, and that at the release of this feature, it is stressed that it is recommended to also build v1 binaries when releasing a Go project for backwards compatibility.

Also I fully agree that the CPU detection PR you linked is useful to make it clear to people in my case to see what is happening, at least for command line programs, or on Unix-like OS where stderr is always available. For GUI-based OS (Windows, OS X), it would be even more useful, if possible, to make the incompatible binaries fail in such a way that the OS displays a GUI message.

--- Comment #21 by mvdan ---
> In stead, I would like to push that this is amply documented, and that at the release of this feature, it is stressed that it is recommended to also build v1 binaries when releasing a Go project for backwards compatibility.

Definitely agreed. My "UX report" comment above also went in the direction of docs. Right now, releasing binaries for an open source project requires a few careful steps - looping over `GOOS/GOARCH`, setting `CGO_ENABLED=0`, setting the right flags to produce static binaries. It would be very useful to document those "general recommendations" for portable/distributable binaries, and those instructions should include a warning about `GOAMD64`, `GOARM`, etc.

--- Comment #22 by beoran ---
Yes, definitely a good idea.

Suddenly I have a different idea: what if there was a flag or so for go build to make the compiler front end do this looping for us, building all binaries for all combinations of os, arch and microrarch? That could make the work a lot easier. I know it is a different issue, though but i like to bring it up here first.

--- Comment #23 by mvdan ---
@beoran I have split that into https://github.com/golang/go/issues/48540, because it certainly feels off-topic :)

--- Comment #24 by randall77 ---
I don't think it is a good idea to have the build depend on any properties of the bootstrap compiler. We have a somewhat complicated bootstrap process exactly to make sure that the final build doesn't contain any artifacts of the bootstrap Go.


--- Comment #25 by Jacalz ---
I wonder, should this also try to pass the relevant architecture to the CGO_CFLAGS (and CXX)? I mean, building the Go binary with `GOAMD64=v3` could then pass `-march=x86_64-v3` to the c-compiler as well to get more benefits when using CGO.

--- Comment #26 by mvdan ---
@randall77 That's fair. Then my only remaining suggestion is better docs around GOAMD64 (how and when to set it) before 1.18 is released :)

--- Comment #27 by fweimer-rh ---
> I wonder, should this also try to pass the relevant architecture to the CGO_CFLAGS (and CXX)? I mean, building the Go binary with `GOAMD64=v3` could then pass `-march=x86_64-v3` to the c-compiler as well to get more benefits when using CGO.

`-march=x86_64=v3` support in compilers is fairly new, so you would have to probe for compiler support before you pass the flag.

--- Comment #28 by gopherbot ---
Change https://golang.org/cl/353249 mentions this issue: `cmd/compile: use TZCNT instruction for GOAMD64>=v3`

--- Comment #29 by gopherbot ---
Change https://golang.org/cl/354670 mentions this issue: `cmd/compile: use MOVBE instruction for GOAMD64>=v3`

--- Comment #30 by mvdan ---
@Jacalz perhaps file a new issue about the `-march` idea and @fweimer-rh's comment? I think this issue will be closed at some point soon, since the env var already works, and I think your follow-up idea is worth tracking and implementing in the future.
