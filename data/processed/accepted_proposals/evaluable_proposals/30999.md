=== Fetching Proposal: MDU6SXNzdWU0MjQwNjkyOTQ= ===
Issue URL: https://github.com/golang/go/issues/30999

==== [Issue Title] ====
net: reject leading zeros in IP address parsers [freeze exception]

==== [Issue Body] ====
### What version of Go are you using (`go version`)?

<pre>
$ go version
go version go1.12.1 linux/amd64
</pre>

### Does this issue reproduce with the latest release?

Yes.

### What operating system and processor architecture are you using (`go env`)?

<details><summary><code>go env</code> Output</summary><br><pre>
$ go env
GOARCH="amd64"
GOBIN=""
GOCACHE="/home/xxx/.cache/go-build"
GOEXE=""
GOFLAGS=""
GOHOSTARCH="amd64"
GOHOSTOS="linux"
GOOS="linux"
GOPATH="/home/xxx/gocode"
GOPROXY=""
GORACE=""
GOROOT="/home/xxx/go"
GOTMPDIR=""
GOTOOLDIR="/home/xxx/go/pkg/tool/linux_amd64"
GCCGO="gccgo"
CC="gcc"
CXX="g++"
CGO_ENABLED="1"
GOMOD=""
CGO_CFLAGS="-g -O2"
CGO_CPPFLAGS=""
CGO_CXXFLAGS="-g -O2"
CGO_FFLAGS="-g -O2"
CGO_LDFLAGS="-g -O2"
PKG_CONFIG="pkg-config"
GOGCCFLAGS="-fPIC -m64 -pthread -fmessage-length=0 -fdebug-prefix-map=/tmp/go-build040813268=/tmp/go-build -gno-record-gcc-switches"
</pre></details>

### What did you do?

```
package main

import "net/http"

func main() {
	http.Get("http://7.7.7.017")
}
```

### What did you expect to see?

`7.7.7.017` is interpreted as `7.7.7.15`.

```
$ ping 7.7.7.017
PING 7.7.7.017 (7.7.7.15) 56(84) bytes of data.
```

### What did you see instead?

The program tries to connect to `7.7.7.17`.

==== [Comments] ====

--- Comment #1 by agnivade ---
This is more of a net/url issue rather than net/http.

What does the RFC say regarding this ?

--- Comment #2 by ghost ---
I believe that `Parse` doesn't try to interpret the hostname at all.

--- Comment #3 by secenv ---
As shown [in this recent article](https://sick.codes/universal-netmask-npm-package-used-by-270000-projects-vulnerable-to-octal-input-data-server-side-request-forgery-remote-file-inclusion-local-file-inclusion-and-more-cve-2021-28918/), this behavior could be used in server-side request forgery, local file inclusion and remote file inclusion vulnerabilities.

--- Comment #4 by tv42 ---
There is no real RFC on textual IP address representation. The best we have is https://tools.ietf.org/html/draft-main-ipaddr-text-rep-02 which says

> All the forms except for decimal octets are seen as non-standard (despite being quite widely interoperable) and undesirable.

I'd argue Go net.ParseIP/ParseCIDR etc should return an error on zero-prefixed input.  It avoids ambiguity and since Go has historically parsed them differently than BSD, an error is a safer change in behavior than silently giving different results.

See also https://man7.org/linux/man-pages/man3/inet_pton.3.html which does not accept zero-prefixed IPs.

--- Comment #5 by tv42 ---
And as I discussed with @secenv on IRC, that article is naive. Typical "attacks" that 0127.0.0.1 enables are enabled also by `evil.example.com A 127.0.0.1` in DNS, and the fix for both is to check the target IP *after resolving*, basically `&http.Client{Transport: &http.Transport{DialContext: dialOnlySafeIPs}}`

--- Comment #6 by secenv ---
I forgot to add that it is indeed an issue that affects net.ParseCIDR https://play.golang.org/p/HpWqhr9tZ53 . I agree with @tv42, those functions should return errors. The documentation should at least warn the developer.

Guess I should mention @FiloSottile for further discussion on the security impact of this issue. 

--- Comment #7 by tv42 ---
I found a more authoritative RFC on IP address textual representation -- although it's only Informational not Standards Track: https://tools.ietf.org/html/rfc6943#section-3.1.1

Since Go doesn't use the "loose" syntax of RFC6943, it's non-conforming already. Rejecting non-dotted-decimal inputs would make Go use the "strict" syntax.

--- Comment #8 by rsc ---
I agree about changing Go's IP address parsers
(ParseIP, ParseCIDR, any others) to reject leading zeros (except "0"),
because:

(1) the RFCs are mostly quiet but in a few places hint that decimal is the right interpretation,
(2) Go interprets leading zeros as decimal, and
(3) BSD stacks nonetheless interpret leading zeros as octal.
(4) The fact that basically no one has noticed this divergence implies
that essentially no one uses leading zeros in IP addresses.

It seems like an open question whether this should be done
in a point release or saved for the next major release (Go 1.17).
But to start, we should agree to do it at all.
Adding to the proposal process.

--- Comment #9 by FiloSottile ---
> And as I discussed with @secenv on IRC, that article is naive. Typical "attacks" that 0127.0.0.1 enables are enabled also by `evil.example.com A 127.0.0.1` in DNS, and the fix for both is to check the target IP _after resolving_, basically `&http.Client{Transport: &http.Transport{DialContext: dialOnlySafeIPs}}`

I find this pretty convincing, especially given that `net.Dial` and `net.Listen` will parse the IPs as decimal.

To end up vulnerable due to this mismatch, an application would have to parse the IP with Go, reject any hostnames, apply security-relevant logic to the return value, and then pass the input (_not_ the encoding of the return value) to a different, non-Go application which is happy to parse the IP as octal.

Generally, this is another instance where relying on parser alignment instead of re-encoding outputs is a fragile design.

We are not aware of any application for which this leads to a security issue, if anyone does please let us know at security@golang.org as that would help evaluate whether to backport the fix.

In any case, I definitely agree we should just consider these inputs invalid in Go 1.17.

--- Comment #10 by bradfitz ---
Related: https://github.com/golang/go/issues/43389 ("net: limit the size of ParseIP input?")


--- Comment #11 by rsc ---

This proposal has been added to the [active column](https://golang.org/s/proposal-status#active) of the proposals project
and will now be reviewed at the weekly proposal review meetings.
â€” rsc for the proposal review group


--- Comment #12 by liggitt ---
One notable use of the stdlib methods is to [validate API fields expected to contain IP / CIDR data](https://github.com/kubernetes/kubernetes/issues/100895). When stdlib methods change to reject data they previously accepted, that makes previously validated and persisted data turn invalid when checked by the same validation code.

While I agree with the goals of bounding input and ensuring data handled by diverse implementations is unambiguous, there should be a reasonable migration path for callers using stdlib methods for this purpose. What would we expect these callers to do before/after the proposed stdlib changes to move away from accepting 0-prefixed IP octets in new data, and to start detecting/migrating existing data?

Options that come to mind:
* Prevalidate IP/CIDR inputs to detect/reject leading 0's in addition to calling stdlib Parse methods? This seems like it reimplements bits of IP parsing, which is fragile/complex, especially for ipv6 addresses (which was why stdlib methods were used in the first place)
* Require normalized form (e.g. `ParseIP().String()`)? This seems burdensome for ipv6 addresses, which are [quite flexible](https://tools.ietf.org/html/rfc4291#section-2.2) and make many accommodations to simplify textual expression

--- Comment #13 by rsc ---
> Prevalidate IP/CIDR inputs to detect/reject leading 0's in addition to calling stdlib Parse methods? This seems like it reimplements bits of IP parsing, which is fragile/complex, especially for ipv6 addresses (which was why stdlib methods were used in the first place)

This seems fine to me if really needed. Instead of reimplementing those bits, though, just make a copy of the existing standard library routines. The license permits that.

The problem with "validate API fields" here is that if the validation disagrees with the eventual use, the validation is wrong. It's probably better for everyone involved to reject those than to mutually misunderstand them.



--- Comment #14 by thockin ---
That's rather unpleasant.  We have persisted data that we don't control and can't ever really declare as invalid.  We'll have to allow old uses of the "sloppy" format in perpetuity.

No hope of adding a `ParseIPSloppy()` sibling in the stdlib ?

--- Comment #15 by rsc ---
If Kubernetes needs ParseIPDecimal then I would suggest adding that to Kubernetes rather than the standard library.
Note that such persisted data does not have the meaning Kubernetes thinks it does when it ends up in non-Go programs.
For example Curl: https://daniel.haxx.se/blog/2021/04/19/curl-those-funny-ipv4-addresses/.



--- Comment #16 by thockin ---
Understood.  Whether this ACTUALLY impacts users I can not say.  I have
never heard a report around this, but it's a little bit of "the devil you
know".

On Wed, Apr 21, 2021 at 10:25 AM Russ Cox ***@***.***> wrote:

> If Kubernetes needs ParseIPDecimal then I would suggest adding that to
> Kubernetes rather than the standard library.
> Note that such persisted data does not have the meaning Kubernetes thinks
> it does when it ends up in non-Go programs.
> For example Curl:
> https://daniel.haxx.se/blog/2021/04/19/curl-those-funny-ipv4-addresses/.
>
> â€”
> You are receiving this because you commented.
> Reply to this email directly, view it on GitHub
> <https://github.com/golang/go/issues/30999#issuecomment-824230377>, or
> unsubscribe
> <https://github.com/notifications/unsubscribe-auth/ABKWAVHIQG3MZU26SZBPVC3TJ4C67ANCNFSM4HALZAHA>
> .
>


--- Comment #17 by rsc ---

Based on the discussion above, this proposal seems like a **[likely accept](https://golang.org/s/proposal-status#likely-accept)**.
â€” rsc for the proposal review group


--- Comment #18 by rsc ---

No change in consensus, so **[accepted](https://golang.org/s/proposal-status#accepted)**. ðŸŽ‰
This issue now tracks the work of implementing the proposal.
â€” rsc for the proposal review group


--- Comment #19 by FiloSottile ---
I'd like to request a freeze exception for this fix. We deemed it not a backportable security fix (also because of the potential for disruption and the limited real-world impact), but it's conceivable that it could have security value for some applications, so we'd like not to wait for Go 1.18.

/cc @golang/release @rsc

--- Comment #20 by gopherbot ---
Change https://golang.org/cl/325829 mentions this issue: `net: reject leading zeros in IP address parsers`

--- Comment #21 by dmitshur ---
Thank you for making this freeze exception request. It is approved.

--- Comment #22 by cpuguy83 ---
The CVE score for this is 7.3/HIGH

Should this be reconsidered for backport or the score re-evaluated?

--- Comment #23 by rolandshoemaker ---
I don't think there is any new information that would lead us to reconsider backporting this change. CVSS scores are highly subjective, and any security issues that this particular parser issue may introduce are going to be extremely contextual. Using these scores as an indicator of the impact of a vulnerability is a dangerous road to go down.

--- Comment #24 by cpuguy83 ---
That is a very theoretically correct response.
Practically I'm not sure that's how things end up playing out.

What this has done more practically is cause a forcing function and require projects to upgrade to go1.17.

--- Comment #25 by liggitt ---
backporting this to go1.16 would be a breaking change that would prevent some projects from picking up go 1.16 patch releases

--- Comment #26 by ssajal-wr ---
> backporting this to go1.16 would be a breaking change that would prevent some projects from picking up go 1.16 patch releases

Hi, can you please explain why the fix is not applicable to go 1.16 release? This is for my own understanding and for those using the 1.16 release of go in the yocto community. Thanks in advance!

--- Comment #27 by benjsmi ---
Hello. Would actually like to request that this be backported to Go v1.15 if at all possible. We'd be eternally grateful. More explanation can be found in the related comment https://github.com/golang/go/issues/43389#issuecomment-910388105.  In short: we find Go 1.15 to still be supported for amd64 and this issue falls under [CVE-2021-29923](https://nvd.nist.gov/vuln/detail/CVE-2021-29923) along with #43389.  We'd be eternally grateful! Thank you!

--- Comment #28 by tv42 ---
@benjsmi Go1.15 is unsupported, since Go1.16 and Go1.17 have been released. https://golang.org/doc/devel/release#policy

--- Comment #29 by rsc ---
We will not be backporting this issue. We are treating the change as a robustness improvement and not a security fix due to its potential for breaking working use cases.

The situation is not nearly so clear cut as the advocates of CVE-2021-29923 would have people believe. They present it as a bug, plain and simple, not to treat leading zeros in IP addresses as indicating octal numbers, but that's not obvious. The BSD TCP/IP stack introduced the octal parsing, perhaps even accidentally, and because BSD is the most commonly used code, that interpretation is also the most common one. But it's not the only interpretation. In fact, the earliest IP RFCs directly contradict the BSD implementation - they are pretty clear that IP addresses with leading zeros are meant to be interpreted as decimal.

Furthermore, the claimed vulnerability is like a [TOCTTOU problem](https://en.wikipedia.org/wiki/Time-of-check_to_time-of-use) where the check and use are handled by different software with differing interpretation of leading zeros. The right fix is, as it always is, to put the check and use together. 

Rejecting the leading zeros entirely avoids resolving the radix ambiguity the wrong way, which improves robustness. But it can also break existing code that might be processing config files that contain leading zeros and were happy with the radix-10 interpretation.

Given that 
1. the right fix for any security consequence does not involve this change at all (the right fix is to place the check and use in the same program), and that 
2. the Go behavior is entirely valid according to some RFCs, and that 
3. the change has a very real possibility of breaking existing, valid, working use cases, 

we chose to make the change only in a new major version, as a robustness fix, rather than treat it as an urgent security fix that would require backporting. We do not want to push a breaking change that will keep people from being able to pick up  critical Go 1.16 patches later.

--- Comment #30 by benjsmi ---
Thanks for the responses everyone. This is an unfortunate situation but I completely understand why you're handling it this way. 
