=== Fetching Proposal: MDU6SXNzdWU3NDg2OTQ0NTg= ===
Issue URL: https://github.com/golang/go/issues/42782

==== [Issue Title] ====
reflect: add VisibleFields function

==== [Issue Body] ====
When writing code that reflects over a struct type, it's a common requirement to know the full set of struct fields, including fields available due to embedding of anonymous members while excluding fields that are erased because they're at the same level as another field with the same name.

The logic to do this is not _that_ complex, but it's a little subtle and easy to get wrong. I propose a new function in `reflect` (or alternatively a new method on `reflect.Type`) that returns the full set of effective fields that apply in a given struct type.

This method doesn't necessarily need to be hugely performant, as it's common to cache results by type.

This API seems sufficient for most use cases:

```
// VisibleFields returns all the visible fields in t, which must be a
// struct type. A field is defined as visible if it's accessible
// directly with a FieldByName call. The returned fields include fields
// inside anonymous struct members and unexported fields. They follow
// the same order found in the struct, with anonymous fields followed
// immediately by their promoted fields.
//
// For each element e of the returned slice, the corresponding field
// can be retrieved from a value v of type t by calling v.FieldByIndex(e.Index).
func VisibleFields(t Type) []StructField
```

A possible implementation is here: https://play.golang.org/p/S63fPVbo3nN

This function could of course be implemented in an external package, but for lower level codec packages, adding an external dependency can be undesirable, so copy/paste or reimplementation of similar code is common. The functionality is small enough and closely tied enough to the core `reflect` logic that it seems to me that incorporating it there is reasonable.

Thanks to @mvdan and @myitcv for useful early feedback on this proposal.

==== [Comments] ====

--- Comment #1 by ianlancetaylor ---
It would help to point to a couple of cases of existing code that would use this.

--- Comment #2 by dsnet ---
Does `VisibleFields` return the same `[]StructField` for every call or does it allocate a new slice?

For existing precedence, the `StructField.Index` field is always a newly allocated copy:
https://github.com/golang/go/blob/d902791b509b641683d4ec58b282180c56918aec/src/reflect/type.go#L1223-L1230

I would expect `VisibleFields` to have similar semantics.

--- Comment #3 by rogpeppe ---
@ianlancetaylor A grep for `\.NumField\(` in any significant Go corpus will turn up a bunch of examples.
The code I've seen either omits handling for anonymous fields or goes to quite a lot of trouble to support
them properly. One example from the standard library that could have used this: `encoding/binary`, which
doesn't support anonymous fields at all, but perhaps would have if this functionality was available originally.

A few random other example packages:

```
github.com/codegangsta/inject
github.com/google/pprof/internal/driver
github.com/BurntSushi/toml
github.com/golang/net/webdav/internal/xml
```

@dsnet I was thinking that the entire thing would be allocated each time. It would be slow, but if you care about the speed, it's easy to use `sync.Map` keyed by `reflect.Type` to preprocess the information anyway.


--- Comment #4 by rsc ---
Indeed, it seems like we have to allocate a new slice on every call. Caching and reusing will lead to too many bugs, and callers can cache themselves as @rogpeppe pointed out.

Overall this seems reasonable.


--- Comment #5 by rsc ---
Will leave in the minutes for another week for visibility but still seems reasonable.


--- Comment #6 by rsc ---
Based on the discussion above, this seems like a **likely accept**.


--- Comment #7 by gopherbot ---
Change https://golang.org/cl/281233 mentions this issue: `reflect: add VisibleFields function`

--- Comment #8 by rsc ---

No change in consensus, so **[accepted](https://golang.org/s/proposal-status#accepted)**. ðŸŽ‰
This issue now tracks the work of implementing the proposal.
â€” rsc for the proposal review group


--- Comment #9 by rajender ---
Curious, why are we not calling this function ExportedFields?

--- Comment #10 by rogpeppe ---
> Curious, why are we not calling this function ExportedFields?

@rajender because it includes unexported fields too.

--- Comment #11 by dsnet ---
I'm a bit late to the bikeshedding party, but would "ReachableFields" be a better name?

The [Go specification on selectors says](https://golang.org/ref/spec#Selectors):
> A selector f may denote a field or method f of a type T, or it may refer to a field or method f of a nested embedded field of T. The number of embedded fields traversed to **reach** f is called its depth in T. The depth of a field or method f declared in T is zero. The depth of a field or method f declared in an embedded field A in T is the depth of f in A plus one.

Since the `reflect.Value.FieldByName` mirrors the field selector rules, and since the field selector rules uses the verb "reach", it seems sensible to use "reachable" as the adjective. The word "visible" does not appear in the section about selectors.


--- Comment #12 by rogpeppe ---
The issue I have with `ReachableFields` is that even hidden fields are "reachable" - it might just require multiple levels of field indirection to reach them. To me "visible" seems like a more intuitive word in this case. "Visible" is used in a similar fashion in this sentence in the spec:

> the method name is visible only within selectors for type T or *T.

YMMV. Any other bikeshedders out there? :)

