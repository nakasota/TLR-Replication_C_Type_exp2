=== Fetching Proposal: MDU6SXNzdWU0NzEzMzk3NDg= ===
Issue URL: https://github.com/golang/go/issues/33232

==== [Issue Title] ====
spec: allow 'any' for 'interface{}' in non-constraint contexts

==== [Issue Body] ====
**Note, 2021-09-02**: Now that `any` _is_ an alias for `interface{}`, we have a special case that it can only be used in type parameter constraints. This proposal is now to remove that special case, allowing any, well, anywhere.

[This CL](https://go-review.googlesource.com/c/go/+/347296) shows what it would look like if used throughout the Go tree.

\- rsc

---

I would lilke to be able to declare any type with keyword any instead of empty interface, like rune means alias int32.
Such feature make language more readable , without polluting declarations with many empty interfaces. Imho any keyword is perfect for such alias.




==== [Comments] ====

--- Comment #1 by alanfo ---
I often use a type alias for this which isn't much extra work:
```go
type any = interface{}
```

--- Comment #2 by ccbrown ---
I agree with the sentiment that `interface{}` is terrible for readability, but I'm really hoping Go 2 has good enough generics to make nearly all uses of `interface{}` an avoidable anti-pattern. If that happens, an `any` type probably wouldn't be warranted at all. But if for some reason generics just completely fall through, sure, I'd support a builtin `any` alias. I do agree that it would increase readability.

--- Comment #3 by dotaheor ---
I support this proposal, though not strongly.

In the early days of using Go, I often encountered the `map[string]interface{}` type, which is really confusing for a new gopher. I used it for about a year without knowing what it exactly means.

--- Comment #4 by whoiswentz ---
I support this proposal too.

Its simple to implements and the readability becomes better

--- Comment #5 by Freeaqingme ---
I don't support this proposal. The power of Go is that for many things there's a single way of doing things. A language gets bloated easily once we start adding additional syntaxes only because some people prefer one  over the other.

People new to the language may initially learn the 'any' keyword, but then read existing code, and still have to look up the interface{} keyword. Effectively, the burden of learning the language increases, rather than decreases.

--- Comment #6 by MaerF0x0 ---
Yes and on w/ what @Freeaqingme  has said, we also must take care when creating different ways of doing the same thing because: 

1. It makes tooling more difficult: now go tools have to support a new path to the same thing, and likely the users of said tools will expect output to match their chosen flavor of alias. 

2. It reduces the token space for future golang iterations. Consider alternate uses for the `any` token in future iterations of the language. We lose the option of clear expressiveness if we choose to alias `any` to something that is already provided.  Some random ideas of how `any` could be something else:  it could refer to `any` length of array  (`[any]string`) , it could refer to non ZeroValue elements in a slice ( `any mySlice`) like [lodash's compact function ](https://lodash.com/docs/4.17.15#compact) . 

The examples are unimportant, but the point should be clear. If we choose to make this our `any` then we're stuck with it for quite some time, likely for good. 

--- Comment #7 by dotaheor ---
Besides readability reason, less verbose and weird (esp. for new gophers) is another good point of this proposal.

@Freeaqingme 
I began using Go by using Go templates to serve some web pages, I didn't need understand what `interface{}` is. I just needed to know I can assign any vale to it. `any` is far better for this purpose.

When a gopher later suddenly realizes that `any` is just `interface{}`, it is a `viva` moment, which in fact helps gophers understand Go better.

@MaerF0x0 

> It makes tooling more difficult:

`any` is just an alias of `interface{}`, there are many aliases in Go. If a tool can't handle such cases, it is a not qualified tool.

> and likely the users of said tools will expect output to match their chosen flavor of alias.

This is not what a qualified tool should do.

> It reduces the token space for future golang iterations.

Builtin identifiers are not keywords, users can shadow them as needed.


--- Comment #8 by Freeaqingme ---
@dotaheor 
> I just needed to know I can assign any vale to it. any is far better for this purpose.

If you really believe interface{} is so bad, I'd suggest you extend this proposal to deprecate interface{} and eventually remove it. I'm not a fan of that either, but my primary argument was against having two keywords for essentially the same thing. That argument would be moot if interface{} keyword is removed.

@MaerF0x0 
> We lose the option of clear expressiveness if we choose to alias any to something that is already provided. 

We still have 'whatever' and 'anythingReally' as alternatives  :yum:

--- Comment #9 by changkun ---
Is there anyone cloud explain the historical reason of why interface{} is designed as interface{} rather than anything else?

--- Comment #10 by dotaheor ---
@Freeaqingme 
`any` will not be a keyword, it will be just a builtin identifier, just like, `rune` and `byte`, etc.

`interface{}` means an interface type specifying no methods, which happens to make it act as the `any` type. `interface{}` is not a bad thing generally, but using it as the `any` type is bad for new gophers. It confuses many new gophers.

--- Comment #11 by fzipp ---
@Freeaqingme

> If you really believe interface{} is so bad, I'd suggest you extend this proposal to deprecate interface{} and eventually remove it. I'm not a fan of that either, but my primary argument was against having two keywords for essentially the same thing. That argument would be moot if interface{} keyword is removed.

@changkun
> Is there anyone cloud explain the historical reason of why interface{} is designed as interface{} rather than anything else?

It's not a special design, but a logical consequence of Go's type declaration syntax.

You can use anonymous interfaces with more than zero methods:

```
func f(a interface{Foo(); Bar()}) {
    a.Foo()
    a.Bar()
}
```

Analogous to how you can use anonymous structs anywhere a type is expected:

```
func f(a struct{Foo int; Bar string}) {
    fmt.Println(a.Foo)
    fmt.Println(a.Bar)
}
```

An empty interface just happens to match all types because all types have at least zero methods. Removing interface{} would mean removing all interface functionality from the language if you want to stay consistent / don't want to introduce a special case.

--- Comment #12 by Freeaqingme ---
@fzipp good point. I realized that after posting my earlier comment as well. Then it makes zero sense to remove that.

I'm sticking with my original reply; we can simply explain why interface{} is interface{} and how it works. There's then no need to add an additional keyword that basically is/does the same thing.

--- Comment #13 by sirkon ---
@Freeaqingme 

> If you really believe interface{} is so bad, I'd suggest you extend this proposal to deprecate interface{} and eventually remove it. I'm not a fan of that either, but my primary argument was against having two keywords for essentially the same thing. That argument would be moot if interface{} keyword is removed.

There was a built in type alias working like
```go
type byte = uint8
```
in every Go package from the very early days.

It is not me being this proposal supporter or the other way, just a well known fact.

--- Comment #14 by y-usuzumi ---
In Haskell when we write guards:

```haskell
abs n
  | n < 0     = -n
  | otherwise =  n
```

where

```haskell
otherwise = True
```

Just imagine how much less readable it is if one uses `True` in place of `otherwise`.

It's only good if there's a single GOOD way of doing things.

--- Comment #15 by ianlancetaylor ---
If we are able to add generics to the language, then I suspect there will be many fewer cases where people write `interface{}`, so the alias would have correspondingly less value.  Putting on hold pending a decision on generics.

--- Comment #16 by conilas ---
The any value acts like the top type in a type system and it may be usefull sometimes even with generics.

Say we have a higher order function that composes just for logs. You do not need a contract of anything like that for that type if you want to log the argument and then perform the action. Something like (take it as a pseudocode):

```
func add(a interface{}, b interface{}, action fn_type<args>){
  return fn(a, b) -> {
    fmt.Printf("%v %v", a, b)
    action(a, b)    
  }
}
```

The top type would be good in this case instead of writing ```interface{}``` either way, so I think this proposal still have some value.

--- Comment #17 by yiyus ---
Relevant: https://groups.google.com/forum/#!topic/golang-nuts/pxDVtPjatXo

--- Comment #18 by sfllaw ---
Also relevant: https://groups.google.com/g/golang-nuts/c/iAD0NBz3DYw

--- Comment #19 by beoran ---
In the latest generics design, we find the following: 

> However, it‘s tedious to have to write interface{} every time you write a generic function that doesn’t impose constraints on its type parameters. So in this design we suggest a type constraint any that is equivalent to interface{}. This will be a predeclared name, implicitly declared in the universe block. It will not be valid to use any as anything other than a type constraint.

> (Note: clearly we could make any generally available as an alias for interface{}, or as a new defined type defined as interface{}. However, we don't want this design draft, which is about generics, to lead to a possibly significant change to non-generic code. Adding any as a general purpose name for interface{} can and should be discussed separately).

I think the "It will not be valid to use any as anything other than a type constraint." is a bad idea. It is far more simple and consistent to allow the use of the any alias `type any = interface{}` everywhere, in the hope that as generics are introduced, we'll see it getting use less and less in non-generic code.

--- Comment #20 by billinghamj ---
I feel very strongly that `any` should either be allowed in both type parameters and everywhere else, or allowed nowhere at all. And quite strongly that it should be allowed.

Having a confusing-to-beginners pattern of using `interface{}` is negative

Having `any` which means the same thing but is only sometimes allowed will add to this confusion and thus is significantly worse

The only thing we must not do is make it more confusing. Adding `any` would be a nice improvement, but not conditionally

--- Comment #21 by quenbyako ---
I disagree too. Maybe in Dart, Typescript, Rust, etc. it can be good improvement, otherwise in go, you can just put in package simple file like
`extra.go`
``` go
package something

type any = interface{}
type null = struct{} // for channels f.e.

// something that you want to syntax sugaring
```

could be amazing practice! I mean, `any/null` is good, it's more readable, than `interface{}/struct{}`, but it can be implemented just now, in specific cases that you want.


--- Comment #22 by pellared ---
@ianlancetaylor 

> If we are able to add generics to the language, then I suspect there will be many fewer cases where people write `interface{}`, so the alias would have correspondingly less value. Putting on hold pending a decision on generics.

From design proposal:

> So in this design we suggest a type constraint `any` that is equivalent to `interface{}`

If I understand it correctly, it would result in having the "alias" **ONLY** for type parameter constrains (and nowhere else). IMO it would make the language not consistent.

--- Comment #23 by g13013 ---
I believe it would be wise to either rename `any` to `interface{}`, or simply deprecate `interface{}`, having two types that mean the same thing would put a lot confusion and ambiguity for new adopters of go in the future.

--- Comment #24 by fzipp ---
> I believe it would be wise to either rename `any` to `interface{}`, or simply deprecate `interface{}`, having two types that mean the same thing would put a lot confusion and ambiguity for new adopters of go in the future.

@g13013 They are not two types. One is the name (an identifier), the other is the actual thing. It's like being confused about `fmt.Stringer` and `interface{String() string}` existing at the same time.

--- Comment #25 by g13013 ---
@fzipp I think that actually `any` means `interface{}`, am I wrong ?

--- Comment #26 by fzipp ---
@g13013 Yes, `any` is an identifier for `interface{}`, like `fmt.Stringer` is an identifier for `interface{String() string}`.

--- Comment #27 by g13013 ---
`any` is just an alias to `interface{}` it might be called an identifier, still it's the same thing, the point is, having two things that mean the same thing should be avoided.

--- Comment #28 by fzipp ---
@g13013 
Why do you not complain about having two ways to write fmt.Stringer?
You can write `func f(s fmt.Stringer) {}` or you can write `func f(s interface{String() string}) {}`

Why do you not complain about having two ways to write io.Writer?
You can write `func f(w io.Writer) {}` or you can write `func f(w interface{Write(p []byte) (n int, err error)}) {}`

Why is it suddenly a problem with `any` and  `interface{}`?

--- Comment #29 by quenbyako ---
@fzipp if so, how to use `json.Unmarshal` without `interface{}`/`any`?

`any` could be just alias) but i agree, that this problem could be solved without change language specification

--- Comment #30 by g13013 ---
@fzipp I would complain about `func f(s interface{String() string}) {}` and `func f(interface{Write(p []byte) (n int, err error)}`, we would definitely ban them in my team as it makes the code unnecessarily unreadable.

`interface{}` is an another story, its the de facto standard in go to accept any type, I think you got me wrong, if the go team choses to introduce `any` for generics, than the deprecation should happen in the documentation and guides not in the language itself, if we are willing to keep `interface{}`, then I would definitely prefer to write generics with `interface{}` instead of `any`.
