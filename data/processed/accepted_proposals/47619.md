=== Fetching Proposal: MDU6SXNzdWU5NjUwMzY2Nzg= ===
Issue URL: https://github.com/golang/go/issues/47619

==== [Issue Title] ====
slices: add Sort, SortStable, IsSorted, BinarySearch, and func variants

==== [Issue Body] ====
**Update**, Sep 15 2021: the current proposal is at https://github.com/golang/go/issues/47619#issuecomment-915428658.    \- @rsc 

---


This proposal is for use with #43651 (and also relies on the accompanying `constraints` package described in #45458). We propose adding a new generic function for sorting slices in the `sort` package and using this code to implement `sort.Ints`, `sort.Float64s` and `sort.Strings` much more efficiently. Similarly, we will do this for other functionality in the `sort` package.

If this proposal is accepted, the changes will be included with the first release of Go that implements #43651 (we currently expect that that will be Go 1.18).

## Part 1 - exposing generic sort functions in the `sort` package API

We propose exposing a generic sort function for sorting a slice as part of the public API of the `sort` package. Specifically, a new exported function:

```
func SliceOf[T constraints.Ordered](x []T)
```

Typical invocation for some slice of an ordered type (like []int64) will look like this (type inference will obviate the need to specify a type):

```
    sort.SliceOf(s)
```

Sorts the provided slice in-place, similarly to todayâ€™s `sort.Slice`. The name of this function is subject to discussion.
With this function in the `sort` package, we can add deprecation notices to existing concrete sort functions: `sort.Ints`, `sort.Float64s`, `sort.Strings` - though these functions will remain in the package in line with Go 1 compatibility guarantee.

## Part 2 - generic functions for additional `sort` package functionality

We propose to provide a generic version of the current `sort.IsSorted` function:

```
func SliceIsSortedOf[T constraints.Ordered](x []T)
```

Efficient stable sorts:

```
func SliceStableOf[T constraints.Ordered](x []T)
```

Binary search:

```
func SearchSliceOf[T constraints.Ordered](what T, x []T) int
```


## Background - generic sort implementation

An internal sorting function:

```
func orderedSort[T constraints.Ordered](x []T)
```

Can be using the same implementation as the internal `quickSort_func` today, with the type parameter replacing the `interface{}` and having to provide a `less` function. Early benchmarks show that this approach is 3-4x faster than the current `sort.Ints`. This function can be added and used to implement exported functions like `sort.Ints` or `sort.Strings` even if we decide not to add new APIs via this proposal.


==== [Comments] ====

--- Comment #1 by randall77 ---
Does `SearchSliceOf` need the `n` argument? I see it as closer to `SearchInts`/`SearchStrings` than to `Search`, where in the former `n` is the length of the slice.


--- Comment #2 by eliben ---
> Does `SearchSliceOf` need the `n` argument? I see it as closer to `SearchInts`/`SearchStrings` than to `Search`, where in the former `n` is the length of the slice.

Yep, you're right. I've edited the proposal to remove the `n`.

--- Comment #3 by cespare ---
> and using this code to implement `sort.Ints`, `sort.Float64s` and `sort.Strings` much more efficiently.

Changes that speed up the internal implementation probably don't need to go through the proposal process. I think this proposal should focus exclusively on the API additions.

---

`SearchSliceOf` should return an `int` (I assume this was a typo).

---

`SliceOf` would cover the most common use cases, and would become the main `sort` function that people would use, but `sort.Slice`, `sort.Sort`, and others permit the use of custom comparison logic. I think it's natural to extend that to the generic versions (better naming welcomed):

    func SliceWith[T any](s []T, less func(T, T) bool)

Similarly, I think a generic counterpart to `SliceStable` taking a `less` func should also be included.

At that point, I think it would be reasonable to further deprecate `Slice`, `SliceIsSorted`, and `SliceStable`.

---

Similar to the above, I think we should include a search function which operates on a slice but uses a custom comparison func (again, better naming needed).

    func SearchWith[T any](s []T, less func(T, T) bool) int

The majority of my use cases for `sort.Search` are operating on slices of compound types, and this would make that code more readable.

If we do all that, then the shape of the (non-deprecated) sorting API essentially looks like this:

1. Functions for sorting/searching slices of comparable elements (e.g., `SliceOf`).
2. Functions for sorting/searching slices using arbitrary comparison functions (e.g., my `SliceWith`)
3. Functions for sorting/searching any abstract collection of values (e.g., `Sort`, `Search`)

---

Finally, even without my suggested modifications, this proposal will leave the sort API in a fairly messy state: something like ~half of the functions/types will be deprecated, and it's hard to come up with good names for the new functions because all the good names are already used by the old ones. I wonder if we should consider deprecating the entire package and introducing a new sorting package instead.

--- Comment #4 by eliben ---
> > and using this code to implement `sort.Ints`, `sort.Float64s` and `sort.Strings` much more efficiently.
> 
> Changes that speed up the internal implementation probably don't need to go through the proposal process. I think this proposal should focus exclusively on the API additions.
> 
> `SearchSliceOf` should return an `int` (I assume this was a typo).

Thanks, fixed.

> 
> `SliceOf` would cover the most common use cases, and would become the main `sort` function that people would use, but `sort.Slice`, `sort.Sort`, and others permit the use of custom comparison logic. I think it's natural to extend that to the generic versions (better naming welcomed):
> 
> ```
> func SliceWith[T any](s []T, less func(T, T) bool)
> ```
> 
> Similarly, I think a generic counterpart to `SliceStable` taking a `less` func should also be included.
> 
> At that point, I think it would be reasonable to further deprecate `Slice`, `SliceIsSorted`, and `SliceStable`.
> 
> Similar to the above, I think we should include a search function which operates on a slice but uses a custom comparison func (again, better naming needed).
> 
> ```
> func SearchWith[T any](s []T, less func(T, T) bool) int
> ```
> 
> The majority of my use cases for `sort.Search` are operating on slices of compound types, and this would make that code more readable.
> 
> If we do all that, then the shape of the (non-deprecated) sorting API essentially looks like this:
> 
> 1. Functions for sorting/searching slices of comparable elements (e.g., `SliceOf`).
> 2. Functions for sorting/searching slices using arbitrary comparison functions (e.g., my `SliceWith`)
> 3. Functions for sorting/searching any abstract collection of values (e.g., `Sort`, `Search`)

These are reasonable suggestions, and I'd like to see what others think. It's also reasonable to start with a minimal approach, adding just the APIs presented in this proposal, and then add more variants in later releases when we have gained more experience with generics in the stdlib (and perhaps some naming conventions emerge).

> 
> Finally, even without my suggested modifications, this proposal will leave the sort API in a fairly messy state: something like ~half of the functions/types will be deprecated, and it's hard to come up with good names for the new functions because all the good names are already used by the old ones. I wonder if we should consider deprecating the entire package and introducing a new sorting package instead.

This is a good point and something we considered, but it seems like a large step to take in 1.18; I'll be happy to hear other opinions as well, of course.



--- Comment #5 by earthboundkid ---
ðŸš´ :

- ~~SliceIsSortedOf~~ â†’ sort.IsSortedSliceOf
- ~~SliceStableOf~~ â†’ sort.StableSliceOf

The other name suggestions seem fine.

--- Comment #6 by earthboundkid ---
One thing Python has that's there is not a great way to do in Go is sort with a key func. If you're sorting using some expensive transform, it might be nice to run the transform O(N) times instead of O(N log N) times. 

```
func SliceByKey[T1 any, T2 comparable](s []T1, key func(T1) T2)
```

--- Comment #7 by rsc ---
I am not convinced about the Of suffix convention when the T is not essentially required. 
`sort.SliceOf(s)` sounds like it is a slice of s.

Package sort is the completely general sort. 
The title of this issue is "generic functions in the sort package",
but they are not actually generic (in the sense of general) - they are specific to slices.

It seems like sort of slices would fit better in package slices - slices.Sort.
There's going to be a slice-specific implementation anyway, so it's not like being in sort helps share code.
Also, although sorting an ordered slice will be common,
sorting an unordered one will too, and we should provide that.

What about:

```
package slices

func Sort[Elem any](x []Elem, less func(a, b Elem) bool)
func Search[Elem any](x []Elem, ok func(Elem) bool) int
func SortOrdered[Elem constraints.Ordered](x []Elem)
func SearchOrdered[Elem constraints.Ordered](x Slice, target Elem) int
```

?

--- Comment #8 by jimmyfrasche ---
Maybe a third package like `sort/sortslice` so the functions can have shorter names (somewhat unwieldy package name aside) and `slices` doesn't need to pull in a dependency to sort?

--- Comment #9 by rsc ---
I don't think slices would have a dependency on sort at all.


--- Comment #10 by jimmyfrasche ---
Ah, missed the part about it having a separate implementation. Still, putting it in slices doesn't feel right. I would expect to find it in or around sort. I suppose there would be a lot of deprecation messages pointing to the new location regardless.

To add an additional :+1: to the Key request I've written *a lot* of less functions that were just `return a.Field < b.Field`.

--- Comment #11 by eliben ---
> I am not convinced about the Of suffix convention when the T is not essentially required.
> `sort.SliceOf(s)` sounds like it is a slice of s.
> 
> Package sort is the completely general sort.
> The title of this issue is "generic functions in the sort package",
> but they are not actually generic (in the sense of general) - they are specific to slices.
> 
> It seems like sort of slices would fit better in package slices - slices.Sort.
> There's going to be a slice-specific implementation anyway, so it's not like being in sort helps share code.
> Also, although sorting an ordered slice will be common,
> sorting an unordered one will too, and we should provide that.
> 
> What about:
> 
> ```
> package slices
> 
> func Sort[Elem any](x []Elem, less func(a, b Elem) bool)
> func Search[Elem any](x []Elem, ok func(Elem) bool) int
> func SortOrdered[Elem constraints.Ordered](x []Elem)
> func SearchOrdered[Elem constraints.Ordered](x Slice, target Elem) int
> ```
> 
> ?

This is a good point, Russ. It will, though, put us in the uncomfortable (IMHO) situation of having both `sort.Slice` and `slices.Sort`



--- Comment #12 by cespare ---
> It will, though, put us in the uncomfortable (IMHO) situation of having both `sort.Slice` and `slices.Sort`

If `sort.Slice` is documented as being deprecated in favor or `slices.Sort` and `slices.SortOrdered` it shouldn't be *too* confusing.

--- Comment #13 by earthboundkid ---
`sync.Map` has a similar problem.

Here's a solution that makes no one happy: `sort/v2`. Why not do it though?

--- Comment #14 by eliben ---

> There's going to be a slice-specific implementation anyway, so it's not like being in sort helps share code.

A note about this: as the background section of this proposal mentions, a generic implementation of slice sorting will be used to reimplement the existing `sort.Ints`, `sort.Strings` etc. much more efficiently. So there is some sharing of implementation if we do opt for `slices.Sort`. I assume this shared implementation can be placed in `src/internal` then?

--- Comment #15 by ianlancetaylor ---
I opened #47657 for `sync.Map` and friends.

--- Comment #16 by rsc ---

This proposal has been added to the [active column](https://golang.org/s/proposal-status#active) of the proposals project
and will now be reviewed at the weekly proposal review meetings.
â€” rsc for the proposal review group


--- Comment #17 by dsnet ---
A common operation that I do is iterating over a map in sorted manner (usually of a string key).

#47649 provides:
```go
func Keys[K comparable, V any](m map[K]V) []K
```

Which we can combine with the above proposal to do:
```go
ks := maps.Keys(m)
sort.SliceOf(ks)
for _, k := range ks {
    ...
}
```

I wonder if we can simplify this by having `SliceOf` return the input.
```go
for _, k := range sort.SliceOf(maps.Keys(m)) {
    ...
}
```

The detriment of returning the slice is that it makes it ambiguous from the function signature whether `sort.SliceOf` mutates the input in place or copies it.

--- Comment #18 by earthboundkid ---
> A common operation that I do is iterating over a map in sorted manner (usually of a string key).

What about having maps.SortedKeys? Seems like a fairly common need.

--- Comment #19 by dsnet ---
The `maps` package is pretty simple, I don't think we would want a dependency on the relatively complicated `sort` package.

The other direction seems more palatable. We could add `sort.MapKeysOf`:
```go
func MapKeysOf[K constraints.Ordered, V any](m [K]V) []K
```
However, it might be weird that it's signature and operation is different than the similarly named `sort.SliceOf` function.

--- Comment #20 by cespare ---
@dsnet I also find that I need this a lot. However, returning the input just to allow fewer newlines to be typed (which I guess would be called "chaining" if we were talking about methods) isn't the prevailing style. Also, as you say, it makes the signature less obvious; people will be much more likely to call `SliceOf` incorrectly, assuming it doesn't mutate the input.

Personally, your second example seems pretty good to me:

```
ks := maps.Keys(m)
sort.SliceOf(ks)
for _, k := range ks {
    ...
}
```

If we want to shorten it, I agree with @carlmjohnson that we should add to `maps`:

    func SortedKeys[K constraints.Ordered, V any](m map[K]V) []K

Regarding adding this to `sort` vs. `maps`, also note that @rsc proposed adding the slice-sorting stuff to `slices` instead of `sort` in https://github.com/golang/go/issues/47619#issuecomment-897042602, and also we don't need to add a dependency on `sort` to have `maps` provide this function.

I also think in the future for a lot of these use cases I might instead use a sorted container instead (a map that maintains the keys in sorted order; presumably backed by a tree). However, that requires more API design work (especially around iteration) and I expect we won't see anything like that in the standard library before 1.19.

--- Comment #21 by rsc ---
I am not sure we should do the extra return value - it will look like maybe it returns a _different_ slice.

I still believe we should think about slices.Sort instead of sort.NewSliceName; see https://github.com/golang/go/issues/47619#issuecomment-897042602.


--- Comment #22 by eliben ---
Having these functions in the `slices` package certainly makes the naming prettier.

We can just deprecate `sort.Ints`, `sort.Strings` etc. without worrying about making them faster; pointing to `slices.SortOrdered` instead - it replaces both of them.

In your list of new functions:

```
package slices

func Sort[Elem any](x []Elem, less func(a, b Elem) bool)
func Search[Elem any](x []Elem, ok func(Elem) bool) int
func SortOrdered[Elem constraints.Ordered](x []Elem)
func SearchOrdered[Elem constraints.Ordered](x Slice, target Elem) int
```

Is `Search` different from `slices.IndexFunc` because it assumes the slice is sorted (like the `Search*` functions from the `sort` package)? There could be some confusion there, it seems. Since these new `Search*` functions are *not* in the `sort` package, perhaps it will be clearer to call them `BinarySearch*`? 



--- Comment #23 by earthboundkid ---
slices.SortOrdered will probably be as common as slices.Sort, possibly more common. It is also conceptually simpler, if more complicated from a type theoretical point of view. Why not name it like this:

```
package slices

func SortFunc[Elem any](x []Elem, less func(a, b Elem) bool)
func BinarySearchFunc[Elem any](x []Elem, ok func(Elem) bool) int
func Sort[Elem constraints.Ordered](x []Elem)
func BinarySearch[Elem constraints.Ordered](x Slice, target Elem) int
```

--- Comment #24 by deanveloper ---
> `func BinarySearchFunc[Elem any](x []Elem, ok func(Elem) bool) int`

Should probably be `func BinarySearchFunc[Elem any](x []Elem, cmp func(a, b Elem) int) int` (unless i'm mistaken, we need to tell the search algorithm which direction to search in)

--- Comment #25 by rsc ---
@deanveloper, the signature is correct as is. See sort.Search.


--- Comment #26 by deanveloper ---
@rsc Just took a look, never used `sort.Search` itself, just the helpers. Didn't realize that we do not short-circuit if we find the element early.

With the generics implementation, it would likely be better named `less func(Elem) bool` than `ok func(Elem) bool`, right?

--- Comment #27 by rsc ---
@deanveloper, if we were to use that naming, it would be `greaterThanOrEqual func(Elem) bool`, which is a bit of a mouthful.
But really it can be anything you want it to be, so it's probably not great to call it that.


--- Comment #28 by Merovius ---
Like others have said, I don't like the names and the clutter in the `sort` package. I also don't really like putting the functions into `slices`, as sorting requires quite a bit of code and that package is pretty devoid of code otherwise. i.e. the point of avoiding a `slices`->`sort` dependency isn't to not have the edge, but to avoid that package being large.

In other news, `SliceOf[T constraints.Ordered](x []T)` should be `SliceOf[S constraints.Slice[T], T constraints.Ordered](s S)` and similar for the other functions.

--- Comment #29 by rsc ---
Completely agree about adding "Binary" per https://github.com/golang/go/issues/47619#issuecomment-910562505. Thanks @carlmjohnson.

Otherwise, it sounds like people are generally in favor of:

```
package slices

func Sort[Elem constraints.Ordered](x []Elem)
func SortFunc[Elem any](x []Elem, less func(a, b Elem) bool)
func SortStable[Elem constraints.Ordered](x []Elem)
func SortStableFunc[Elem any](x []Elem, less func(a, b Elem) bool)
func IsSorted[Elem constraints.Ordered](x []Elem)
func IsSortedFunc[Elem any](x []Elem, less func(a, b Elem) bool)

func BinarySearch[Elem constraints.Ordered](x Slice, target Elem) int
func BinarySearchFunc[Elem any](x []Elem, ok func(Elem) bool) int
```

(Not completely unanimous but generally in favor.)

--- Comment #30 by jimmyfrasche ---
StableSort[Func] and IsSorted[Func] seems to have gotten dropped from the discussion at some point.
