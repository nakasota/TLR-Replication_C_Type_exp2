=== Fetching Proposal: MDU6SXNzdWU3NTM1MjU0NDk= ===
Issue URL: https://github.com/golang/go/issues/42888

==== [Issue Title] ====
runtime/debug: add SetCrashOutput(file *os.File)

==== [Issue Body] ====
Currently there are difficulties with nicely capturing crash output from Go programs. Crashes print to stderr, however, usually both stdout and stderr are used by programs for other purposes. While it's not wrong to output it to stderr, it mixes two outputs together making later separation more difficult.

Capturing crashes is useful for post-mortem debugging and sending reports. Of course, due to unknown crashed program state using a custom callback is understandably dangerous.

A simpler alternative would be to allow changing file descriptor where to print crashes. In the simplest form it could look like:

```
package main
import "runtime/debug"

func init(){
	debug.SetCrashOutputFD(3)
}
```

This would allow passing in a `fd` for separate file, pipe to another "crash monitor" process or connect to an external server. Of course there's a slight possibility of `write` taking a long time, when passing in a pipe/connection slowing down the crashing of the program.

With regards to naming it could also be `SetCrashFD`, `SetTracebackFD`  or  `SetTracebackOutputFD`.

==== [Comments] ====

--- Comment #1 by prattmic ---
As a data point, the gVisor project wants to redirect panic/throw output. It works around this problem by dup'ing over stderr with the FD of the desired crash output location (https://cs.opensource.google/gvisor/gvisor/+/master:runsc/cli/main.go;l=194-198?q=dup3&ss=gvisor%2Fgvisor). stderr is otherwise unused by the program, so this works OK. This is a workable solution, but it would certainly be nicer to be able to change the destination directly.

--- Comment #2 by mvdan ---
Thinking outloud, the runtime prints other output besides just crashes, such as what one can enable via GODEBUG. Should that be included in this option?

--- Comment #3 by prattmic ---
I'd think (initially, at least), yes. I'd probably call this something like `SetRuntimeFD` for any runtime-generated output.

On the other hand, there are nice opportunities if a separate "fatal" FD could be provided that only includes fatal panic/throw output, plus any related prints immediately before a throw. That would allow a nice simplification of "any bytes received on this FD indicates a crash". But it means extra complexity for a rather edge case [1].

[1] I can't think of any non-fatal runtime output that isn't behind a GODEBUG option.

--- Comment #4 by egonelbre ---
I would say, yes, to including other runtime output as well. If there's a need for additional separation it can be always introduced later. But, I wouldn't be also opposed to introducing it immediately either.

I think the fatal output can be detected when the `fd` write closes due to the program stopping.

--- Comment #5 by alexbrainman ---
@egonelbre how do you propose to use your API on Windows?

I agree. I wanted this feature to capture crash dumps of a Windows service.

/cc @zx2c4 

Alex

--- Comment #6 by zx2c4 ---
I've handled this until now with defer/recover in each go routine, which is really very subpar and doesn't handle all crashes.

Rather than setting an output fd, what about setting an output callback? There'd be certain restrictions on what it could do, obviously, but it could still probably accomplish most things that people want. In my case, it'd just copy the bytes to some mmap'd ring buffer log file.

--- Comment #7 by egonelbre ---
@alexbrainman it would behave in a similar manner that you can provide a `fd` that outputs to a file or a pipe. Flushing it to Event Log would require some external "crash reporting" service that reads that file or pipe. This isn't ideal, but would allow better handling than what can be currently done. Ideal scenario would be to write directly to event-log, however that would probably require specialized machinery.

@zx2c4 I believe the callback has been proposed a few times, however I cannot find the exact proposals. I think the fundamental issue is that you don't know really much about the crashed system - what's broken and what's not. e.g. maybe you got a panic during sigprof where some code holds a runtime lock "x", which your code needs and you'll deadlock when calling `file.Write`. This is all hypothetical of course.

--- Comment #8 by zx2c4 ---
> what's not. e.g. maybe you got a panic during sigprof where some code holds a runtime lock "x", which your code needs and you'll deadlock when calling file.Write. This is all hypothetical of course.

Right. If you're using `debug.SetCrashCallback`, then you are signing up for that kind of fun, and it's up to to write Go code that calls the minimal set of things needed. If the runtime can already do that for spitting to a fd, so can a custom handler function.

> Ideal scenario would be to write directly to event-log, however that would probably require specialized machinery.

Writing to event log isn't too bad. It'd support the callback-based approach I mentioned.
(In my case, log writes look like this: https://git.zx2c4.com/wireguard-windows/tree/ringlogger/ringlogger.go#n105 )

--- Comment #9 by prattmic ---
> Right. If you're using `debug.SetCrashCallback`, then you are signing up for that kind of fun, and it's up to to write Go code that calls the minimal set of things needed. If the runtime can already do that for spitting to a fd, so can a custom handler function.

This means no heap allocation, no stack splits, no map access (IIRC), particularly if you want this to cover runtime `throw`s. Not impossible, but a pretty high bar to set for an API.

--- Comment #10 by zx2c4 ---
> This means no heap allocation, no stack splits, no map access (IIRC), particularly if you want this to cover runtime throws. Not impossible, but a pretty high bar to set for an API.

But also not _so_ out of place for something in debug, right? We're offering some way to hook into runtime internals, and with that comes the responsibilities of being in the runtime. But maybe there's a better idea here:

The other way of doing this might be to have an unstable and unexported function `runtime.setCrashHook`, which can then be used by wrapper packages like:

```go
//go:linkname setCrashHook runtime.setCrashHook
```

That then represents the lowest level. At a higher level, then the debug package can use that to implement things like `debug.SetCrashFD` and the Windows service package can implement things like `svc.SetCrashEventlog`. And then most users use these normal functions that our libraries can provide.

Meanwhile, insane users like me can dip down into `runtime.setCrashHook`, along with all of its dangers, for hooking it up my custom ringbuffer mmap'd logger thing, knowing full well that if anything goes wrong, this is unsupported and my fault, etc.

--- Comment #11 by ianlancetaylor ---
The restrictions on an output callback would be severe, as @prattmic says, and failure modes would be unpredictable.  In Go we try to avoid that kind of deeply unsafe operation.

I think it would be better to keep this issue focused on the much safer operation of setting a file descriptor.

That said, I don't understand what would happen if the descriptor is a pipe that nothing is reading from.  Or a file opened on a networked file system that is not responding.  What should do in cases like that?

--- Comment #12 by zx2c4 ---
> The restrictions on an output callback would be severe, as @prattmic says, and failure modes would be unpredictable. In Go we try to avoid that kind of deeply unsafe operation.

What do you think of my proposal above of allowing this to be a general callback via go:linkname -- i.e. just for libraries? That's a mere "implementation detail", but it'd go a long way of enabling this to be extensible for the adventurous.

--- Comment #13 by prattmic ---
> That said, I don't understand what would happen if the descriptor is a pipe that nothing is reading from. Or a file opened on a networked file system that is not responding. What should do in cases like that?

I'm not sure we need to worry about those (beyond documentation, perhaps). stderr could already be any of those kinds of descriptors, as set by the parent process, so the same problems would exist today.

--- Comment #14 by egonelbre ---
> That said, I don't understand what would happen if the descriptor is a pipe that nothing is reading from. Or a file opened on a networked file system that is not responding. What should do in cases like that?

I guess this is the main danger with the proposal. As @prattmic mentioned, somebody could pipe stderr to somewhere that isn't being read. I didn't test it, but I think that would block in the same way.

Using a non-blocking write that drops data when the fd is not responding would be nice, however I suspect that would be difficult to implement.

It'll definitely need examples how to write the listening side.

Other than that, I don't have any further ideas.

--- Comment #15 by egonelbre ---
This might be still difficult due to the constraints, but if the writing is on a different thread and the previous write hasn't finished in appropriate time, the write can be dropped. The threshold could be configured via GODEBUG or similar.

--- Comment #16 by rsc ---
Should we just have GODEBUG=debugfd=3?

/cc @aclements 

--- Comment #17 by ianlancetaylor ---
@zx2c4 I'm not fond of documenting a callback to use with `go:linkname` either.  I tend to think that people who operate at that level can customize their Go distribution.

--- Comment #18 by aclements ---
I'd be okay with GODEBUG=debugfd=3. It's not straightforward to implement, though, since we don't distinguish between runtime output and anything else printed by `print(ln)`. It would actually be much easier to implement just for tracebacks because we could use something like the `gp.writebuf` redirection, just to an FD instead. But maybe that's better anyway?

I agree with @alexbrainman that I'm not sure how this would work on Windows. Internally, we treat any "fd" other than 1 or 2 as a raw Windows handle value, but I don't know if such a thing can be meaningfully passed as an environment variable. Is it possible for a parent process to create a handle and pass it to a child like this?

On the topic of a callback, in addition to the subtle and rather onerous restrictions on the callback, those restrictions can also change with new releases. We don't expose anything remotely like that right now.

--- Comment #19 by egonelbre ---
I did think about GODEBUG, but I suspect that would be complicated to use in Windows services since you don't have a nice way to figure out the fd prior to starting it. The main process needs to respond to messages (https://github.com/golang/sys/blob/ef89a241ccb347aa16709cf015e91af5a08ddd33/windows/svc/example/service.go#L23).

`debug.SetCrashFD` allows the main process to start a "monitor process" and set the fd accordingly, while the main process can handle the "service" responsibilities.

--- Comment #20 by alexbrainman ---
> @alexbrainman it would behave in a similar manner that you can provide a `fd` that outputs to a file or a pipe. Flushing it to Event Log would require some external "crash reporting" service that reads that file or pipe. This isn't ideal, but would allow better handling than what can be currently done. Ideal scenario would be to write directly to event-log, however that would probably require specialized machinery.

@egonelbre I don't understand what you are suggesting.

If I have a Windows service written in Go, how can I redirect its crash dump to a file by using `debug.SetCrashOutputFD(3)` ? Let's say I want crash dump file to be called c:\a.txt.

Similarly, I don't see how using `debug.SetCrashOutputFD(3)` would help me write to Event Log.

Maybe we can use file path instead of file descriptor? Like `debug.SetCrashOutput("/tmp/a.txt")`.

Alex

--- Comment #21 by aclements ---
@alexbrainman , for writing to a file, I imagine you would open the file and then pass that handle to `debug.SetCrashOutputFD` (or whatever). I don't know how the event log works, but I imagine you'd start a second process with a pipe between them and the second process would be responsible for writing to the event log.

> debug.SetCrashFD allows the main process to start a "monitor process" and set the fd accordingly, while the main process can handle the "service" responsibilities.

Is there a reason this can't be done the other way around? The first process is the monitor process and opens the FD, then starts the second process with the `GODEBUG` environment set. Does this not work for Windows services?

(I'm not necessarily opposed to having a `runtime/debug` function for this, just trying to understand the space of constraints. One nice thing about the environment variable is that it can catch very early panics, like during package init.)

--- Comment #22 by zx2c4 ---
> @zx2c4 I'm not fond of documenting a callback to use with `go:linkname` either. I tend to think that people who operate at that level can customize their Go distribution.

Yea, _documenting_ it is probably the wrong thing to do. But having something in there akin to nanotime would be "very nice"...and would allow me to implement something for Go's Windows service package that uses it to ship things to eventlog automatically.

Anyway, I realize pushing this too hard is an loosing battle, for good reason. But if somehow the implementation _happened_ to be structured in a way that made it _coincidentally possible_ to go:linkname it from elsewhere, I would be very happy.

--- Comment #23 by zx2c4 ---
> Is it possible for a parent process to create a handle and pass it to a child like this?

You can make a handle inheritable, and then pass its value as an argument to the new process. The value will remain the same in the new process. Alternatively, DuplicateHandleEx allows the one process to duplicate a handle _into_ another process.

--- Comment #24 by egonelbre ---
@alexbrainman, so roughly what I'm thinking is the following. However, I might also forget some internal details that could make the following difficult with Windows.

The most basic thing is to send the output to a separate file:

```
package main

import (
	"os"
	"runtime/debug"
)

func main() {
	f, err := os.Open("service_log.txt")
	if err != nil {
		os.Exit(1)
		return
	}

	debug.SetCrashFD(f.Fd())

	// rest of the service logic
}
```

The next step would be to create a watchdog sub-process:

```
package main

import (
	"os"
	"os/exec"
	"runtime/debug"
)

func main() {
	r, w, err := os.Pipe()
	if err != nil {
		os.Exit(1)
		return
	}

	// this could also self-start, but in a different mode
	// but we'll use a separate binary for now
	cmd := exec.Command("watchdog.exe") 
	cmd.Stdin = r
	// also set other flags here to ensure that the watchdog
	// doesn't immediately close together with the parent.
	cmd.Start()

	debug.SetCrashFD(w.Fd())

	// rest of the service logic
}
```

You could also create governors using ExtraFiles:

```
package main

import (
	"os"
	"os/exec"
	"runtime/debug"
)

func main() {
	r, w, err := os.Pipe()
	if err != nil {
		os.Exit(1)
		return
	}

	cmd := exec.Command("watchdog.exe") 
	cmd.ExtraFiles = []*os.File{w}
	cmd.Start()

	// monitor `r`
}

// The other process has `debug.SetCrashFD(3)` in init,
// with some check that `3` actually exists.
```

For windows, I think (named) pipes could also be used:
```
f, err := os.Open(`\\.\pipe\randomhexvalue`)
...
debug.SetCrashFD(f.Fd())
```

--- Comment #25 by egonelbre ---
> The first process is the monitor process and opens the FD, then starts the second process with the GODEBUG environment set. Does this not work for Windows services?

Yes, it could work. The main drawback is that windows services need to respond to control messages. https://pkg.go.dev/golang.org/x/sys/windows/svc#Handler

This would mean that the governor process would need to delegate all those messages to the subprocess, which would introduce an additional complication. Although, there might be a way to make subprocess handle the service messages directly, I haven't seen it.

--- Comment #26 by zx2c4 ---
Avoid using named pipes if you can; they're a security landmine. Instead pass a handle to a child process, as in your other example.

However, I still suspect there's a way that we can log things directly to the eventlog even during a panic, without the need to launch a _persistent_ watchdog process. That's what I was proposing doing with `go:linkname` above.

But if you're really after something maximally robust, a better bet is to share a file mapping -- `CreateFileMapping`/`MapViewOfFile` -- and then have the error handle simply write bytes to an address, and voila, they'll be logged. And if you have a watchdog process monitoring the parent process (via `WaitForSingleObject(OpenProcess(...))` or via `NotifyServiceStatusChange`), it can check this shared memory region after termination.

Alternatively, if you want to forgo the child process entirely, you can actually have a crash reporter process spin up via service triggers if the crashing process is able to raise an ETW event. Check out `SERVICE_TRIGGER_TYPE_CUSTOM`. That's a bit clumsy though, and requires you to be able to successfully call the ETW api from a crashing process.

Perhaps the more robust way to go about this would be to use the built-in Windows Error Reporting functions. Your program could use `WerRegisterMemoryBlock` or `WerRegisterFile` to set up the Go panic output destination, and then WER could collect the info there. Then, Go's panic handler would write to that file, or more reliably, write into that registered memory block. You can then pick this up with the normal default WER crash dump files, or better, have your application use `WerRegisterRuntimeExceptionModule` prior, which will then load a custom DLL of your choosing to then do something useful with the memory block (containing the Go panic output) registered prior.

In other words, if what you're after with this proposal is more robust Windows crash dumps, I think there's actually a lot of room for improvement all over.

--- Comment #27 by egonelbre ---
> Avoid using named pipes if you can; they're a security landmine. Instead pass a handle to a child process, as in your other example.

Fair enough.

> In other words, if what you're after with this proposal is more robust Windows crash dumps, I think there's actually a lot of room for improvement all over.

It was meant as a more general purpose, something that would be useful on unix as well, not just windows.

It would improve the windows service situation. And, I do agree that avoiding subprocess and using the OS api would improve it even more. But, it seems that would be a different proposal.

Although, now thinking of it... maybe, a windows service could use `os.Open()` set the crash fd and use `WerRegisterFile` on it. That way it would end up getting the info.

--- Comment #28 by zx2c4 ---
> Although, now thinking of it... maybe, a windows service could use os.Open() set the crash fd and use WerRegisterFile on it. That way it would end up getting the info.

(Assuming that the Go process is in a position to jump to WriteFile to actually write to the handle. `WerRegisterMemoryBlock` or similar is probably the more robust route.)

--- Comment #29 by ianlancetaylor ---
I suppose a program can always do this by re-execing itself with standard error mapped to some descriptor.  Or you can use a wrapper program to do this.

Is it ever useful to do this other than when starting the program?

--- Comment #30 by zx2c4 ---
Oh, you know if all you're trying to do is `dup2` over stderr on Windows, you can already hack the panic and println output fd like this:

```go
	f, _ := os.Create(`C:\helloworld.txt`)
	windows.SetStdHandle(^uint32(11), windows.Handle(f.Fd()))
	panic("oh nose!")
```

That works reasonably well, even inside of services:

![image](https://user-images.githubusercontent.com/10643/100954990-fc651380-3515-11eb-88c2-8a488484d300.png)

---

Changing the fd isn't particularly difficult, as you can see there, which is why I keep poking at, "what about running custom logger functions?", which is the much more interesting goal (to me, at least).
