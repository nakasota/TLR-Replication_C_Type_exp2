=== Fetching Proposal: MDU6SXNzdWU1NzI0NTYwMDQ= ===
Issue URL: https://github.com/golang/go/issues/37533

==== [Issue Title] ====
flag: exit 0 for default -h/-help option

==== [Issue Body] ====
When the `-help` or `-h` flags are undefined and invoked, the `flag` package handles this situation as a special case and prints a nice and helpful default help text, but exit the process with exit code 2. This proposal proposes the exit code be 0 by default and configurable for this specific case.

Emphasis: this proposal __does not__ propose/incur any changes to programs which has `-h` or `-help` defined.

---

As a concrete example, using `gofmt`, which uses the `flag` package and does not have `-help` or `-h` defined, the behavior today is:

```
$ gofmt -help
usage: gofmt [flags] [path ...]
  -cpuprofile string
        write cpu profile to this file
<...abbreviated...>
$ echo $?
2
```


The proposed behavior is:

```
$ gofmt -help
usage: gofmt [flags] [path ...]
  -cpuprofile string
        write cpu profile to this file
<...abbreviated...>
$ echo $?
0
```

==== [Comments] ====

--- Comment #1 by gopherbot ---
Change https://golang.org/cl/221427 mentions this issue: `flag: exit 0 when -h or -help invoked but undefined`

--- Comment #2 by bitfield ---
If a program is run with an undefined flag, that's an error, because it's being invoked incorrectly. Unless we report this as a non-zero error status, the error will never be detected.

On the other hand, if you explicitly _ask_ for help, using a _defined_ `-help` or `-h` flag, or any other flag, that's fine. That's a zero exit status situation, because you invoked the program with a valid flag and it did what you asked. But you explicitly say that your proposal excludes that situation.

--- Comment #3 by sding3 ---
@bitfield , reading your second paragraph, I think there is a misunderstanding. What I mean is that if the flags `-h` or `-help` are defined, then the `flag` package's treatment of such flags do not change from existing behavior.

The `flag` package already handles `-h` and `-help`, when undefined, as a special case by printing out a help message, which is helpful for the general use case. This proposal only suggests for this case and this case only, which is already handled as a special case in `flag.go`, to exit with 0 instead of 2.

Maybe if you run `gofmt -help`, which uses `flag`, and check the exit code you'll see.

--- Comment #4 by bitfield ---
No, we understand one another correctly, I think. We agree that if the program defines the flag `-h`, then calling the program with it is not an error.

However, if the program does not define `-h`, then the current behaviour of `flag` is that this is an error. You are suggesting changing this. I am saying the current behaviour is correct. Calling a program with an undefined command-line flag is calling the program incorrectly.

--- Comment #5 by rsc ---
/cc @robpike 

--- Comment #6 by rsc ---
The problem here is that although we recognize -h and -help in flag, all that it does is avoid printing "unrecognized flag: -help". Then it calls f.usage, which is user-defined. And essentially all the usage functions in existence do os.Exit(2). I guess those would keep exiting 2. The main flag.Parse loop would see an ErrHelp and I suppose it could treat that case, provided the error handling is set to ExitOnError, as os.Exit(0) instead of os.Exit(2).

It's a bit of a corner case. Do all the other getopt/argparse/etc agree to exit 0 on -help, or is there variation?


--- Comment #7 by as ---
I don't think it's a good idea to have specific behaviors for `-h` and `-help`. There are instances where `-h` does not mean `-help` in some command line tools, and this change can possibly modify the behavior of scripts that use command line tools built in Go.

Ignoring the point above, what is the merit, or usefulness, of homogeneously returning 0 when `-h` is present? What value does it add to tool building or automation?

--- Comment #8 by sding3 ---
@as , this proposal __does not__ propose any changes to go programs that have the `-h` or `-help` flags defined. Further, this proposal __does not__ propose homogeneously returning 0 when -h is present. Sorry if this wasn't clear from the proposal description. I've added a note in the description above to emphasize this point.

This proposal is useful for programs, which do not have the `-h` or `-help` flag defined, and want/need the default usage printing behavior and a zero exit code when such flags are provided. This proposal makes this much easier for these programs (easier, as they basically get it for free by default), yet without changing anything for programs who do have the the `-h` or `-help` flag defined.

--- Comment #9 by sding3 ---
@rsc,  yes, it already is a corner case before this proposal. flag.go has special handling for `h` and `help`.

Looking at argparse for python3 and getopt for GNU C, and both of them exit 0 when programs don't explicitly defined a help flag.

<details><summary>GNU C argp </summary>
<p>

```c
#include <stdlib.h>
#include <argp.h>

const char *argp_program_version =
  "argp-ex2 1.0";
const char *argp_program_bug_address =
  "<bug-gnu-utils@gnu.org>";

static char doc[] =
  "Argp example #2 -- a pretty minimal program using argp";

static struct argp argp = { 0, 0, 0, doc };

int
main (int argc, char **argv)
{
  argp_parse (&argp, argc, argv, 0, 0, 0);
  exit (0);
}

```
---
Produces:
```bash
$ ./a.out --help
Usage: a.out [OPTION...]
Argp example #2 -- a pretty minimal program using argp

  -?, --help                 Give this help list
      --usage                Give a short usage message
  -V, --version              Print program version

Report bugs to <bug-gnu-utils@gnu.org>.

$ echo $?
0
```

</p>
</details>


<details><summary>python3 argparse </summary>
<p>

```python
import argparse

parser = argparse.ArgumentParser(description='Process some integers.')
parser.add_argument('integers', metavar='N', type=int, nargs='+',
                    help='an integer for the accumulator')
parser.add_argument('--sum', dest='accumulate', action='store_const',
                    const=sum, default=max,
                    help='sum the integers (default: find the max)')

args = parser.parse_args()
print(args.accumulate(args.integers))
```
---
Produces:
```bash
$ ./flag.py -h
usage: flag.py [-h] [--sum] N [N ...]

Process some integers.

positional arguments:
  N           an integer for the accumulator

optional arguments:
  -h, --help  show this help message and exit
  --sum       sum the integers (default: find the max)

$ echo $?
0

```

</p>
</details>

--- Comment #10 by mattn ---
The exit code of usage is depend on whether the "help" or "-h" is defined for the application.

```
$ go --help 2> /dev/null
$ echo $?
2

$ go -help 2> /dev/null
$ echo $?
2

$ go -h 2> /dev/null
$ echo $?
2

$ go help > /dev/null
$ echo $?
0
```
argp or argparse provide "-h" or "--help" automatically. If you want to get exit code 0 with -help, you should define "-h" your self, i think.

--- Comment #11 by rsc ---
@sding3, thanks for checking GNU C argp and Python argparse. @ianlancetaylor says that GNU getopt also exits 0 for help. The only one that I'd want to check that's left is BSD getopt, but really it doesn't have any concept of -h or --help at all. I guess most BSD getopt-using programs just treat -h the same as any other unrecognized option. For example, on a Mac:

```
$ ls --help
ls: illegal option -- -
usage: ls [-@ABCFGHLOPRSTUWabcdefghiklmnopqrstuwx1%] [file ...]
$ echo $?
1
$
```

I guess if we're going to go to the trouble of implementing -h and --help as a special case, it would make sense to match all the others.

Does anyone see any argument for _not_ changing the exit status of these to match all other languages we have checked? Thanks.



--- Comment #12 by rsc ---
Based on the discussion above and the lack of objections raised since my last comment, this seems like a **likely accept**.



--- Content after FINAL acceptance decision removed ---