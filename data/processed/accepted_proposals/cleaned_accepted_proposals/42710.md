=== Fetching Proposal: MDU6SXNzdWU3NDYxNTk0NTI= ===
Issue URL: https://github.com/golang/go/issues/42710

==== [Issue Title] ====
hash/maphash: add Bytes and String

==== [Issue Body] ====
**Update**, Mar 16 2022 - Current proposal is https://github.com/golang/go/issues/42710#issuecomment-1067042869.

---

The overhead of constructing a `Hash` object in order to call `Hash.Write` greatly diminishes its utility for small buffers.

Consider the following micro-benchmark:
```go
var source = []byte("hello, world") // 12 bytes long
var sink uint64

func BenchmarkMapHash(b *testing.B) {
	var seed = maphash.MakeSeed()
	for i := 0; i < b.N; i++ {
		var h maphash.Hash
		h.SetSeed(seed)
		h.Write(source)
		sink = h.Sum64()
	}
}

//go:linkname runtime_memhash runtime.memhash
//go:noescape
func runtime_memhash(p unsafe.Pointer, seed, s uintptr) uintptr

func BenchmarkUnsafeHash(b *testing.B) {
	for i := 0; i < b.N; i++ {
		sink = uint64(runtime_memhash(*(*unsafe.Pointer)(unsafe.Pointer(&source)), 0, uintptr(len(source))))
	}
}
```

On my machine this produces:
```
BenchmarkMapHash      	56459700	        21.6 ns/op
BenchmarkUnsafeHash   	246443527	        4.90 ns/op
```
Directly using `runtime_memhash` is around ~4x faster since it avoids all the unnecessary state contained by `Hash` that are relatively pointless when hashing a single small string.

I propose adding the following API:
```go
func Sum(b []byte, seed Seed) uint64
```
where the function is a thin wrapper over `runtime_memhash`. It takes `Seed` as an input to force the user to think about the application of seeds.

I chose the name `Sum` to be consistent with `md5.Sum` or `sha1.Sum`.

==== [Comments] ====

--- Comment #1 by mpx ---
I found `hash/maphash` was unusable for string hashing in a custom map implementation due to performance. It was better to use `runtime.strhash` directly (..and accept potential future maintenance hassle).

Ideally `maphash.Sum([]byte(s), seed)` would also be Fast, but this requires some compiler improvements. Maybe `SumString` should be added as well to address this use case?

--- Comment #2 by dsnet ---
> Ideally `maphash.Sum([]byte(s), seed)` would also be Fast, but this requires some compiler improvements. Maybe `SumString` should be added as well to address this use case?

See #2205. I didn't propose `SumString` cause I'm still hoping for a compiler optimization to avoid these cases.

--- Comment #3 by rsc ---
	for i := 0; i < b.N; i++ {
		var h maphash.Hash
		h.SetSeed(seed)
		h.Write(source)
		sink = h.Sum64()
	}

This is not how it's supposed to be used. You're supposed to do:

	var h maphash.Hash
	h.SetSeed(seed)
	for i := 0; i < b.N; i++ {
		h.Reset()
		h.Write(source)
		sink = h.Sum64()
	}

Can you try that instead?



--- Comment #4 by dsnet ---
> Can you try that instead?

The runtime drops from ~22ns to 20ns, but it's still much slower compared to a direct hash on a `[]byte` (~5ns).

--- Comment #5 by rsc ---
@dsnet, is there a fundamental reason why Write+Sum64 should be so much slower than a single call?
Back when SetSeed was in the loop, I could see SetSeed being fundamentally unnecessarily expensive.
But why is Write+Sum64 fundamentally slower than one call? Do we just have a performance bug somewhere?


--- Comment #6 by dsnet ---
I see several reasons for slowdown:
* `Hash.Write` always performs a [copy on the input slice](https://github.com/golang/go/blob/5627a4dc3013fed02c4b8097413643b682cac276/src/hash/maphash/maphash.go#L96). It's not clear to me how to avoid the copy without fundamentally changing the operation of how `Hash` works. For hashing short strings, half the time is spent on copying (i.e., avoiding the copy brings runtime to 10ns).
* `Hash.Reset`, `Hash.Write`, `Hash.Sum64`, and `Hash.initSeed` are not inlineable. With some massaging, we can probably get all of them except `Hash.Write` to be inlined. Doing so saves a few more ns.

--- Comment #7 by rsc ---
I see. So the copy during the large writes is a bug - we should just hash those bytes directly. Then the benchmark, which hashes a multiple of 64 bytes, would have no copies at all. At that point it seems like the only win is Write+Sum64 combined knowing that the final copy isn't needed. But maybe that's too small a win.




--- Comment #8 by gopherbot ---
Change https://golang.org/cl/278758 mentions this issue: `hash/maphash: optimize Write and WriteString`

--- Comment #9 by gopherbot ---
Change https://golang.org/cl/278759 mentions this issue: `hash/maphash: manually inline setSeed`

--- Comment #10 by josharian ---
I played with this a bit, because I also hit this recently. CLs 278758 and 278759 and 278760 were what I could squeeze out of it. They help a fair amount for large writes, but not much for little ones, which is what I'm working on (trying to reduce the performance regression due to https://github.com/tailscale/tailscale/commit/aa9d7f466550b567e11c317f64ea5eac76d31314).

--- Comment #11 by gopherbot ---
Change https://golang.org/cl/278760 mentions this issue: `hash/maphash: increase the buffer size`

--- Comment #12 by rsc ---
Thanks for working on optimizations, @josharian. We should probably put this proposal on hold until we've made the current API as fast as it can be.


--- Comment #13 by josharian ---
FWIW, I've optimized as much as I know how. I don't see a way to make the current API any faster for small writes. The need to make writes work identically regardless of how they got chunked really ties the hands of the implementation.

--- Comment #14 by rsc ---

**[Placed on hold](https://golang.org/s/proposal-status#hold)**.
â€” rsc for the proposal review group


--- Comment #15 by alandonovan ---
While attempting to fix https://github.com/google/starlark-go/issues/16 I rediscovered this issue and was about to file a bug report, but then stumbled on this one. I'll share my benchmark here in case it's useful.

```
package test_test                                                                                                                                                                                                                                                                                                                                                                               
                                                                                                                                                                                                                                                                                                                                                                                                
import (                                                                                                                                                                                                                                                                                                                                                                                        
        "fmt"                                                                                                                                                                                                                                                                                                                                                                                   
        "hash/maphash"                                                                                                                                                                                                                                                                                                                                                                          
        "math/rand"                                                                                                                                                                                                                                                                                                                                                                             
        "testing"                                                                                                                                                                                                                                                                                                                                                                               
        _ "unsafe" // for linkname hack                                                                                                                                                                                                                                                                                                                                                         
)                                                                                                                                                                                                                                                                                                                                                                                               
                                                                                                                                                                                                                                                                                                                                                                                                
// fnv is the fastest for size < 16, runtime is asymptotically fastest.                                                                                                                                                                                                                                                                                                                         
// maphash only beats fnv at when size >= 128, and is 6x slower than runtime                                                                                                                                                                                                                                                                                                                    
// when size = 1024 even though it's the same algorithm.                                                                                                                                                                                                                                                                                                                                        
//                                                                                                                                                                                                                                                                                                                                                                                              
// Benchmark/maphash-1-12               65962508                17.13 ns/op                                                                                                                                                                                                                                                                                                                     
// Benchmark/fnv-1-12                   1000000000               0.6944 ns/op                                                                                                                                                                                                                                                                                                                   
// Benchmark/runtime-1-12               291040464                3.793 ns/op                                                                                                                                                                                                                                                                                                                    
// Benchmark/maphash-2-12               69972840                17.02 ns/op                                                                                                                                                                                                                                                                                                                     
// Benchmark/fnv-2-12                   1000000000               1.052 ns/op                                                                                                                                                                                                                                                                                                                    
// Benchmark/runtime-2-12               282301180                3.786 ns/op                                                                                                                                                                                                                                                                                                                    
// Benchmark/maphash-4-12               74032375                16.76 ns/op                                                                                                                                                                                                                                                                                                                     
// Benchmark/fnv-4-12                   594186979                1.727 ns/op                                                                                                                                                                                                                                                                                                                    
// Benchmark/runtime-4-12               278877213                4.043 ns/op                                                                                                                                                                                                                                                                                                                    
// Benchmark/maphash-8-12               70253731                16.79 ns/op                                                                                                                                                                                                                                                                                                                     
// Benchmark/fnv-8-12                   420115022                2.600 ns/op                                                                                                                                                                                                                                                                                                                    
// Benchmark/runtime-8-12               291869521                3.903 ns/op                                                                                                                                                                                                                                                                                                                    
// Benchmark/maphash-16-12              72486172                16.24 ns/op                                                                                                                                                                                                                                                                                                                     
// Benchmark/fnv-16-12                  249103671                4.397 ns/op                                                                                                                                                                                                                                                                                                                    
// Benchmark/runtime-16-12              300819609                3.706 ns/op                                                                                                                                                                                                                                                                                                                    
// Benchmark/maphash-32-12              83406832                13.99 ns/op                                                                                                                                                                                                                                                                                                                     
// Benchmark/fnv-32-12                  140682667                8.300 ns/op                                                                                                                                                                                                                                                                                                                    
// Benchmark/runtime-32-12              292491626                4.171 ns/op                                                                                                                                                                                                                                                                                                                    
// Benchmark/maphash-64-12              72692757                16.07 ns/op                                                                                                                                                                                                                                                                                                                     
// Benchmark/fnv-64-12                  74951726                15.94 ns/op                                                                                                                                                                                                                                                                                                                     
// Benchmark/runtime-64-12              200250006                5.884 ns/op                                                                                                                                                                                                                                                                                                                    
// Benchmark/maphash-128-12             43835584                26.30 ns/op                                                                                                                                                                                                                                                                                                                     
// Benchmark/fnv-128-12                 33626848                35.25 ns/op                                                                                                                                                                                                                                                                                                                     
// Benchmark/runtime-128-12             131992580                8.546 ns/op                                                                                                                                                                                                                                                                                                                    
// Benchmark/maphash-256-12             24941272                48.08 ns/op                                                                                                                                                                                                                                                                                                                     
// Benchmark/fnv-256-12                 16829190                66.17 ns/op                                                                                                                                                                                                                                                                                                                     
// Benchmark/runtime-256-12             102915433               11.18 ns/op                                                                                                                                                                                                                                                                                                                     
// Benchmark/maphash-512-12             10526881                96.05 ns/op                                                                                                                                                                                                                                                                                                                     
// Benchmark/fnv-512-12                  9160648               127.0 ns/op                                                                                                                                                                                                                                                                                                                      
// Benchmark/runtime-512-12             64771675                18.82 ns/op                                                                                                                                                                                                                                                                                                                     
// Benchmark/maphash-1024-12             6152947               193.3 ns/op                                                                                                                                                                                                                                                                                                                      
// Benchmark/fnv-1024-12                 4535538               248.3 ns/op                                                                                                                                                                                                                                                                                                                      
// Benchmark/runtime-1024-12            35820849                33.13 ns/op                                                                                                                                                                                                                                                                                                                     
                                                                                                                                                                                                                                                                                                                                                                                                
func Benchmark(b *testing.B) {                                                                                                                                                                                                                                                                                                                                                                  
        for size := 1; size <= 1024; size *= 2 {                                                                                                                                                                                                                                                                                                                                                
                buf := make([]byte, size)                                                                                                                                                                                                                                                                                                                                                       
                rand.New(rand.NewSource(0)).Read(buf)                                                                                                                                                                                                                                                                                                                                           
                s := string(buf)                                                                                                                                                                                                                                                                                                                                                                
                                                                                                                                                                                                                                                                                                                                                                                                
                b.Run(fmt.Sprintf("maphash-%d", size), func(b *testing.B) {                                                                                                                                                                                                                                                                                                                     
                        for i := 0; i < b.N; i++ {                                                                                                                                                                                                                                                                                                                                              
                                maphashString(s)                                                                                                                                                                                                                                                                                                                                                
                        }                                                                                                                                                                                                                                                                                                                                                                       
                })                                                                                                                                                                                                                                                                                                                                                                              
                b.Run(fmt.Sprintf("fnv-%d", size), func(b *testing.B) {                                                                                                                                                                                                                                                                                                                         
                        for i := 0; i < b.N; i++ {                                                                                                                                                                                                                                                                                                                                              
                                fnvHashString(s)                                                                                                                                                                                                                                                                                                                                                
                        }                                                                                                                                                                                                                                                                                                                                                                       
                })                                                                                                                                                                                                                                                                                                                                                                              
                b.Run(fmt.Sprintf("runtime-%d", size), func(b *testing.B) {                                                                                                                                                                                                                                                                                                                     
                        for i := 0; i < b.N; i++ {                                                                                                                                                                                                                                                                                                                                              
                                runtimeHashString(s, 0)                                                                                                                                                                                                                                                                                                                                         
                        }                                                                                                                                                                                                                                                                                                                                                                       
                })                                                                                                                                                                                                                                                                                                                                                                              
        }                                                                                                                                                                                                                                                                                                                                                                                       
}                                                                                                                                                                                                                                                                                                                                                                                               
                                                                                                                                                                                                                                                                                                                                                                                                
// maphashString computes the hash of a string using the maphash package,                                                                                                                                                                                                                                                                                                                       
// which is a wrapper around the implementation used by runtimeHashString.                                                                                                                                                                                                                                                                                                                      
func maphashString(s string) uint32 {                                                                                                                                                                                                                                                                                                                                                           
        var h maphash.Hash                                                                                                                                                                                                                                                                                                                                                                      
        h.SetSeed(seed)                                                                                                                                                                                                                                                                                                                                                                         
        h.WriteString(s)                                                                                                                                                                                                                                                                                                                                                                        
        sum := h.Sum64()                                                                                                                                                                                                                                                                                                                                                                        
        return uint32(sum>>32) ^ uint32(sum&0xFFFFFFFF)                                                                                                                                                                                                                                                                                                                                         
}                                                                                                                                                                                                                                                                                                                                                                                               
                                                                                                                                                                                                                                                                                                                                                                                                
var seed = maphash.MakeSeed()                                                                                                                                                                                                                                                                                                                                                                   
                                                                                                                                                                                                                                                                                                                                                                                                
// runtimeHashString computes the hash of a string using amd64 AESINC hardware.                                                                                                                                                                                                                                                                                                                 
//go:linkname runtimeHashString runtime.stringHash                                                                                                                                                                                                                                                                                                                                              
func runtimeHashString(s string, seed uintptr) uintptr                                                                                                                                                                                                                                                                                                                                          
                                                                                                                                                                                                                                                                                                                                                                                                
// fnvHashString computes the FNV hash of s in software.                                                                                                                                                                                                                                                                                                                                        
func fnvHashString(s string) uint32 {                                                                                                                                                                                                                                                                                                                                                           
        var h uint32                                                                                                                                                                                                                                                                                                                                                                            
        for i := 0; i < len(s); i++ {                                                                                                                                                                                                                                                                                                                                                           
                h ^= uint32(s[i])                                                                                                                                                                                                                                                                                                                                                               
                h *= 16777619                                                                                                                                                                                                                                                                                                                                                                   
        }                                                                                                                                                                                                                                                                                                                                                                                       
        return h                                                                                                                                                                                                                                                                                                                                                                                
}                                                                                                                                                                                                                                                                                                                                                                                               
```                                                                                                                                                                                                                                                                                                                                                                                                

--- Comment #16 by josharian ---
All my optimizations are in. I still think we need new API to make small writes faster.


--- Comment #17 by kixelated ---
Ran into this issue when benchmarking my application.

Here's the worst case scenario:

```golang
func BenchmarkMaphash(b *testing.B) {
    var hash maphash.Hash
    var data [127]byte

    for i := 0; i < b.N; i += 1 {
        hash.Reset()
        hash.Write(data[:])
        hash.Sum64()
    }
}
```

27% of the time is spent in `Write`, where none of the hashing takes place. Like mentioned earlier, this is due to copying the 127 bytes into the buffer, so the hash can be computed when `Sum64` is called. Only 53% of the time was actually spent in `rthash`; the rest was spent record keeping.

I would propose adding a `Sum` method to `Seed`:

```golang
seed := maphash.MakeSeed()
sum := seed.Sum64(data)
```

IMO this fits the API better than a function that takes `Seed` as an argument.

--- Comment #18 by kixelated ---
This proposal would also make the code more readable.

Before:
```golang
var seed = maphash.MakeSeed() // global

var hash maphash.Hash
hash.SetSeed(seed)
_, _ = hash.Write(data)
sum := hash.Sum64()
```

After:
```golang
var seed = maphash.MakeSeed() // global

sum := seed.Sum64(data)
```

--- Comment #19 by kixelated ---
For some more context, I'm hashing a set of strings and a unix timestamp (int64) to use as a map key.

The old code used to sort the strings, append them together, and use strconv to build a string as a key.  The new code uses maphash to hash each string and XOR the hashes together (so order is irrelevant). Then I hash the timestamp with a different seed and XOR it to the hash. It's 5x faster now and has reduced my service's CPU usage by 5%.

I'm using the `unsafe` code in this ticket and it works great. However, I had to fork it into `string` and `int64` variants. Casting the `string` to `[]byte` was more expensive than I had anticipated. For the best performance, it would actually be necessary to expose the type-specific hash functions as defined in `src/runtime/alg.go`.

Maybe something like?

```golang
var nameSeed = maphash.MakeSeed()
var timeSeed = maphash.MakeSeed()

func myHash(names []string, timestamp int64) (sum uint64) {
  for _, name := range names {
    sum ^= nameSeed.HashString(name)
  }

  sum ^= timeSeed.HashInt64(timeSeed)
  return sum
}
```

The current `maphash` API is inadequate because of the aforementioned buffer and it would require the names to be sorted.

--- Comment #20 by bradfitz ---
People were pinging me privately to unhold this per comments above, so done.

--- Comment #21 by gopherbot ---
Change https://go.dev/cl/392494 mentions this issue: `hash/maphash: add BytesSum64 and StringSum64`

--- Comment #22 by rsc ---
Thanks @josharian for optimizing the current API. It looks like you got about 2X, and that there's still about 2X on the table. I mailed [CL 392494](https://go.dev/cl/392494) showing the 2X that remains.

The remaining 2X gap seems fundamental, so it seems reasonable to add new API.

I hesitate to add methods directly on maphash.Seed. That seems like confusing different concepts. And adding new concurrency-safe methods on maphash.Hash confuses when a Hash can be shared by multiple goroutines. That leaves top-level functions, analogous to sha1.Sum and so on, as @dsnet originally suggested.


--- Comment #23 by rsc ---
In the CL I used:

    func BytesSum64(Seed, []byte) uint64
    func StringSum64(Seed, string) uint64

Thumbs up/down: do people think it would be better to use

    func Bytes(Seed, []byte) uint64
    func String(Seed, string) uint64

?


--- Comment #24 by dsnet ---
What about?
```go
func Sum[Bytes interface{ []byte | string }](b Bytes) uint64
```

--- Comment #25 by rsc ---
It's unclear that generics are making things clearer in that case, and I don't know how to implement the function body.


--- Comment #26 by rsc ---
Does anyone object to adding Bytes and String as described in https://github.com/golang/go/issues/42710#issuecomment-1067042869?


--- Comment #27 by rsc ---

Based on the discussion above, this proposal seems like a **[likely accept](https://golang.org/s/proposal-status#likely-accept)**.
â€” rsc for the proposal review group


--- Comment #28 by rsc ---

No change in consensus, so **[accepted](https://golang.org/s/proposal-status#accepted)**. ðŸŽ‰
This issue now tracks the work of implementing the proposal.
â€” rsc for the proposal review group

--- Content after FINAL acceptance decision removed ---