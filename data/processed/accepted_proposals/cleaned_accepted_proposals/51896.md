=== Fetching Proposal: I_kwDOAWBuf85GPHbT ===
Issue URL: https://github.com/golang/go/issues/51896

==== [Issue Title] ====
unicode/utf16: add AppendRune

==== [Issue Body] ====
## Background

[utf16.Encode](https://pkg.go.dev/unicode/utf16#Encode) always allocates a `[]uint16` large enough to fit the UTF-16 encoded sequence, which is really ergonomic but forces one allocation.

## Proposal

**Update**, May 27 2022: The proposed API has changed (see https://github.com/golang/go/issues/51896#issuecomment-1076731715) to:

```go
// AppendRune appends the UTF-16 encoding of the Unicode code point r
// to the end of p and returns the extended buffer. If the rune is not
// a valid Unicode code point, it appends the encoding of U+FFFD.
func AppendRune(p []uint16, r rune) []uint16
``` 

---

**Update**, May 27 2022: The following functions were been superseded by the previous `AppendRune`.

For those cases that the extra allocation matters, `unicode/utf16` could provide an additional encoding function which accepts a pre-allocated (and large enough) backing slice.

The signature would look like this:

```go
// EncodeInto writes into a (which must be large enough) the UTF-16 encoding
// of the Unicode code point sequence s.
func EncodeInto(a []uint16, s []rune) []uint16
```

Optionally, in order to know the minimum size of the backing array,  `unicode/utf16` could provide an additional function which counts the number of code units in a code point sequence.

It would look something like this:

```go
// Countreturns the number of code units in p.
// Invalid encodings are treated as single runes of width 1 byte.
func Count(s []rune) int {
	n := len(s)
	for _, v := range s {
		if v >= surrSelf {
			n++
		}
	}
	return n
}
```

It worth northing that `utf16.Encode` could then be implemented using `utf16.Count` and `utf16.EncodeInto`.

## Examples

My specific use case is to allow `x/sys/windows/mkwinsyscall` generate syscall wrappers which accept `string` arguments without allocating, at least for short strings. Check [this comment](https://github.com/golang/go/issues/51786#issuecomment-1072934787) for more context.

If I had `utf16.EncodeInto` I could implement a non-allocating wrapper as follows:

```go
func Foo(s string) {
	p := []rune(s + "\x00")
	l := utf16.Count(p)
	var a []uint16
	if l < 32 {
		a = make([]uint16, 32)
	} else {
		a = make([]uint16, l)
	}
	a = utf16.EncodeInto(a, p)
	syscall.Syscall6(fnAddr(), 6, 0, uintptr(unsafe.Pointer(&a[0])), 0, 0, 0, 0)
	return
}
```

==== [Comments] ====

--- Comment #1 by randall77 ---
Maybe instead we should have `Append` versions, like #50601 and #51644 ?
If that were the case maybe `Count` wouldn't be necessary? You could rely on `append`s growth to size the buffer correctly (across multiple calls to `Encode`).


--- Comment #2 by qmuntal ---
> Maybe instead we should have `Append` versions, like #50601 and #51644 ? If that were the case maybe `Count` wouldn't be necessary? You could rely on `append`s growth to size the buffer correctly (across multiple calls to `Encode`).

I like your suggestion a lot. It would match nicely [utf8.AppendRune](https://pkg.go.dev/unicode/utf8#AppendRune) and there is no need for `Count`, just setting an initial buffer capacity is enough to avoid some allocations.

My syscall example would look like this:

```go
func Foo(s string) {
	p := []rune(s + "\x00")
	a := make([]uint16, 0, 32)
	for _, r := range p {
		a = utf16.AppendRune(a, r)
	}
	syscall.Syscall6(procBCryptGetProperty.Addr(), 6, 0, uintptr(unsafe.Pointer(&a[0])), 0, 0, 0, 0)
	return
}
```

--- Comment #3 by gopherbot ---
Change https://go.dev/cl/409054 mentions this issue: `unicode/utf16: add AppendRune`

--- Comment #4 by qmuntal ---
Prototyped the proposal in [CL 409054](https://go-review.googlesource.com/c/go/+/409054).

--- Comment #5 by rsc ---

This proposal has been added to the [active column](https://golang.org/s/proposal-status#active) of the proposals project
and will now be reviewed at the weekly proposal review meetings.
â€” rsc for the proposal review group


--- Comment #6 by rsc ---

Based on the discussion above, this proposal seems like a **[likely accept](https://golang.org/s/proposal-status#likely-accept)**.
â€” rsc for the proposal review group


--- Comment #7 by rsc ---

No change in consensus, so **[accepted](https://golang.org/s/proposal-status#accepted)**. ðŸŽ‰
This issue now tracks the work of implementing the proposal.
â€” rsc for the proposal review group

--- Content after FINAL acceptance decision removed ---