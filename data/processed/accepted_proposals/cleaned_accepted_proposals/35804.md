=== Fetching Proposal: MDU6SXNzdWU1Mjc2MjkwMzk= ===
Issue URL: https://github.com/golang/go/issues/35804

==== [Issue Title] ====
database/sql: add error getter on sql.Row

==== [Issue Body] ====
<!-- Please answer these questions before submitting your issue. Thanks! -->

### What version of Go are you using (`go version`)?

<pre>
$ go version
go version go1.13.4 linux/amd64
</pre>

This is a small feature request.

https://github.com/golang/go/blob/6f7b96f6cb5f5c156cf4e69b1fa1ec0e57b01677/src/database/sql/sql.go#L3093-L3097

At this moment `QueryRow()` variants only return a row, and as mentioned in the above comments, for easy chaining. This makes it a bit inconvenient to program against `QueryRow()` if one wants to check the error and return the Row as-is to a higher level caller. For instance, in my usecase I would like to wrap `QueryRow()` in go routines against multiple hosts and return the first successful result.

Would it be possible to have an **error getter method** (eg. `row.Err()`) on the the `sql.Row` type? This way "chaining" is still possible, while giving also more control over the error checking mechanism.

**Edit:** forgot to mention that I'm willing to implement this in a PR myself.

==== [Comments] ====

--- Comment #1 by toothrot ---
Hi @muhlemmer, could you provide a code example of the chaining that this API change would improve?

/cc @bradfitz @kardianos

--- Comment #2 by muhlemmer ---
> Hi @muhlemmer, could you provide a code example of the chaining that this API change would improve?

Example 1:

````
// Node represents a database server connection
type Node struct {
	db             *sql.DB
        // other stuff that keeps track of Node health statistics and re-connection parameters.
}

// CheckErr checks for "serious" errors, like connection and database consistency.
// For example: lib/pq has predefined error codes which can be checked.
// Serious errors are counted as failures.
// If a the configured failure trashhold is reached, this node will we disconnected.
func (n *Node) CheckErr(err error) error {
    // Call helper methods for checking and decision making
    return err  //return the original error
}

// QueryRowContext wrapper around sql.DB.QueryRow.
// Implements boil.ContextExecutor
func (n *Node) QueryRowContext(ctx context.Context, query string, args ...interface{}) *sql.Row {
        row, err := n.DB().QueryRowContext(ctx, query, args...)
	return rows, n.CheckErr(row.Err()) // <--- This is what I would like to do
}

````

Example 2 extends example 1:

````
// MultiNode holds a slice of Nodes.
// All methods on this type run their sql.DB variant in one Go routine per Node.
type MultiNode []*Node

// QueryRowContext runs sql.DB.QueryRowContext on the Nodes in seperate Go routines.
// The first non-error result is returned immediatly.
// Errors from remaining Nodes will not be returned,
// just logged for stastics and descison making.
//
// The following errors can be returned:
// - If all nodes respond with the same error, that exact error is returned as-is.
// - If there is a variaty of errors, they will be embedded in a MultiError return.
//
// Implements boil.ContextExecutor.
func (mn MultiNode) QueryRowContext(ctx context.Context, query string, args ...interface{}) (*sql.Row, error) {
	rc := make(chan *sql.Row, len(mn))
	for _, n := range mn {
		go func(n *Node) {
			rc <- n.QueryRowContext(ctx, query, args...)
		}(n)
	}

	var me MultiError
	for i := 0; i < len(mn); i++ {
		row := <-rc
		if err := row.Err(); err == nil { // <-- Same here: this is what I would like to do
			return row, nil
		} else {
			me.append(err)
		}
	}
	return nil, me.check() // Compare errors and return accordingly.
}
````

I would like both the `Node` and `MultiNode` interface compatible with `sql.DB` and `sql.Tx`. Or more specifically with [this interface](https://github.com/volatiletech/sqlboiler/blob/e004393fa62ca053ec76d14df63d2e066cd2de23/boil/db.go#L15-L22):

````
// ContextExecutor can perform SQL queries with context
type ContextExecutor interface {
	Executor


	ExecContext(ctx context.Context, query string, args ...interface{}) (sql.Result, error)
	QueryContext(ctx context.Context, query string, args ...interface{}) (*sql.Rows, error)
	QueryRowContext(ctx context.Context, query string, args ...interface{}) *sql.Row
}
````

So that I can pass this types as DB or Tx connetion objects to the ORM.

Ultimately, a caller of my package's objects could replace:

````
var int i
err := db.QueryRowContext(ctx, "select $1", 1).Scan(&i)
````
With:

````
var int i
err := nodes.QueryRowContext(ctx, "select $1", 1).Scan(&i)
````
And keep the same chaining as the `database/sql` package currently provides, while my package can inspect the error in any given moment.

--- Comment #3 by muhlemmer ---
I see there is still a `WaitingForInfo` tag on this issue. Is there anything else you would like me to clarify?

--- Comment #4 by ianlancetaylor ---
@muhlemmer Not at this time.  Thanks.

@kardianos Any thoughts on this?  Thanks.

--- Comment #5 by kardianos ---
`*Row` is a struct so adding a new method would be fine, and adding `Err() error` would be symmetric to `*Rows`. I see no technical reason not to add it.

The benefit I would cite to adding it would be it allows you to differentiate query errors from Scan errors and in a framework act appropriately to each.

The two strikes against this proposal is that (1) it makes this less of a convenience method (expands use case rather then just using *Result for most use cases) and (2) I tend to make different types of abstractions then what is presented here.

I'm fine with adding this.


--- Comment #6 by ianlancetaylor ---
@kardianos When you wrote "continence method" did you mean "convenience method"?

--- Comment #7 by kardianos ---
@ianlancetaylor Yes, I intended to write "convenience method" and is in no way a commentary upon my personal continence; though given that I confused the two, may shed doubt upon my cognizance.

--- Comment #8 by rsc ---
Based on the discussion, this seems like a **likely accept**.

Leaving open for a week for final comments.

--- Content after FINAL acceptance decision removed ---