=== Fetching Proposal: I_kwDOAWBuf85GegMM ===
Issue URL: https://github.com/golang/go/issues/51972

==== [Issue Title] ====
sync: add new Map methods CompareAndSwap, CompareAndDelete, Swap

==== [Issue Body] ====
I propose adding a new method on `sync.Map` similar to `atomic.Value`'s `Swap()` method. I think either the name `LoadAndStore()` to match the existing LoadOrStore or `Swap()` to match `atomic.Value` would make sense. The function signature would look something like this
```go
func (m *Map) LoadAndStore(key, newValue any) (previous any, loaded bool)
```

I think the fact that this already exists in `atomic.Value` is a good argument that there is a use case for it. The same thing could be achieved by creating a `sync.Map` of `atomic.Value`s, but that is a lot of type-assertion, and I have to stare at it pretty hard to make sure it's free of race conditions. My specific use case is basically de-bouncing abuse reports. If a worker detects abuse from a client it would
```go
lastReport, hasReportHistory := lastReportTimes.LoadAndStore(clientIP, time.Now())
if hasReportHistory && time.Since(lastReport.(time.Time)) < time.Hour {
    log("not re-sending abuse report")
    return
}
sendAbuseReport(clientIP)
```

==== [Comments] ====

--- Comment #1 by ianlancetaylor ---
CC @bcmills 

--- Comment #2 by rsc ---

This proposal has been added to the [active column](https://golang.org/s/proposal-status#active) of the proposals project
and will now be reviewed at the weekly proposal review meetings.
â€” rsc for the proposal review group


--- Comment #3 by rsc ---
@bcmills, what do you think?


--- Comment #4 by bcmills ---
`func (m *Map) Swap(key, value any) (previous any, loaded bool)` seems like a reasonable addition to me.

It has the right granularity to fit with the other `Map` methods (only synchronizes access to a specific key, and has similar atomicity properties to `LoadOrStore`), and it enables coding patterns that are otherwise complicated or inefficient.

--- Comment #5 by bcmills ---
We may also want to consider `CompareAndSwap` and `CompareAndDelete` at the same time to parallel `(*atomic.Value).CompareAndSwap`, which was added along with `Swap` in proposal #39351. That might look like:

```go
// CompareAndSwap swaps the old and new values for key
// if the value stored in the map is equal to old.
// The old value must be of a comparable type.
//
// If old is the nil interface value, the swap will occur if either there
// is no existing value for the key or the existing value is also the
// nil interface.
func (m *Map) CompareAndSwap(key, old, new any) (swapped bool)

// CompareAndDelete deletes the entry for key if its value is equal to old.
// The old value must be of a comparable type.
//
// If there is no current value for key in the map, CompareAndDelete
// returns false (even if the old value is the nil interface value).
func (m *Map) CompareAndDelete(key, old any) (deleted bool)
```

--- Comment #6 by gopherbot ---
Change https://go.dev/cl/399094 mentions this issue: `sync: add new Map method Swap`

--- Comment #7 by rsc ---
Does anyone object to adding Swap, CompareAndSwap, and CompareAndDelete?



--- Comment #8 by changkun ---
While prototyping the CompareAndDelete, it got me thinking: is it really make sense to have `CompareAndDelete`?

`sync.Map` has two maps inside and is optimized for read-most context.

Since we don't have an atomic compare and delete primitive. What can we do to the read map to compare the old value, and delete it atomically? I could not yet make sense out of this implementation:

```go
func (m *Map) CompareAndDelete(key, old any) (deleted bool) {
	read, _ := m.read.Load().(readOnly)
	if e, ok := read.m[key]; ok {
		if e.tryCompareAndSwap(&old, nil) {
			// Here is clearly(?) non-atomic
			// what if something happens between the above CAS and below delete?
			// Is it possible?
			delete(read.m, key)
			deleted = true
			return
		}
	}

	m.mu.Lock()
	...
}
```

Or is this something I am not going in the right direction of implementation? It looks like to me that we have to lock the entire Map to proceed? Am I overthinking here? What is the fast path in this case?

--- Comment #9 by bcmills ---
@changkun, the use case for `CompareAndDelete` is to delete, say, stale entries from a cache (which otherwise could have the right properties).

If the key is a hit in the read-only map, the entry will still remain but be marked as deleted.

--- Comment #10 by rsc ---

Based on the discussion above, this proposal seems like a **[likely accept](https://golang.org/s/proposal-status#likely-accept)**.
â€” rsc for the proposal review group


--- Comment #11 by rsc ---

No change in consensus, so **[accepted](https://golang.org/s/proposal-status#accepted)**. ðŸŽ‰
This issue now tracks the work of implementing the proposal.
â€” rsc for the proposal review group

--- Content after FINAL acceptance decision removed ---