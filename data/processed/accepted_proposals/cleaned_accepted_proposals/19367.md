=== Fetching Proposal: MDU6SXNzdWUyMTE0NjU3MjA= ===
Issue URL: https://github.com/golang/go/issues/19367

==== [Issue Title] ====
unsafe: add Slice(ptr *T, len anyIntegerType) []T

==== [Issue Body] ====
`reflect.SliceHeader` and `reflect.StringHeader` are clumsy to use because their `Data` fields have type `uintptr` instead of `unsafe.Pointer`.

This proposal is to add types `unsafe.Slice` and `unsafe.String` as replacements. They would be declared just like their package reflect analogs, except with `unsafe.Pointer`-typed `Data` fields:

    type Slice struct {
        Data Pointer
        Len int
        Cap int
    }

    type String struct {
        Data Pointer
        Len int
    }

Additionally, I suggest that for the purposes of type conversion, we treat that `string` and `unsafe.String` have the same underlying type, and also `[]T` and `unsafe.Slice`. For example, these would be valid:

    func makestring(p *byte, n int) string {
        // Direct conversion of unsafe.String to string.
        return string(unsafe.String{unsafe.Pointer(p), n})
    }

    func memslice(p *byte, n int) (res []byte) {
        // Direct conversion of *[]byte to *unsafe.Slice, without using unsafe.Pointer.
        s := (*unsafe.Slice)(&res)
        s.Data = unsafe.Pointer(p)
        s.Len = n
        s.Cap = n
        return
    }

While the same results can be achieved using `unsafe.Pointer` conversions, by using direct conversions the compiler can provide a little extra type safety.

==== [Comments] ====

--- Comment #1 by ianlancetaylor ---
If we do this, we should figure out a way to exempt these new types from the Go 1 compatibility guarantee, so that we can change the representation of strings and slices in the future.  I'm not sure how best to do that.

--- Comment #2 by cespare ---
@ianlancetaylor reflect.SliceHeader and reflect.StringHeader already try:

> It cannot be used safely or portably and its representation may change in a later release.

but the compat doc itself gives a strong exemption for all of unsafe:

> Packages that import unsafe may depend on internal properties of the Go implementation. We reserve the right to make changes to the implementation that may break such programs.

ISTM that unsafe.{Slice,String} would already be exempted sufficiently.

--- Comment #3 by rsc ---
Go 2 seems like the time to think about this (and reflect.SliceHeader etc).

-rsc for @golang/proposal-review 

--- Comment #4 by bcmills ---
This proposal seems a bit redundant with https://github.com/golang/go/issues/13656.

How much of the use-case is "create a string or slice aliasing C memory" vs. "manipulate existing strings and slices by tweaking header fields unsafely"?

--- Comment #5 by mdempsky ---
I'd like to suggest renewing consideration of this proposal for Go 1.14. I think it will be useful for users trying to address issues flagged by -d=checkptr.

I'll also offer a counter-proposal that I think better addresses most end user needs in a more ergonomic manner:

    package unsafe

    func Slice(ptr *ArbitraryType, len, cap int) []ArbitraryType
    func String(ptr *byte, len int) string

[Edit: As discussed below, I'm now in favor of combining Slice's len/cap parameter into a single parameter.]

This is a little less versatile than exposing the Header types, but I think it will minimize typing for most users, while also providing better type safety.

We could also do both this proposal and my original one, if we want to still offer the full flexibility of the Header types. In that case, I would suggest renaming the types to SliceHeader and StringHeader, and reserve the shorter Slice and String identifiers for the constructor functions.

--- Comment #6 by bradfitz ---
I like that counter proposal API.

--- Comment #7 by mdempsky ---
A few additional thoughts to add to my counter proposal:

1. We should decide what happens when `len < 0` or `cap < len`. I'm leaning towards panic, but maybe we should just leave it unspecified/undefined.

    Edit: `ptr == nil && len > 0` is another case to consider.

    Edit 2: Also, `len > MAXWIDTH / unsafe.Sizeof(*ptr)`.

2. The functions would be builtins; in particular, users can't write `f := unsafe.String; f(...)`.

3. The `cap` argument to `unsafe.Slice` can be optional; if it's omitted, the `len` argument is used. (Just like `make([]T, n)` is shorthand for `make([]T, n, n)`.)

4. Perhaps the `int` parameters should actually follow the same goofy semantics that `make([]T, n, m)` follows. (I.e., `make([]T, uint64(10), int8(20))` is valid, even though uint64 and int8 aren't normally assignable to int.)

5. Since `unsafe.String` would be a builtin, it could evaluate to an untyped string.

--- Comment #8 by bcmills ---
That API is closer to what I had suggested in https://golang.org/issue/13656#issuecomment-303216308, and we've been using that variant within Google for a couple of years now without complaints.

If the type desired for the slice does not match the pointer that the user has (for example, if one is a cgo-generated type and the other is a native Go type), I'm assuming that the caller could do something like:
```go
	var s = unsafe.Slice((*someGoType)(unsafe.Pointer(cPtr)), len, cap)
```
to set the element type?

--- Comment #9 by bcmills ---
> We should decide what happens when `len < 0` or `cap < len`. I'm leaning towards panic, but maybe we should just leave it unspecified/undefined.

I would leave it unspecified, but `panic` is a fine implementation of ‚Äúunspecified‚Äù.

> Perhaps the `int` parameters should actually follow the same goofy semantics that `make([]T, n, m)` follows.

That would certainly smooth out the call site in the (overwhelmingly common) case that `len` and/or `cap` is a `C.size_t`.

--- Comment #10 by mdempsky ---
> If the type desired for the slice does not match the pointer that the user has (for example, if one is a cgo-generated type and the other is a native Go type), I'm assuming that the caller could do something like:
> 
> ```go
> 	var s = unsafe.Slice((*someGoType)(unsafe.Pointer(cPtr)), len, cap)
> ```
> 
> to set the element type?

Yeah, that's my thought. If a user wants to convert `*T` into `[]U`, then I think it's reasonable to require an explicit conversion there.

--- Comment #11 by mdempsky ---
> I would leave it unspecified, but panic is a fine implementation of ‚Äúunspecified‚Äù.

Ack, though my concern is if we panic by default, then users might come to rely on it panicking and not write their own checking.

It would be easy to put the panic behind `-d=checkptr` though.

--- Comment #12 by bradfitz ---
> func Slice(ptr *ArbitraryType, len, cap int) []ArbitraryType

Can we instead do:

```
func Slice(ptr *ArbitraryType, len int[, cap int]) []ArbitraryType
```

... with an optional cap. Where omitting cap means cap == len?


--- Comment #13 by mdempsky ---
@bradfitz Yeah, that's my [additional thought #3](https://github.com/golang/go/issues/19367#issuecomment-543927371) above. :)

--- Comment #14 by bcmills ---
> if we panic by default, then users might come to rely on it panicking and not write their own checking.

Hmm, good point. We could make it a throw! üòâ

Or we could make it a `panic` in ordinary code but a `throw` under `-race` or `-d=checkptr`. (The important thing, I think, is to vary it just enough that it causes tests to fail in some reasonably-common configuration.)

--- Comment #15 by mdempsky ---
> (The important thing, I think, is to vary it just enough that it causes tests to fail in some reasonably-common configuration.)

Obviously we should just make it randomly do one or the other, like map iteration order. :>

--- Comment #16 by jimmyfrasche ---
Do you need to be able to specify len < cap? After it's constructed, it's a slice.

--- Comment #17 by bradfitz ---
@jimmyfrasche, good point. Requiring only cap would simplify the API and remove a number of behavior questions.

--- Comment #18 by mdempsky ---
Yeah, I like simplifying it to just:

    func Slice(ptr *ArbitraryType, cap int) []ArbitraryType

It's not much more typing to write `unsafe.Slice(ptr, cap)[:len]` instead of `unsafe.Slice(ptr, len, cap)`, and like @bradfitz points out it's a little simpler to specify and implement.

--- Comment #19 by randall77 ---
> It's not much more typing to write unsafe.Slice(ptr, cap)[:len] instead of unsafe.Slice(ptr, len, cap), and like @bradfitz points out it's a little simpler to specify and implement.

This was my argument against the 3-arg slice op: `a[x:y:z] = a[x::z][:y-x]`, so we would only need the 2-arg `[x:y]` and `[x::y]` operators.  I lost that argument :(


--- Comment #20 by mdempsky ---
https://go-review.googlesource.com/c/go/+/202080 contains a prototype implementation of the counter-proposal for cmd/compile.

Edit: And CL 202082 demonstrates some usage of it within the Go runtime.

--- Comment #21 by gopherbot ---
Change https://golang.org/cl/202080 mentions this issue: `cmd/compile: implement unsafe.Slice and unsafe.String`

--- Comment #22 by gopherbot ---
Change https://golang.org/cl/202082 mentions this issue: `runtime: make use of unsafe.Slice`

--- Comment #23 by gopherbot ---
Change https://golang.org/cl/201839 mentions this issue: `cmd/compile: recognize (*[Big]T)(ptr)[:n:m] pattern for -d=checkptr`

--- Comment #24 by ianlancetaylor ---
@rsc suggests adding a new, optional, parameter to `make` of a slice type:

```Go
    make([]byte, p, l, c)
```

This example would make a new slice of type `[]byte` with the underlying array set to `p`, the length set to `l`, and the capacity set to `c`.  This could be used with any slice type.  The new `p` parameter would be required to have type `unsafe.Pointer` (which would permit distinguishing this new case from existing ones, in which the second parameter must have integer type or be an untyped constant).  The capacity parameter `c` would be optional as it is today.

--- Comment #25 by josharian ---
I don't see how further overloading `make` buys that much in terms of parsimony. And it makes it less obvious at call sites what is going on; the types of the parameters can be effectively invisible to a human reader of code, but `unsafe.Slice` never will be.


--- Comment #26 by bcmills ---
I don't think `make` is actually a great fit. For all other types, `make` allocates some kind of backing store (on either the stack or the heap) and returns header that refers to that backing store.

In contrast, punning an `unsafe.Pointer` to a slice does not allocate any kind of backing store ‚Äî it *only* returns a header that refers to the existing data. That feels like a different operation to me ‚Äî more like a conversion than a `make`.

--- Comment #27 by mdempsky ---
My initial reaction is that having `make` construct a `[]T` from `unsafe.Pointer` is less type-safe than `unsafe.Slice` constructing `[]T` from `*T`, but after re-reviewing the likely use sites, it seems less of a problem than I initially suspected. In most of the cases in CL 202082, the `*T` was explicitly converted from `unsafe.Pointer` anyway.

I think like @josharian says, it might be tricky reading the code to understand what's going on, but I think technically it works and addresses the issue.

--- Comment #28 by mdempsky ---
@bcmills I think there's some analogy to be made to C++'s [placement `new` operator](https://en.cppreference.com/w/cpp/language/new#Placement_new). Normally `new` allocates new memory, but placement `new` uses existing memory.

--- Comment #29 by bradfitz ---
So we going to call it "placement make"? 

--- Comment #30 by bcmills ---
The ergonomics of the ‚Äúplacement make‚Äù form seem worse compared to `unsafe.Slice`. To draw an example from https://golang.org/cl/202082:

Under @mdempsky's proposal, we have:
```go
	scases := unsafe.Slice(cas0, ncases)
```
with the element type propagated from element type of the existing `cas0` variable.

In contrast, under @rsc's alternative we would have:
```go
	scases := make([]scase, unsafe.Pointer(cas0), ncases)
```
