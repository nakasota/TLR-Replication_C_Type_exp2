=== Fetching Proposal: MDU6SXNzdWU2NTA1OTg2OTk= ===
Issue URL: https://github.com/golang/go/issues/40025

==== [Issue Title] ====
proposal: io/ioutil: move Discard, NopCloser, ReadAll to io

==== [Issue Body] ====
io/ioutil exists mainly to avoid import cycles: it can make use of packages that themselves depend on io.

The practical effect of this is that io/ioutil is mainly about convenient OS file access: ReadDir, ReadFile, TempDir, TempFile, and WriteFile. These are here because os was too low level, and io cannot import os. (For more about why `io` should not depend on `os`, see “[Codebase Refactoring (with help from Go)](https://talks.golang.org/2016/refactor.article)”, especially section 3.)

The three functions that don't quite fit this bill are Discard, NopCloser, and ReadAll. These are general, useful I/O helpers without dependencies, at least conceptually. They don't need to be in io/ioutil. 

It is confusing that nearly all reader and writer adapters—like LimitReader, MultiReader, MultiWriter, TeeReader, SectionReader—are in io, while NopCloser and Discard hide in io/ioutil. They should join the others. I think it was mostly accidental that they ended up in io/ioutil.

It is similarly confusing that the reader and writer helpers—Copy, CopyBuffer, CopyN, ReadAtLeast, ReadFull, WriteString—are all in io, while ReadAll alone hides in io/ioutil. It too should join the others. 

In the case of ReadAll, there is a clearer reason why it was relegated to io/ioutil: it imports bytes for access to bytes.Buffer, and bytes imports io. But ReadAll need not use bytes.Buffer, especially now that we have `append` built in.

Obviously we cannot delete these three from io/ioutil. But we can move the implementations to io and leave wrappers behind. That will be easier for new users, and it lets more packages do general I/O without a dependency on os.

**Edit**: To be clear, _no existing code will break_. The old symbols will remain behind, as wrappers of the ones in io.

==== [Comments] ====

--- Comment #1 by josharian ---
And if we moved the remaining functions to a new package, `io/fileio`, we could deprecate io/ioutil entirely.

But should this happen as part of a stdlib v2? It is backwards compatible, but at the cost of a fair amount of duplication.


--- Comment #2 by rsc ---
The fileio suggestion is #19660 for what it's worth.

--- Comment #3 by rsc ---
For what it's worth, I think we can correct these three symbols without waiting for a more comprehensive stdlib v2.
They clearly belong in io, by almost any criteria. (And we're not likely to start chopping up io or anything like that.)

The remaining symbols I think we can deal with at another time. It's possible they just belong in os, instead of isolated in a side package all by themselves, except that there's already an os.TempDir.




--- Comment #4 by rsc ---
The reactions I see above (one comment, bunch of emoji) are all positive. Does anyone object to accepting this proposal?


--- Comment #5 by magical ---
No objection from me. I can never remember what's in ioutil vs io.

--- Comment #6 by rsc ---
Based on the discussion above, this seems like a **likely accept**.

(Part of the reason to do this is that then you never have to use io/ioutil when working with a non-operating-system [fs.FS](https://golang.org/s/draft-iofs-design). io/ioutil becomes OS-only.)

--- Content after FINAL acceptance decision removed ---