=== Fetching Proposal: MDU6SXNzdWU2NjgwMTc3OTU= ===
Issue URL: https://github.com/golang/go/issues/40481

==== [Issue Title] ====
unsafe: add Add function

==== [Issue Body] ====
@mdempsky has a [proposal from 2014 ](https://docs.google.com/document/d/1yyCMzE4YPfsXvnZNjhszaYNqavxHhvbY-OWPqdzZK30/pub) to add unsafe.Add, analogous to the existing (unexported) runtime function

```
func add(p unsafe.Pointer, x uintptr) unsafe.Pointer {
       return unsafe.Pointer(uintptr(p) + x)
}
```

#19367 is about adding unsafe.Slice, and #395 is about slice to array conversion. Doing unsafe.Add at the same time would be a good bundle so that people who want to clean up uses of unsafe can do it all at one time.

This issue is to propose unsafe.Add, probably as a function, but maybe as a method on Pointer? Matthew's doc discusses the tradeoffs there.


==== [Comments] ====

--- Comment #1 by seebs ---
```func (base Pointer) Add(offset uintptr) (derived Pointer) { ... }```
?

... oh you actually already suggested that. I guess consider this a vote for a method, analogous to `time.Add()`. And this implies, perhaps, ```func (derived Pointer) Sub(base Pointer) (offset uintptr) { ... }```


--- Comment #2 by mdempsky ---
@seebs The proposal mentions `Sub` at the bottom too.

--- Comment #3 by mdempsky ---
In addition to `unsafe.Add` (or `unsafe.Pointer.Add`), I think it would also be worth considering adding some methods to package reflect like:

    func (h *SliceHeader) DataPointer() unsafe.Pointer { return unsafe.Pointer(h.Data) }
    func (h *SliceHeader) SetDataPointer(p unsafe.Pointer) { h.Data = uintptr(p) }

    func (h *StringHeader) DataPointer() unsafe.Pointer { return unsafe.Pointer(h.Data) }
    func (h *StringHeader) SetDataPointer(p unsafe.Pointer) { h.Data = uintptr(p) }

    func (v Value) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(v.Pointer()) }

If these methods were in place, we could issue vet warnings against using accessing `Data` directly or calling `Value.Pointer` or `Value.Addr`. `unsafe.Pointer(v.UnsafeAddr())` can be rewritten to `v.Addr().UnsafePointer()`, but we could also add variant of `UnsafeAddr` that returns `unsafe.Pointer` directly too.

Together with `unsafe.Add`, I think this would eliminate any need for `uintptr` -> `unsafe.Pointer` conversions. For backwards compatibility, we'd still need to support them; but we'd at least be able to guide users towards less-error-prone solutions.

Historically, package reflect couldn't return `unsafe.Pointer` values directly, because of safe mode, which restricted use of `unsafe.Pointer`. But we removed safe mode in 2018, as we have better ways to sandbox untrusted Go programs nowadays and restricting use of `unsafe.Pointer` is intrusive upon the Go ecosystem.

--- Comment #4 by seebs ---
Hmm. I sort of like that, but a concern would be that it's potentially wrong to set the data pointer without first setting len/cap appropriately, so if you have a SetDataPointer, but not the other parts, I feel like this will be a temptation to do unsafe things.

(And just a wild loose-end idea: Distinguish between `runtime.Pointer` and `unsafe.Pointer`, with runtime.Pointer only permitting/admitting known-safe operations, while `unsafe.Pointer` admits risky ones? Probably not useful, though.)

--- Comment #5 by mdempsky ---
> it's potentially wrong to set the data pointer without first setting len/cap appropriately

The order that you set data/len/cap don't matter as long as you set all of them before using the underlying string/slice again.

However, it's a fair point that maybe:

    func (h *SliceHeader) Get() (data unsafe.Pointer, len, cap int)
    func (h *SliceHeader) Set(data unsafe.Pointer, len, cap int)

    func (h *StringHeader) Get() (data unsafe.Pointer, len int)
    func (h *StringHeader) Set(data unsafe.Pointer, len int)

would be a useful abstraction instead or as well. In fact, I think abstracting away the fields into methods like this would address the long-term compatibility issues that "It cannot be used safely or portably and its representation may change in a later release." are meant to caveat. No matter the underlying representation, these methods could still work.

Though this also starts trending towards overlap with the earlier suggestions of #19367.

> And just a wild loose-end idea: Distinguish between runtime.Pointer and unsafe.Pointer, with runtime.Pointer only permitting/admitting known-safe operations, while unsafe.Pointer admits risky ones?

Do you have any known-safe operations in mind that aren't already supported by `interface{}` or `reflect.Value`?

--- Comment #6 by seebs ---
I saw a thing, somewhere, which said in passing that it was important to set len/cap to either 0 or the smaller of the values before setting data, or else you'd have an inconsistent state, but on consideration I can't see why it would matter unless something else was accessing the slice concurrently, which it presumably shouldn't be. I'm now trying to remember where I saw this, and what the rationale was.

As to known-safe: My vague idea was roughly that a runtime.Pointer might be a richer datatype, which also had information about known bounds, so it could reject or fail an Add() or a Sub() with invalid parameters, while unsafe.Pointer would assume you know what you're doing. This is probably a large and separate idea, and probably not a great idea, but I am a bit stream-of-consciousness some days. So, runtime.Pointer wouldn't imply genuine and complete knowledge of a pointer's real bounds, it would just be working from provenance; if you have a `var a [7]int`, and you get a runtime.Pointer to a[0], it's the address plus the knowledge that the bounds are [0,7*sizeof(int)], so it can detect/diagnose modifications.

I'm admittedly also coming up light on circumstances where you have enough information that this would be useful, but you also have any reason to use pointers and pointer arithmetic.

--- Comment #7 by mdempsky ---
> it was important to set len/cap to either 0 or the smaller of the values before setting data, or else you'd have an inconsistent state

Yeah, this at least isn't an issue under any existing Go implementation (to my knowledge). The Go runtime's GC only pays attention to the `Data` field; it doesn't care about the `Len` or `Cap` fields. And when it comes to concurrent access, you'll need to synchronize access to the entire slice/string value anyway, so the order you update individual fields doesn't matter. (Unless you're doing sequenced atomic stores of each field, but then you need matched atomic loads at access sites; at which point you're talking about an application-specific synchronization protocol, not a general Go coding pattern.)

> My vague idea was roughly that a runtime.Pointer might be a richer datatype, which also had information about known bounds, so it could reject or fail an Add() or a Sub() with invalid parameters

I think you're describing reflect.Value. :)

--- Comment #8 by beoran ---
I like the original proposal, so I'd also like to get the  func unsafe.Sub(p, q Pointer) uintptr, func unsafe.Less(p, q Pointer) uintptr, and func unsafe.IsSameVariable(p, q Pointer) bool as well, please :) . With all of them in place, pointer arithmetic will become a lot easier to do right in Go. 

--- Comment #9 by rsc ---
@beoran, while you might use unsafe.Add with the offsets you find in reflect information (particularly in StructField), I can't think of a corresponding time when you should ever use unsafe.Sub. Pointer arithmetic like in C is _not_ safe, because you may construct an invalid pointer (C doesn't care, but Go does), nor is it a goal. Am I missing some typical use of subtracting pointers in Go? I've written plenty of unsafe code and can't remember ever doing that.

@mdempsky, we should probably start a separate discussion for the SliceHeader/StringHeader changes. It's unclear to me how much is left after unsafe.Slice is added. It's also unclear to me whether we should do new methods or just define better new types (with an unsafe.Pointer-typed field).






--- Comment #10 by rsc ---
Other topics aside, the reception to adding unsafe.Add seems overwhelmingly positive on the reactions, with no objections in the text here.

This seems like a **likely accept**. 
(Not trying to cut off the discussion of other changes - we can certainly discuss them separately.)


--- Content after FINAL acceptance decision removed ---