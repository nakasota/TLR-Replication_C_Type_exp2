=== Fetching Proposal: I_kwDOAWBuf85BMK5l ===
Issue URL: https://github.com/golang/go/issues/50436

==== [Issue Title] ====
os/exec: add fields for managing termination signals and pipes

==== [Issue Body] ====
### Background

#23019 (accepted but not yet implemented; CC @ianlancetaylor @bradfitz) proposed to change `exec.Cmd.Wait` to stop the goroutines that are copying I/O to and from a completed `exec.Cmd`; see that proposal for further background on the problem it aims to address. However, as noted in https://github.com/golang/go/issues/23019#issuecomment-396372555 and https://github.com/golang/go/issues/23019#issuecomment-558416418, any feasible implementation of the proposal requires the use of an arbitrary timeout, and the proposal does not include a mechanism to adjust that timeout. (Given our history with the Go project's builders, I am extremely skeptical that any particular hard-coded timeout can strike an appropriate balance between robustness and latency.)

#31774, #22757, and #21135 proposed to allow users of `exec.CommandContext` to customize the signal sent to the command when the context is canceled. They were all declined due to lack of concrete demand for the feature (https://github.com/golang/go/issues/21135#issuecomment-332006025, https://github.com/golang/go/issues/22757#issuecomment-345034265, https://github.com/golang/go/issues/31774#issuecomment-490246274). We have since accrued a number of copies of functions that work around the feature's absence. In the Go project alone, we have:
* https://cs.opensource.google/go/go/+/master:src/cmd/go/script_test.go;l=1233-1292;drc=af3b8cf5026a9d74a53ac5d3fec2bba35a96ad91
* https://cs.opensource.google/go/go/+/master:src/internal/testenv/testenv.go;l=312-366;drc=cc795a01dcec7c97044b31571af88ac98310f2b3 (added for #37405)
* https://cs.opensource.google/go/x/build/+/master:internal/internal.go;l=28-86;drc=fa5c6e87e680b621066712172cd92426fb206416
* https://cs.opensource.google/go/x/playground/+/master:internal/internal.go;l=14-70;drc=ccdf1e5d22bc9653f3a3b58016d2c9914ebaad48

I'm attempting to add yet another variation (in [CL 373005](https://go.dev/cl/373005)) in order to help diagnose #50014. However, for this variation (prompted by discussions with @aclements and @prattmic) I have tried to make this variation a minimally-invasive change on top of the `exec.Cmd` API.

I believe I have achieved that goal: the API requires the addition of only 2â€“3 new fields and no new methods or top-level functions. You can view (and try out) a prototype as [`github.com/bcmills/more/os/moreexec`](https://pkg.go.dev/github.com/bcmills/more/os/moreexec), which provides a drop-in replacement for a subset of the `exec.Cmd` API.

### Proposal

I propose the addition of the following fields to the `exec.Cmd` struct, along with their corresponding implementation:

```go
	// Context is the context that controls the lifetime of the command
	// (typically the one passed to CommandContext).
	Context context.Context

	// If Interrupt is non-nil, Context must also be non-nil and Interrupt will be
	// sent to the child process when Context is done.
	//
	// If the command exits with a success code after the Interrupt signal has
	// been sent, Wait and similar methods will return Context.Err()
	// instead of nil.
	//
	// If the Interrupt signal is not supported on the current platform
	// (for example, if it is os.Interrupt on Windows), Start may fail
	// (and return a non-nil error).
	Interrupt os.Signal

	// If WaitDelay is non-zero, the command's I/O pipes will be closed after
	// WaitDelay has elapsed after either the command's process has exited or
	// (if Context is non-nil) Context is done, whichever occurs first.
	// If the command's process is still running after WaitDelay has elapsed,
	// it will be terminated with os.Kill before the pipes are closed.
	//
	// If the command exits with a success code after pipes are closed due to
	// WaitDelay and no Interrupt signal has been sent, Wait and similar methods
	// will return ErrWaitDelay instead of nil.
	//
	// If WaitDelay is zero (the default), I/O pipes will be read until EOF,
	// which might not occur until orphaned subprocesses of the command have
	// also closed their descriptors for the pipes.
	WaitDelay time.Duration
```

The new `Context` field is exported only in order to simplify the documentation for the `Interrupt` and `WaitDelay` fields. (It was requested and rejected in #46699, but the objection there was my own â€” due to concerns about the interactions with the API in <em>this</em> proposal. It could be excised from this proposal without damaging anything but documentation clarity.)

The new `Interrupt` field sets the signal to be sent when the `Context` is done. `exec.CommandContext` explicitly sets it to `os.Kill` in order to maintain the existing behavior of `exec.CommandContext`, but I expect many users on Unix platforms will want to set it to `os.Interrupt` or `syscall.SIGQUIT` instead.

The new `WaitDelay` field sets the interval to wait for input and output after process termination or an interrupt signal. That interval turns out to be important for many testing applications (such as the Go Playground implementation and the `cmd/go` test suite). It also generalizes nicely to the use-cases in #23019: setting `WaitDelay` without `Context` provides bounded I/O wait times without sending a preceding signal.

### Compatibility

I believe that this proposal is entirely backward-compatible (in contrast with #23019). The zero-values for the new fields provide exactly the same behavior as a `Cmd` returned by `exec.Command` or `exec.CommandContext` today.

### Caveats

This proposal does not address graceful shutdown on Windows (https://github.com/golang/go/issues/22757#issuecomment-773581159; CC @mvdan). However, it may be possible to extend it to do so by providing special-case Windows behavior when the `Interrupt` field is set to `os.Interrupt`, or by adding an `InterruptFunc func(*Cmd)` callback that would also be invoked when `Context` is done.

The proposed API also does not provide a mechanism to send an `Interrupt` signal followed by `os.Kill` after a delay <em>but still wait for subprocesses</em> to close all I/O pipes. I believe the use-cases for that scenario are sufficiently niche to be provided only by third-party libraries: sending `SIGKILL` to the parent process makes it likely that subprocesses will not know to shut down, so in the vast majority of cases users should either not send `SIGKILL` at all (`WaitDelay` == 0), forcibly terminate the pipes to try to kill the subprocesses with `SIGPIPE` (`WaitDelay` > 0), or do something platform-specific to try to forcibly shut down an entire process group (outside the scope of this proposal).

### Alternatives considered

In https://github.com/golang/go/issues/31774#issuecomment-488320719, @bradfitz suggested a field `Kill func(*os.Process)`, which would presumably be added instead of the `Interrupt` field in this proposal. However, I believe that such a field would be simultaneously too complex and not powerful enough:

* The `Kill` field would be too complex for most Unix applications, which overwhelmingly only need to send one of `SIGTERM`, `SIGINT`, `SIGQUIT`, or `SIGKILL` â€” why pass a whole callback when you really just want to say which signal you need?

* A `*os.Process` callback would still not be powerful enough for Windows applications. If I understand the discussion in #6720 correctly (CC @alexbrainman), `CTRL_BREAK_EVENT` is sent to an entire process group, not a single `*os.Process`, so Windows users would also need a mechanism for creating (or determining) such a group, or some completely separate out-of-band way to request that the process terminate (such as by sending it a particular input or IPC message).

Given the above, the `Interrupt` field seems more ergonomic: it gives the right behavior for Unix users, and if Windows users want to do something more complex they can set `Interrupt` to `nil` and start a separate goroutine in between the calls to `(*Cmd).Start` and `(*Cmd).Wait` to implement whatever custom logic they want.

==== [Comments] ====

--- Comment #1 by gopherbot ---
Change https://golang.org/cl/373005 mentions this issue: `internal/moreexec: add a utility package for manipulating os/exec.Cmd`

--- Comment #2 by seebs ---
> // If the command's process is still running after WaitDelay has elapsed,
> // it will be terminated with os.Kill before the pipes are closed.

I think this may be innately race-prone in that theoretically, the process can terminate and be replaced by a new process with that PID between the check and the kill. I have vague recollections of someone having told me there's a fancy new feature in some Linuxes that could bypass this, and it's admittedly a very small window for a very large amount of stuff to happen.

--- Comment #3 by seebs ---
I'm a bit unclear on the meaning of the exported fields. Are they required to be set prior to launching a command, or can they be changed during the lifespan of the command? What happens if I change c.Interrupt after starting a process? What happens if I write a new value into c.Context while the process is running, and then after doing that close the previous context? etc.

I'm not sure what the answers should be, I'm pretty sure that any reasonably plausible answer will be fine, but I think it should be explicit. I think I'd favor "Context is a read-only field once the command is started, Interrupt and WaitDelay are both writeable".

--- Comment #4 by bcmills ---
> the process can terminate and be replaced by a new process with that PID between the check and the kill.

That is #13987, which seems orthogonal.

--- Comment #5 by bcmills ---
> I'm a bit unclear on the meaning of the exported fields. Are they required to be set prior to launching a command, or can they be changed during the lifespan of the command?

They are like the other (existing) exported fields of `exec.Cmd`: they must be set prior to `Start` (or equilavent) and then not modified until `Wait` (or equivalent) returns.

--- Comment #6 by seebs ---
It is the same issue as 13987, but it's a new circumstance in which we hit that which might be non-obvious to a user, who is assuming that if we are killing "the" process, we'll pick the right one.


--- Comment #7 by bcmills ---
That's true, but applies equally to all of the (numerous) workarounds that build the same behavior on top of `os/exec.Cmd` today. (I don't think this proposal makes that race any _worse_ for anybody than it already is.)

--- Comment #8 by ianlancetaylor ---
> theoretically, the process can terminate and be replaced by a new process with that PID between the check and the kill. I have vague recollections of someone having told me there's a fancy new feature in some Linuxes that could bypass this, and it's admittedly a very small window for a very large amount of stuff to happen.

The Go standard library already uses that feature (the `waitid` or `wait6` system call with an option of `WNOWAIT`) on Linux, DragonFly, and FreeBSD.  (For a while we used `waitid` on macOS but stopped doing so due to #19314.)

--- Comment #9 by mvdan ---
> However, as noted in [#23019 (comment)](https://github.com/golang/go/issues/23019#issuecomment-396372555) and [#23019 (comment)](https://github.com/golang/go/issues/23019#issuecomment-558416418), any feasible implementation of the proposal requires the use of an arbitrary timeout, and the proposal does not include a mechanism to adjust that timeout. (Given our history with the Go project's builders, I am extremely skeptical that any particular hard-coded timeout can strike an appropriate balance between robustness and latency.)

I share this concern enthusiastically. Depending on what program you're executing, and in what environment and context, you may need very different timeouts. I also agree that we should let the user decide. As much as I would love for Go to just "do the right thing" without having to extend the API, I don't think we can do that without introducing footguns.

> I believe that this proposal is entirely backward-compatible (in contrast with #23019). The zero-values for the new fields provide exactly the same behavior as a `Cmd` returned by `exec.Command` or `exec.CommandContext` today.

I had originally given https://github.com/golang/go/issues/23019 a thumbs up, but I've moved my thumbs up here now instead :) I even think #23019 might qualify as a breaking change, given how it may break some unlucky programs where the timeout may lead to losing some output.

--- Comment #10 by bcmills ---
Thinking about this some more, there is one other interesting caveat: error behavior.

If we stop reading the program's output before EOF, it may be useful for the caller to know that. Stopping output before EOF seems orthogonal to the exit status of the program, which is what the `Wait` and similar methods currently report.

Should setting `WaitDelay` cause `Wait` and similar methods to return a different error if end up forcibly closing I/O pipes?

--- Comment #11 by henvic ---
The Interrupt field seems super useful to me.

However, IMHO adding the Context field to simplify the documentation might end up hurting more than helping as now I've to understand why there are two ways to pass context. Especially after reading this:

> // If Interrupt is non-nil, Context must also be non-nil and Interrupt will be
> // sent to the child process when Context is done.

--- Comment #12 by henvic ---
Someone might ask themselves: is it only if I pass Context as a field or also when using CommandContext?

--- Comment #13 by bcmills ---
> IMHO adding the Context field to simplify the documentation might end up hurting more than helping as now I've to understand why there are two ways to pass context.

Note that without the Context field, we would still have to explain that `Interrupt` can only be used (or only has an effect) with `Cmd` instances returned by `CommandContext`. So I'm not sure that removing it would help with that confusion much. ðŸ˜…

> Someone might ask themselves: is it only if I pass Context as a field or also when using CommandContext?

Probably we could update the `CommandContext` doc comment to explicitly state that it sets the `Context` and `Interrupt` fields?

--- Comment #14 by bcmills ---
> Should setting `WaitDelay` cause `Wait` and similar methods to return a different error if end up forcibly closing I/O pipes?

I gave this some thought and arrived at:
* Setting `WaitDelay` should not change the exit code if the command fails. The fact that the command failed is almost always enough for the caller to know that its output may be suspecct.
* However, if the command exits with a successful status (that is, if `Wait` would otherwise return `nil`) but we had to forcibly close the pipes, we should return a distinguished error (perhaps a new `exec.ErrWaitDelay`?) so that the caller knows the input and/or output may have been truncated.

--- Comment #15 by bcmills ---
I thought some more about the appropriate Windows behaviors. I added an â€œAlternatives consideredâ€ section and removed the future option for `CTRL_BREAK_EVENT`, since per #6720 it seems not to be feasible.

Instead, on Windows the `Start` method should fail with an error wrapping `syscall.EWINDOWS` if the specified `Interrupt` signal is not supported (that is, if it is not either `nil` or `os.Kill`).

--- Comment #16 by rsc ---

This proposal has been added to the [active column](https://golang.org/s/proposal-status#active) of the proposals project
and will now be reviewed at the weekly proposal review meetings.
â€” rsc for the proposal review group


--- Comment #17 by rsc ---
It seems like the docs need to distinguish what we call cmd.Stdin from cmd.Stdout/cmd.Stderr. cmd.Stdin is already closed when we finish writing whatever was standard input, independent of exiting/waiting/cancellation.

I'm also confused by the WaitDelay description mixing cancellation and ordinary exits. 

Maybe it would help to see the diff that would implement this? I looked at CL 373005 but it's a whole package, not a diff.




--- Comment #18 by bcmills ---
> It seems like the docs need to distinguish what we call cmd.Stdin from cmd.Stdout/cmd.Stderr. cmd.Stdin is already closed when we finish writing whatever was standard input, independent of exiting/waiting/cancellation.

A hang due to `stdin` copying analogous to the one involving `stdout` and `stderr` can occur if the command spawns its own subprocess with `cmd.Stdin = os.Stdin` and then exits without either process reading `stdin` to completion. (The copying goroutine is started in [`(*Cmd).stdin`](https://cs.opensource.google/go/go/+/master:src/os/exec/exec.go;l=258-275;drc=master), and it only closes the pipe once copying is complete â€” which may be arbitrarily long if the writes don't fit in whatever buffer the kernel provides.)

So, at least in that case, we really do need to treat the I/O pipes symmetrically.

--- Comment #19 by rsc ---
Thanks for the clarification about stdin. 

I still feel like it would help me to see the diff in the package, as opposed to a fork as in CL 373005. I'm still not 100% sure I understand the proposal.


--- Comment #20 by bcmills ---
Found another â€œrun or killâ€ function in the main Go repo, and this one doesn't even bother using an appropriate signal (it skips straight to `SIGKILL`):
https://cs.opensource.google/go/go/+/master:test/run.go;l=834-854;drc=f4aa021985e9ae4a9a395f8fbe32ad08d2bfda3b

That manifests as a less-than-useful failure mode in #50973.

--- Comment #21 by rsc ---
I'm still a little confused about the implications here. I'd like to see a concrete CL to understand it better. Will leave this open for this week, but let me know if you'd rather we put it on hold for now.


--- Comment #22 by rsc ---
On hold for a concrete CL.


--- Comment #23 by rsc ---

**[Placed on hold](https://golang.org/s/proposal-status#hold)**.
â€” rsc for the proposal review group


--- Comment #24 by gopherbot ---
Change https://go.dev/cl/401835 mentions this issue: `os/exec: implement Interrupt and WaitDelay`

--- Comment #25 by gopherbot ---
Change https://go.dev/cl/401834 mentions this issue: `os/exec: clean up pipe-closing logic`

--- Comment #26 by gopherbot ---
Change https://go.dev/cl/401895 mentions this issue: `os/exec: export the Context field`

--- Comment #27 by gopherbot ---
Change https://go.dev/cl/401894 mentions this issue: `os/exec: split local pipes by whether they are pumped by user code or internal goroutines`

--- Comment #28 by gopherbot ---
Change https://go.dev/cl/401896 mentions this issue: `os/exec: make the body of Wait eager`

--- Comment #29 by gopherbot ---
Change https://go.dev/cl/401897 mentions this issue: `os/exec: make skipStdinCopyError a function instead of a variable`

--- Comment #30 by bcmills ---
> I'd like to see a concrete CL to understand it better.

A draft of the implementation (on top of a bunch of refactoring that helps to clarify the specific changes) is contained in https://go.dev/cl/401835.

(I believe that the refactoring portion of the stack up through https://go.dev/cl/401834 is an improvement to the codebase independent of this proposal, and that portion has no effect on the exported API.)
