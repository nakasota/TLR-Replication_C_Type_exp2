=== Fetching Proposal: I_kwDOAWBuf85KCusf ===
Issue URL: https://github.com/golang/go/issues/53003

==== [Issue Title] ====
unsafe: add StringData, String, SliceData

==== [Issue Body] ====
Now that `reflect.StringHeader` and `reflect.SliceHeader` are [officially deprecated](https://github.com/golang/go/commit/bc2e961cf4cda945dc6d607a5076b4e376553e9f), I think it's time to revisit adding function that satisfy the reason people have used these types. AFAICT, the reason for deprecation is that `reflect.SliceHeader` and `reflect.StringHeader` are commonly misused. As well, the types have _always_ been documented as unstable and not to be relied upon.

We can see in Github [code](https://github.com/search?l=Go&q=reflect.SliceHeader&type=Code) [search](https://github.com/search?l=Go&q=reflect.StringHeader&type=Code) that usage of these types is ubiquitous. The most common use cases I've seen are:

- converting `[]byte` to `string`
- converting `string` to `[]byte`
- grabbing the `Data` pointer field for ffi or some other niche use
- converting a slice of one type to a slice of another type

The first use case can also commonly be seen as `*(*string)(unsafe.Pointer(&mySlice))`, which is never actually officially documented anywhere as something that can be relied upon. Under the hood, the shape of a string is less than a slice, so this seems valid per unsafe rule (1), but this is all relying on undocumented behavior. The second use case is commonly seen as `*(*[]byte)(unsafe.Pointer(&string))`, which is by-default broken because the Cap field can be past the end of a page boundary (example [here](https://github.com/kubernetes/apiserver/blob/706a6d89cf35950281e095bb1eeed5e3211d6272/pkg/authentication/token/cache/cached_token_authenticator.go#L263-L271), in widely used code) -- this violates unsafe rule (1).

Regardless of the thought that people should never rely upon these types, people do, and they do so all over. People also rely on _invalid_ conversions because Go has never made this easy. Part of the discussion on #19367 was about all the ways that people misuse these types today. These conversions are small tricks that can alleviate memory pressure and improve latencies and CPU usage in real programs. The use cases are real, and Go provides just enough unsafe and buggy ways of working around these problems such that now there is a large ecosystem of technically invalid code that just so happens to work.

Rather than consistently saying "don't use this", `go vet`ing _somewhat_, and then ducking all responsibility for buggy programs, Go should provide actual safe(ish) APIs that people can rely on in perpetuity. New functions can live in `unsafe` and have well documented rules around their use cases, and then Go can finally document what to do when people want this common escape hatch.

# Concrete proposal

The following APIs in the unsafe package:

```
// StringToBytes returns s as a byte slice by performing a non-copying type conversion.
// Slices returned from this function cannot be modified.
func StringToBytes(s string) []byte

// BytesToString returns b as a string by performing a non-copying type conversion.
// The input bytes to this function cannot be modified while any string returned from
// this function is alive.
func BytesToString(b []byte) string
```
~`func DataPointer[T ~string|~[]E, E any](t T) unsafe.Pointer`~ eliminating, because realistically a person can just do `&slice[0]` (although a corresponding analogue does not exist for strings)


I think `unsafe.Slice` covers the use case for converting between slices of different types, although I'm not 100% sure what the use case of `unsafe.Slice` is.

==== [Comments] ====

--- Comment #1 by ianlancetaylor ---
Thanks, but I don't see an actual proposal here.  If you want to discuss ideas, please use golang-nuts.  The proposal process should be for a proposal.  That is, suggest some specific functions that we should introduce.  Thanks.

--- Comment #2 by twmb ---
Sure, good point. I've edited my comment with an actual proposal of ~three~two new functions. I think `unsafe.Slice` covers my the fourth common use case I mentioned above, but I'm not 100% sure.

--- Comment #3 by ianlancetaylor ---
One of the main use cases of `unsafe.Slice` is to create a slice whose backing array is a memory buffer returned from C code or from a call such as `syscall.MMap`.  I agree that it can be used to (unsafely) convert from a slice of one type to a slice of a different type.

--- Comment #4 by ianlancetaylor ---
CC @mdempsky 

--- Comment #5 by paulstuart ---
> from a call such as `syscall.MMap`

Having mmap'd slices in the standard lib would be a huge win (pun intended). The concrete proposal referring to this only addresses strings -- can we get mmaps as part of that too?

--- Comment #6 by ianlancetaylor ---
@paulstuart I'm not sure exactly what you are asking, but that sounds like a different issue.  Note that code can already call `syscall.Mmap` and `unsafe.Slice` to create a slice backed by mmap'ed memory.

--- Comment #7 by rsc ---
Filed #53079. Perhaps we should undeprecate them for Go 1.19, since we don't have a replacement for all valid use cases yet. Thanks.


--- Comment #8 by rsc ---

This proposal has been added to the [active column](https://golang.org/s/proposal-status#active) of the proposals project
and will now be reviewed at the weekly proposal review meetings.
â€” rsc for the proposal review group


--- Comment #9 by bcmills ---
FWIW, the proposed functions closely parallel the `OfString` and `AsString` functions in my [`unsafeslice`](https://pkg.go.dev/github.com/bcmills/unsafeslice) package.

That package also provides best-effort mutation detection, since Go `string` variables are supposed to be immutable and Go programs may generally assume that variables passed as type `string` are never mutated until they are garbage-collected.

--- Comment #10 by twmb ---
I've seen that package, and the one thing I'd not do is the mutation detection (which you gate behind the `unsafe` build tag). I'd expect mutation detection to be automatically done when testing / when built with `-race`, but not to automatically be applied in releases. I'm using the unsafe package, after all :).

I was thinking to link the package in my original writeup, since it is further evidence of the use case.

--- Comment #11 by bcmills ---
At the very least, I think it's important for the documentation for the proposed functions to explicitly call out the lifetime issues, especially for `BytesToString` â€” a `string` used as a map key can cause arbitrary memory corruption if it is mutated while the map is still live.

--- Comment #12 by ianlancetaylor ---
To fully replace `reflect.StringHeader` and `reflect.SliceHeader`, let's consider what they permit us to do.  They can be used to read and/or to modify the contents of a string or a slice.

For reading, we can already extract all the elements of a slice, via `&s[0]`, `len(s)`, and `cap(s)`.  We can get the length of a string via `len(s)`, but we can't get the pointer to the data.

For writing, we can create a new slice setting all the elements, via `unsafe.Slice` followed by a slice expression.  But we can't create a new string.

So to me that suggests, in package unsafe,

```Go
// StringData returns a pointer to the bytes of a string.
// The bytes must not be modified; doing so can cause
// the program to crash or behave unpredictably.
func StringData(string) *byte

// String constructs a string value from a pointer and a length.
// The bytes passed to String must not be modified;
// doing so can cause the program to crash or behave unpredictably.
func String(*byte, int) string
```

These functions should remain meaningful even if we somehow change the representation of slices or strings in the future.

The restrictions on changing the bytes are unfortunate, but the fact is that people are doing these kinds of transformations today.  Omitting these functions from the unsafe package doesn't mean that Go programs won't do them, it just means that they will do in ways that are sometimes even less safe.

It should be feasible to add a dynamic detector for any modifications to these bytes.  This could perhaps be enabled when using the race detector.  This would not be perfect but would detect egregious misuses.

The functions suggested above would then be written as

```Go
func StringToBytes(s string) []byte {
    return unsafe.Slice(unsafe.StringData(s), len(s))
}

func BytesToString(b []byte) string {
    return unsafe.String(&b[0], len(b))
}
```

(To be clear, the reverse is also possible: we can write `String` and `StringData` in terms of `StringToBytes` and `BytesToString`.)

--- Comment #13 by rsc ---
It does seem like unsafe.String and unsafe.StringData match unsafe.Slice a bit better and are more fundamental operations
than providing StringToBytes and BytesToString as the primitives. 
I wonder if we should add unsafe.SliceData as well (code often has to work around len 0 using &s[0]).



--- Comment #14 by mdempsky ---
I'd like to suggest we reconsider the original proposal from #19367: to add new `unsafe.StringHeader` and `unsafe.SliceHeader` types, to handle the remaining advanced use cases that are supported by `reflect.{String,Slice}Header` but aren't covered by `unsafe.Slice`.

Concretely, I propose adding:

```
package unsafe

type StringHeader struct {
    Data *byte
    Len int
}

type SliceHeader[Elem any] struct {
    Data *Elem
    Len, Cap int
}
```

and allowing conversions between `string` and `unsafe.StringHeader`, and also between `[]Elem` and `unsafe.SliceHeader[Elem]`.

Converting an invalid `unsafe.{String,Slice}Header` (e.g., Len > Cap, or Data==nil and Len>0) into a normal string or slice type should fail, at least in `-d=checkptr` mode. I'm leaning towards making it a run-time panic (like `unsafe.Slice`) because the failure conditions are easy to specify/detect, but simply leaving it undefined (like `unsafe.Add`) seems not unreasonable too.

N.B., my original #19367 proposal also allowed conversions between `*string` and `*unsafe.StringHeader`, etc. I think we could still allow that (e.g., particularly to help users transition away from `reflect.{String,Slice}Header`), but I think it's less error-prone (and marginally better for escape analysis) if we encourage users to construct an `unsafe.StringHeader`, value convert it to `string`, and then store that into memory; rather than creating a `*unsafe.StringHeader` and individually assigning fields in memory.

--- Comment #15 by ianlancetaylor ---
My concern about `StringHeader` and `SliceHeader` is that it locks all possible implementations into either using those exact headers or doing strange contortions in the compiler.

What can we do with `StringHeader` and `SliceHeader` that we can't do with `Slice`, `SliceData`, `String`, and `StringData`?

--- Comment #16 by mdempsky ---
After thinking about it more, I'm inclined to agree that `{Slice,String}{,Data}` builtin functions are the way to go. As you say, they support the same functionality. I think that will be easier on tools authors than extending conversion semantics too.

--- Comment #17 by rsc ---
It sounds like we've converged on considering unsafe.StringData, unsafe.String, and unsafe.SliceData.
Does anyone object to those?


--- Comment #18 by rsc ---

Based on the discussion above, this proposal seems like a **[likely accept](https://golang.org/s/proposal-status#likely-accept)**.
â€” rsc for the proposal review group


--- Comment #19 by rsc ---

No change in consensus, so **[accepted](https://golang.org/s/proposal-status#accepted)**. ðŸŽ‰
This issue now tracks the work of implementing the proposal.
â€” rsc for the proposal review group

--- Content after FINAL acceptance decision removed ---