=== Fetching Proposal: MDU6SXNzdWU0NzAyMTU1ODg= ===
Issue URL: https://github.com/golang/go/issues/33184

==== [Issue Title] ====
time: add Ticker.Reset

==== [Issue Body] ====
<!-- Please answer these questions before submitting your issue. Thanks! -->

### What version of Go are you using (`go version`)?

<pre>
go 1.12
</pre>

### Does this issue reproduce with the latest release?
yes.
### What operating system and processor architecture are you using (`go env`)?
linux amd64
### What did you do?
I added the api reset function.
### What did you expect to see?
I hope that the proposal will take effect,because sometimes we need to adjust the time dynamically.
This is not a problem,this is just a suggestion.
Please read the following.thanks.

api:

	// Reset duration to reset a ticker.
	func (t *Ticker) Reset(d Duration) bool {
		if t.r.f == nil {
			panic("time: Reset called on uninitialized Ticker")
		}
		w := when(d)
		active := stopTimer(&t.r)
		t.r.when = w
		t.r.period = int64(d)
		startTimer(&t.r)
		return active
	}


==== [Comments] ====

--- Comment #1 by rsc ---
It seems reasonable to be able to change the duration on a ticker.
But the return value from time.Timer.Reset was a mistake and is impossible to use correctly, and this API would provide the same return value. It seems like better options would be to have no return value from Reset and either:

1. Require that the ticker is stopped; panic if not.
2. If the ticker is not stopped, first stop it and drain any existing value from the channel.

The second seems defensible to me and useful in code that is doing something like:

    t := time.NewTicker(d)
    for range t.C {
        if ... { t.Reset(newD) }
    }

In general, if the Reset is happening separate from the channel receive, you'd want to do t.Stop, then synchronize with the receiver so it knows to expect a new duration, then t.Reset. But the pattern above does not need that because the receiver and the Reset caller are the same, and that seems likely to be common.

So I would lean toward option 2. Thoughts?

--- Comment #2 by namewxt1220 ---
@rsc 
I agree that Reset has no return value,but I don't know what stopTimer returns error under what conditions,at first I just wanted to separate out two apis,like this:

	func NewTicker(d Duration) *Ticker {
		...
		//startTimer(&t.r)
		return t
	}
	func (t *Ticker) StartTicker() {c
		startTimer(&t.r)
	}


This way developers can control their own startup time,later added api Reset,using like this:

	ticker := time.NewTicker(d)
	go func() {
		for _ = range ticker.C {
			...
		}
	}()
	...
	...
	...
	if ... {
		ticker.Reset(newD)
	}

But this does have a situation where stopTimer returns an error,do you have a better solution?

--- Comment #3 by rsc ---
Given the two options I mentioned above, it seems like "the ticker is not stopped, first stop it and drain any existing value from the channel" is the much less error-prone API. If you don't want that, you can of course stop the ticker yourself first.

With that clarification, this seems like a **likely accept**.



--- Content after FINAL acceptance decision removed ---