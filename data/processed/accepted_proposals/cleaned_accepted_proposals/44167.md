=== Fetching Proposal: MDU6SXNzdWU4MDM4ODEwNzY= ===
Issue URL: https://github.com/golang/go/issues/44167

==== [Issue Title] ====
proposal: runtime: GC pacer redesign

==== [Issue Body] ====
# GC Pacer Redesign

Author: Michael Knyszek (with lots of input from Austin Clements, David Chase, and Jeremy Faller)

## Abstract

Go's tracing garbage collector runs concurrently with the application, and thus requires an algorithm to determine when to start a new cycle. In the runtime, this algorithm is referred to as the pacer. Until now, the garbage collector has framed this process as an optimization problem, utilizing a proportional controller to achieve a desired stopping-point (that is, the cycle completes just as the heap reaches a certain size) as well as a desired CPU utilization. While this approach has served Go well for a long time, the design has accrued many corner cases due to resolved issues, as well as a backlog of unresolved issues.

I propose redesigning the garbage collector's pacer from the ground up to capture the things it does well and eliminate the problems that have been discovered.

More specifically, I propose:
1. Including all non-heap sources of GC work (stacks, globals) in pacing decisions.
1. Reframing the pacing problem as a search problem, "solved" by a proportional-integral controller,
1. Extending the hard heap goal to the worst-case heap goal of the next GC,

(1) will resolve long-standing issues with small heap sizes, allowing the Go garbage collector to scale *down* and act more predictably in general.
(2) will eliminate offset error present in the current design, will allow turning off mark-assist almost entirely outside of exceptional cases, improving allocation latency, and will enable clearer designs for setting memory limits on Go applications.
(3) will enable smooth and consistent response to large changes in the live heap size with large GOGC values.

## Full design

[Found here.](https://github.com/golang/proposal/blob/master/design/44167-gc-pacer-redesign.md)

==== [Comments] ====

--- Comment #1 by gopherbot ---
Change https://golang.org/cl/290489 mentions this issue: `design: add GC pacer redesign`

--- Comment #2 by mknyszek ---
By the way: this design feels solid to me, but has not gone through any rounds of feedback yet. In the interest of transparency, I'm hoping to get feedback and work on this here on GitHub going forward.

So, given that, I would not be surprised if there are errors in the document. Please take a look when you have a chance!

CC @randall77 @jeremyfaller @dr2chase @aclements 

--- Comment #3 by storozhukBM ---
@mknyszek

Do I understand correctly that the [forcegcperiod](https://github.com/golang/go/blob/cd176b361591420f84fcbcaaf0cf24351aed0995/src/runtime/proc.go#L5094) is required because the current pacer does not consider non-heap sources of GC work? Is it necessary to call GC periodically in application with effectively zero heap allocation rate to collects stacks, etc.? If I understood your proposal correctly, it seems like it should be possible to remove these periodic calls of GC, and applications that don't create new goroutines and don't allocate anything on heap should never trigger garbage collections, which is a good benefit by itself.

--- Comment #4 by mknyszek ---
@storozhukBM `forcegcperiod` is pretty much completely separate from this proposal. Not accounting for non-heap sources of work more directly affects the minimum heap size and whether the GC reaches its goals. Related though is https://github.com/golang/go/issues/44163, which is partly motivated by some of the ill effects of the `forcegcperiod` trigger.

I believe `forcegcperiod` exists these days to help finalizers run in long-running mostly-idle programs. For example, if you have an external resource tied to the finalizer, you want that cleaned up _eventually_ (and sooner, probably). Going by the API it need not ever run. But, then we could just turn the forced GC on only if there's active finalizers or something, so I'm not convinced that's the only reason. Shrinking stacks periodically also might be a reason, but that seems less critical.

Anyway, I have to look into this again so don't quote me. My memory is hazy. :) I'll dig into the reasons why next week (I don't see them documented anywhere).

--- Comment #5 by gopherbot ---
Change https://golang.org/cl/292789 mentions this issue: `design: add user-configurable memory target`

--- Comment #6 by gopherbot ---
Change https://golang.org/cl/293790 mentions this issue: `design: regenerate graphs for GC pacer redesign`

--- Comment #7 by gopherbot ---
Change https://golang.org/cl/295509 mentions this issue: `design: add initial conditions section to GC pacer redesign`

--- Comment #8 by gopherbot ---
Change https://golang.org/cl/306605 mentions this issue: `runtime: make gcEffectiveGrowthRatio a method on gcControllerState`

--- Comment #9 by gopherbot ---
Change https://golang.org/cl/306603 mentions this issue: `runtime: move next_gc and last_next_gc into gcControllerState`

--- Comment #10 by gopherbot ---
Change https://golang.org/cl/306599 mentions this issue: `runtime: make gcSetTriggerRatio a method of gcControllerState`

--- Comment #11 by gopherbot ---
Change https://golang.org/cl/306600 mentions this issue: `runtime: move gcPercent and heapMinimum into gcControllerState`

--- Comment #12 by gopherbot ---
Change https://golang.org/cl/306596 mentions this issue: `runtime: break out GC pacer into its own file`

--- Comment #13 by gopherbot ---
Change https://golang.org/cl/306597 mentions this issue: `runtime: rename gcpercent, readgogc, and heapminimum to match Go style`

--- Comment #14 by gopherbot ---
Change https://golang.org/cl/306602 mentions this issue: `runtime: create setGCPercent method for gcControllerState`

--- Comment #15 by gopherbot ---
Change https://golang.org/cl/306604 mentions this issue: `runtime: pass work.userForced to gcController.endCycle explicitly`

--- Comment #16 by gopherbot ---
Change https://golang.org/cl/306601 mentions this issue: `runtime: create initializer for gcControllerState`

--- Comment #17 by gopherbot ---
Change https://golang.org/cl/306598 mentions this issue: `runtime: move internal GC statistics from memstats to gcController`

--- Comment #18 by gopherbot ---
Change https://golang.org/cl/308690 mentions this issue: `runtime: formalize and fix gcPercent synchronization`

--- Comment #19 by gopherbot ---
Change https://golang.org/cl/309274 mentions this issue: `runtime: move pacer time updates and state resets into methods`

--- Comment #20 by gopherbot ---
Change https://golang.org/cl/309273 mentions this issue: `runtime: detangle sweeper pacing from GC pacing`

--- Comment #21 by gopherbot ---
Change https://golang.org/cl/309275 mentions this issue: `runtime: move heapLive and heapScan updates into a method`

--- Comment #22 by gopherbot ---
Change https://golang.org/cl/309590 mentions this issue: `runtime: track scannable globals space`

--- Comment #23 by gopherbot ---
Change https://golang.org/cl/309589 mentions this issue: `runtime: track the amount of allocated stack for the GC pacer`

--- Comment #24 by gopherbot ---
Change https://golang.org/cl/309869 mentions this issue: `runtime: implement GC pacer redesign`

--- Comment #25 by mknyszek ---
Unfortunately with everything already going into this release, I need to push this back.

--- Comment #26 by gopherbot ---
Change https://golang.org/cl/350429 mentions this issue: `design: update gc-pacer-redesign and remove inaccuracies`

--- Comment #27 by gopherbot ---
Change https://golang.org/cl/353353 mentions this issue: `runtime: pass nanotime and gomaxprocs into endCycle explicitly`

--- Comment #28 by gopherbot ---
Change https://golang.org/cl/353354 mentions this issue: `runtime: add testing framework and basic tests for GC pacer`

--- Comment #29 by gopherbot ---
Change https://golang.org/cl/368137 mentions this issue: `runtime: switch back to a 4 MiB min heap for GOEXPERIMENT=pacerredesign`

--- Comment #30 by gopherbot ---
Change https://go.dev/cl/399300 mentions this issue: `runtime: update description of GODEBUG=gctrace=1`
