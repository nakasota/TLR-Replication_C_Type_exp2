=== Fetching Proposal: I_kwDOAWBuf85ILkO8 ===
Issue URL: https://github.com/golang/go/issues/52463

==== [Issue Title] ====
go/ast: formally deprecate Object

==== [Issue Body] ====
https://pkg.go.dev/go/ast is the package declaring the syntax tree types for parsed Go code, where https://pkg.go.dev/go/parser produces them.

However, note that it also has a rather rudimentary form of typechecking, as it attempts to keep track of [objects](https://pkg.go.dev/go/ast#Object) and [scopes](https://pkg.go.dev/go/ast#Scope). However, this doesn't really work in practice, because `go/ast` and `go/parser` do not implement a proper Go typechecker; that's https://pkg.go.dev/go/types.

I find this to be very unfortunate in terms of confusing users, especially those new to Go tools and static analysis who are not aware of this historical gotcha. For example, I was just helping someone on Slack who was finding that objects were sometimes not resolved correctly, and the reason was the use of `ast.Object` rather than `types.Object`. See [their code](https://github.com/dolmen-go/sqlfunc/blob/59ab33b1b9a5dfbacacd0284d5e9d903b2805119/poc_test.go#L102) for context.

For some more context, we added a mode bit to `go/parser` to skip object resolution in https://github.com/golang/go/issues/46485, bringing significant speedups at basically no cost for many programs, since they made no use of this partial object resolution.

We can't outright remove types and fields like `ast.Object` for backwards compatibility concerns, but we could certainly warn users against the use of `ast.Object`. For instance:

```
package ast

// [...]
//
// Deprecated: go/ast does not implement a full Go type checker; use go/types.Object instead.
type Object [...]

// [...]
//
// Deprecated: go/ast does not implement a full Go type checker; use go/types.Scope instead.
type Scope [...]
```

It is true that, potentially, using the partial object resolution in `go/ast` is fine for some use cases. Perhaps they only deal with very simple Go code that doesn't run into any of the limitations against `go/types`. I think it should be fine for those (hopefully very rare) cases to consciously ignore the deprecation notice.

cc @findleyr @griesemer @josharian @dominikh

==== [Comments] ====

--- Comment #1 by mvdan ---
One potential question is what to do with existing users of `ast.Object`. For example, `cmd/gofmt` uses it for its rewrite feature (which arguably is deprecated in its own right, as it's rather limited and hasn't been developed in many years) and for its simplify feature, where it's only used to simplify `s[:len(s)]` into `s[:]`. I don't think we're necessarily in a rush to replace both of those bits of code.

--- Comment #2 by timothy-king ---
Two others examples of existing users include `x/tools/go/{ssa,cfg}`. Both use the *ast.Objects to build control flow internally.

--- Comment #3 by dominikh ---
I've switched from ast.Object to types.Object in my fork of go/ssa and it was a [trivial change](https://github.com/dominikh/go-tools/commit/67fb03b7ba3ad2c83698603791223fa377184c05). I can't speak to go/cfg, but I reckon it'll be roughly the same.

--- Comment #4 by gopherbot ---
Change https://go.dev/cl/401875 mentions this issue: `cmd/gofmt: use SkipObjectResolution with -s as well`

--- Comment #5 by mvdan ---
The CL above removes the lone use in `gofmt -s`, which was arguably unnecessary to begin with. Or rather, it only prevented simple forms of false positives, and the assumption was that there shouldn't be any false positives anyway.

--- Comment #6 by timothy-king ---
Took a look at `go/cfg`. It does not depend on `go/types` yet. This would need a `types.Info` for the same solution to apply. The obvious fix is to pass a `*types.Info` which is a breaking change.

--- Comment #7 by gopherbot ---
Change https://go.dev/cl/402034 mentions this issue: `ssa: switch lblocks to types.Object`

--- Comment #8 by gopherbot ---
Change https://go.dev/cl/402054 mentions this issue: `nilness: add unit test for generic instantiation.`

--- Comment #9 by gopherbot ---
Change https://go.dev/cl/402055 mentions this issue: `ssautil: Add unit tests that set ssa.InstantiateGenerics`

--- Comment #10 by findleyr ---
This came up in #50956 as well. With the status-quo, users are likely to be confused about whether to use ast.Object, and then even more confused when they encounter a limitation of ast.Object. With that said, there are currently several valid uses of syntactic object resolution, such as in cmd/godoc, that we probably won't ever update to use go/types. This is of course OK even if we deprecate the API.

I have hesitated to use the `SkipObjectResolution` parser mode more widely, because I am wary of creating a world where we have different color syntax trees. Deprecating ast.Object would be a step toward skipping object resolution in more contexts.  However I think we should consider first providing an API to do syntactic object resolution without relying on ast.Ident.Obj. This would allow existing valid usage of ast.Object to migrate off the API without the machinery of go/types.

For example, something equivalent to the following would be trivial to implement based on the current factoring of go/parser, though the API requires some serious thought.

```go
// ResolveFiles syntactically resolves identifiers in the package defined by files, recording their referenced declarations
// in the given decls map, if non-nil. The resulting error will wrap a scanner.ErrorList reporting errors encountered
// during resolution.
func ResolveFiles(files []*ast.File, decls map[*ast.Ident]ast.Node) error
```

CC @adonovan, who has been thinking about this problem recently.

--- Comment #11 by gopherbot ---
Change https://go.dev/cl/402276 mentions this issue: `pointer: Adds unit tests for pointer with type parameters.`

--- Comment #12 by timothy-king ---
Please ignore messages for ssautil, nilness and cl/402276. These were attached to the wrong github issue.

--- Comment #13 by mvdan ---
@findleyr that plan of action sounds good to me.

> I have hesitated to use the `SkipObjectResolution` parser mode more widely, because I am wary of creating a world where we have different color syntax trees.

While that's a valid concern, I think it's more of an issue for general-purpose APIs like `go/packages`, where we don't know what the `go/ast` will be used for. The changes I have been making are much more limited, such as in `cmd/gofmt` or `go/format`, where we know for certain that the AST objects are unused and that will not change over time.

--- Comment #14 by rsc ---

This proposal has been added to the [active column](https://golang.org/s/proposal-status#active) of the proposals project
and will now be reviewed at the weekly proposal review meetings.
â€” rsc for the proposal review group


--- Comment #15 by findleyr ---
We discussed this today in the external tools call. There seemed to be consensus that `ast.Object` should be deprecated, so I think it would be reasonable to proceed with this proposal even if we do not yet have a replacement API for syntactic object resolution. We will of course preserve backward compatibility, so people can continue to use `ast.Object` even if it is deprecated, but deprecation will make the current situation less confusing to new users.

--- Comment #16 by rsc ---

Based on the discussion above, this proposal seems like a **[likely accept](https://golang.org/s/proposal-status#likely-accept)**.
â€” rsc for the proposal review group


--- Comment #17 by rsc ---

No change in consensus, so **[accepted](https://golang.org/s/proposal-status#accepted)**. ðŸŽ‰
This issue now tracks the work of implementing the proposal.
â€” rsc for the proposal review group


--- Comment #18 by gopherbot ---
Change https://go.dev/cl/504915 mentions this issue: `go/ast: deprecate Object`
