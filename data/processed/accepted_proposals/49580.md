=== Fetching Proposal: I_kwDOAWBuf84-w11d ===
Issue URL: https://github.com/golang/go/issues/49580

==== [Issue Title] ====
io/fs: add ReadLinkFS interface

==== [Issue Body] ====
### What version of Go are you using (`go version`)?

<pre>
$ go version
go version go1.17.3 linux/amd64
</pre>

### Does this issue reproduce with the latest release?

Yes

### What did you do?

Walked a directory with [`fs.WalkDir`](https://pkg.go.dev/io/fs#WalkDir) and encountered a symlink that I wanted to read.

### What did you expect to see?

A function `fs.ReadLink` that behaves like [`os.Readlink`](https://pkg.go.dev/os#Readlink), but operates on an `fs.FS`. Design sketch:

```go
package fs

// ReadLink returns the destination of the named symbolic link.
//
// If fsys does not implement ReadLinkFS, then ReadLink returns an error.
func ReadLink(fsys FS, name string) (string, error)

// ReadLinkFS is the interface implemented by a file system that supports symbolic links.
type ReadLinkFS interface {
  FS

  // ReadLink returns the destination of the named symbolic link.
  ReadLink(name string) (string, error)
}
```

I would also want the file system returned by `os.DirFS` to have an implementation that calls `os.Readlink`. IIUC [`archive/zip.Reader`](https://pkg.go.dev/archive/zip#Reader) would probably also benefit from an implementation.

An open question in my mind is whether the returned destination should be a slash-separated path or kept as-is. I think for consistency it probably should convert to a slash-separated path, but I'm not sure if this has problems on Windows.

### What did you see instead?

No such API exists.

### Other details

I have bandwidth to contribute an implementation of this, but I understand we're in the freeze and the earliest this could go in is Go 1.19.

This is somewhat related to #45470, but I'm not proposing changing any existing semantics, just adding a new method.

==== [Comments] ====

--- Comment #1 by bcmills ---
> An open question in my mind is whether the returned destination should be a slash-separated path or kept as-is.

I would say it should be slash-separated and _also_ relative to the same `FS`: links to absolute paths should be made relative, and links to paths above the FS root (or on an entirely different volume) should be rejected.

--- Comment #2 by rsc ---
Rewriting the link is tricky and not rewriting the link is also tricky. It's unclear to me what we should do here, if anything.


--- Comment #3 by rsc ---

This proposal has been added to the [active column](https://golang.org/s/proposal-status#active) of the proposals project
and will now be reviewed at the weekly proposal review meetings.
â€” rsc for the proposal review group


--- Comment #4 by zombiezen ---
As a data point, for the application I was writing, rewriting the link to be relative is effectively what I did anyway. I wanted to create a zip archive of an on-disk directory, so absolute paths were rewritten to be relative to the `DirFS` root. Returning an error if the path could not be represented was acceptable.

--- Comment #5 by rsc ---
So the API for ReadLink is that it must return a path relative to the link, and if it can't do that, then it returns an error?
It seems like most symlinks are absolute, though, and most DirFS(foo) will not use foo = "/", so that will make most symlinks result in errors?

I'm trying to understand how useful this will be in practice, to balance against the cost. Will it be useful in practice? Or will people just be frustrated that 99% of symlinks aren't usable?


--- Comment #6 by bcmills ---
> So the API for ReadLink is that it must return a path relative to the link, and if it can't do that, then it returns an error?

Yes.

> It seems like most symlinks are absolute, though, and most DirFS(foo) will not use foo = "/", so that will make most symlinks result in errors?

I would expect the `ReadLink` method to internally transform absolute link paths to relative ones (for example, by using `filepath.Rel` and then checking that the returned path does not begin with `../`.) That would allow symlinks to succeed when they are to other locations under the FS root â€” they would only fail if they are absolute symlinks that would otherwise refer to locations completely outside the FS tree.

So, for example, os.DirFS("/") on Unix would be able to resolve symlinks anywhere on the filesystem, even if those symlinks are absolute.

--- Comment #7 by hherman1 ---
>I would expect the ReadLink method to internally transform absolute link paths to relative ones (for example, by using filepath.Rel and then checking that the returned path does not begin with ../.) That would allow symlinks to succeed when they are to other locations under the FS root â€” they would only fail if they are absolute symlinks that would otherwise refer to locations completely outside the FS tree.

Does this extend to non local-disk filesystems?

--- Comment #8 by zombiezen ---
@rsc:

> So the API for ReadLink is that it must return a path relative to the link, and if it can't do that, then it returns an error?

That was sufficient for my application. The root of my `DirFS` could contain multiple projects (think a GOPATH-like setup), so symlinks would usually resolve within the `io/fs` filesystem.

> It seems like most symlinks are absolute, though, [...]

I'm not 100% convinced of that, but I don't have evidence to dispute your claim.

FWIW the cases that I was concerned with in a DevTools context:
- Symlinks within the same directory. A common case is multiple aliases for a single on-disk program, like Busybox.
- IIRC old versions of Git would use symlinks to represent [symbolic references](https://git-scm.com/book/en/v2/Git-Internals-Git-References) like `HEAD` instead of a file.

> I'm trying to understand how useful this will be in practice, to balance against the cost. Will it be useful in practice? Or will people just be frustrated that 99% of symlinks aren't usable?

Agreed, I think weighing this tradeoff is the trickiest part of this proposal.

Relative links are IMO the most useful for a consumer of this API. I could imagine an implementation of `ReadLink` also returning absolute paths in the case where the returned path is above the root `io/fs` directory, but this might add complexity when the paths aren't slash-separated. However, I tend to agree with @bcmills that being strict about this is probably better.

You're probably already considering this, but it's just `FS.ReadLink` that would be picky about the link target. The implicit interface of `DirFS.Open` is to follow symlinks (again, #45470 tracks spelling out that behavior for other filesystems), and symlinks are already visible in directory listings.

---

@hherman1:

> Does this extend to non local-disk filesystems?

I'm proposing the slash-separated relative path restriction would extend to non-local-disk filesystems, yes. How each implementation meets this contract is up to the individual filesystem.


--- Comment #9 by rsc ---
@zombiezen, thanks for the use cases. It seems fairly unobtrusive to add ReadLinkFS and fs.ReadLink, so the cost seems low and the benefit > 0.

@bcmills:

> I would expect the ReadLink method to internally transform absolute link paths to relative ones (for example, by using filepath.Rel and then checking that the returned path does not begin with ../.) That would allow symlinks to succeed when they are to other locations under the FS root â€” they would only fail if they are absolute symlinks that would otherwise refer to locations completely outside the FS tree.
>
> So, for example, os.DirFS("/") on Unix would be able to resolve symlinks anywhere on the filesystem, even if those symlinks are absolute.

Rewriting symlinks may run into problems. I've been burned enough that I'm a bit wary about that. Should we start with just erroring out on the absolute ones?



--- Comment #10 by bcmills ---
I think it would be fine to start by erroring out on absolute links, and perhaps define a specific error (or error type) for symlinks that refer to locations outside of the `FS`.

From the perspective of `fs.ReadLinkFS`, the requirement would be that every returned path is relative to the passed-in name and below the FS root. (It would be up to the specific `FS` implementation to decide whether to achieve that by rewriting absolute links or rejecting them.)

--- Comment #11 by rsc ---
OK, so it sounds like we agree on ReadLink and ReadLinkFS but with the restriction that the returned link must be relative, and absolute symlinks return errors instead. Do I have that right?


--- Comment #12 by zombiezen ---
IIUC the full constraint for the returned link is relative _and_ underneath the root of `FS`. Otherwise, yes, that matches my understanding.

--- Comment #13 by rsc ---

Based on the discussion above, this proposal seems like a **[likely accept](https://golang.org/s/proposal-status#likely-accept)**.
â€” rsc for the proposal review group


--- Comment #14 by rsc ---

No change in consensus, so **[accepted](https://golang.org/s/proposal-status#accepted)**. ðŸŽ‰
This issue now tracks the work of implementing the proposal.
â€” rsc for the proposal review group


--- Comment #15 by zombiezen ---
Excellent! I'm working on a CL now.

Implementation question: I would very much like to be able to use `filepath.Clean` and `filepath.Rel` in the `os.DirFS` implementation, but that would introduce a cyclic dependency AFAICT. What's the best way to use those functions?

--- Comment #16 by ianlancetaylor ---
In principle you could move the functions into an internal package imported by both the os package and the path/filepath package.  But try to avoid that if you can.  Better to keep the os package focused on the simplest possible approach.  In particular I don't see why the os package would need to use `Clean`.

--- Comment #17 by gopherbot ---
Change https://go.dev/cl/385534 mentions this issue: `io/fs: add ReadLinkFS interface`

--- Comment #18 by kaniini ---
I have use-cases which require the ability to have an absolute path returned, namely, taking an fs.FS and taring it up (tons of symlinks to `/bin/busybox`), would it be possible to make it so that an absolute path can be returned if opted into?

--- Comment #19 by ianlancetaylor ---
@kaniini Let's do this version now and then work out whether it can be extended in some sensible way.  Since the io/fs interface doesn't use absolute paths (https://pkg.go.dev/io/fs#ValidPath) it's not really obvious how a `ReadLink` version of io/fs should handle absolute paths.

--- Comment #20 by kaniini ---
Sure, I have a workaround that will work for now.  Just noting that there are usecases :)

--- Comment #21 by mvdan ---
I have a use case for an `io/fs.FS` abstraction supporting symlinks, similar to the proposal author here. However, I want almost the opposite of `ReadLink` - I want an `Lstat`, as `fs.StatFS.Stat` is effectively equivalent to `os.Stat` in that it follows symlinks.

It seems to me that, if an `io/fs.FS` supports symlinks, it should support both `ReadLink` and `Lstat`. Without `Lstat`, it's very hard to get the `FileInfo` for just a symlink if you have its path: using `ReadDir` on its parent directory won't always work, as some paths aren't canonical, like short path names on Windows.

I realise I'm late to this proposal and it's already accepted, but I would imagine that it would be better to instead have:

```
type SymlinkFS interface {
	FS

	// ReadLink returns the destination of the named symbolic link.
	ReadLink(name string) (string, error)

	// Lstat returns a FileInfo describing the file without following any symbolic links.
	// If there is an error, it should be of type *PathError.
	Lstat(name string) (FileInfo, error)
}
```

An alternative is to add an `LstatFS` next to `ReadLinkFS` and `StatFS`, but I can't imagine why one would have `ReadLink` without being able to have `Lstat` or vice versa.

--- Comment #22 by flokli ---
> I have a use case for an `io/fs.FS` abstraction supporting symlinks, similar to the proposal author here. However, I want almost the opposite of `ReadLink` - I want an `Lstat`, as `fs.StatFS.Stat` is effectively equivalent to `os.Stat` in that it follows symlinks.

I initially thought the same. However, after playing with these ideas for a bit, I don't think this is necessary or desirable.

"Following a symlink" is a concept that can only apply to mounted filesystems. Inside your go code, you might be able to do some guessing in cases where your symlinks are relative and don't cross your "filesystem barrier", but as soon as it gets more complicated than that, following becomes impossible.

I guess the right call here is to only return information about the requested path, and not following. Together with the `ReadLink(name string) (string, error)` introduced in https://go-review.googlesource.com/c/go/+/385534/, this should be sufficient.

It's a bit confusing that the function in `io.File` is called `Stat()`, while it is essentially an Lstat, but that interface is probably too widely used to be changed.

--- Comment #23 by mvdan ---
@flokli you are right that the `lstat` and `readlink` operations are all that one needs to fully support symbolic links - `stat` can be implemented by combining both. The only reason I suggested to add `Lstat` instead of repurposing the existing `Stat` is for backwards compatibility. The `io/fs` docs do not say anything about following symlinks, but the fact that the method is called `FS.Stat`, plus how it [uses os.Stat underneath](https://cs.opensource.google/go/go/+/refs/tags/go1.19.1:src/os/file.go;l=661) which follows symlinks, makes me think that changing `FS.Stat` to not follow symlinks would break a few too many programs.

> It's a bit confusing that the function in `io.File` is called `Stat()`, while it is essentially an Lstat, but that interface is probably too widely used to be changed.

Arguably this is an argument in favor of adding `Lstat` to not follow symlinks, rather than to repurpose `Stat` to not follow symlinks, further adding to the confusion :)

But also, I think you've got a valid point about the older APIs: `os.File.Stat` should be clarified to mention that it does _not_ follow symlinks. Its godoc is nearly identical to `os.Stat`, which does follow symlinks.

--- Comment #24 by mauri870 ---
What is the status on this one? The [CL](https://go-review.googlesource.com/c/go/+/385534) seems to be stale for more than a year. I have a use case for ReadLinkFS in the new AddFS apis for zip and tar. If we can identify the bits that are missing to implement this maybe we could finish the work to get this merged. 

Happy to jump in and finish the work  if no one is going to work on it in the near future.

--- Comment #25 by zombiezen ---
> What is the status on this one? The [CL](https://go-review.googlesource.com/c/go/+/385534) seems to be stale for more than a year.

Sorry about that. I need some guidance on how to implement the relative path restrictions in the os package without cyclic dependency issues. I sketched out a potential solution in the CL, but I'd like folks from the project to weigh in on whether this is desirable.

> I have a use case for ReadLinkFS in the new AddFS apis for zip and tar. If we can identify the bits that are missing to implement this maybe we could finish the work to get this merged. 
> 
> Happy to jump in and finish the work  if no one is going to work on it in the near future.

If I get guidance, I think I can finish the CL.



--- Comment #26 by mauri870 ---
kindly CC @bcmills

--- Comment #27 by mvdan ---
I realise that my comment at https://github.com/golang/go/issues/49580#issuecomment-1066844678 arrived weeks after the proposal was accepted, but I was hoping to get the extra `Lstat` method included or at least discussed as part of this proposal. If the interface shipped as-is in Go 1.22, adding an extra method in a later Go release would be a breaking change.

--- Comment #28 by zombiezen ---
Just wanted to acknowledge @mvdan's message: I don't think it would be much more complexity to add it. That said, since I'm more of a casual contributor I don't feel comfortable making the judgement call on it. Would either @bcmills or @ianlancetaylor be willing to weigh in here as to whether `Lstat` should be included in the `io/fs` interface (and IIUC the interface should be renamed `io/fs.SymlinkFS`)?

--- Comment #29 by bcmills ---
I'm not in the proposal review group, but I've flagged this question for them to discuss.

--- Comment #30 by rsc ---
Moving proposal back to Active to talk about SymlinkFS.

