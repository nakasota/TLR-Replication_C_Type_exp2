=== Fetching Proposal: MDU6SXNzdWU5NjI5MjMwNzU= ===
Issue URL: https://github.com/golang/go/issues/47579

==== [Issue Title] ====
fmt: add Append, Appendf, Appendln

==== [Issue Body] ====
### What version of Go are you using (`go version`)?

1.16

### Does this issue reproduce with the latest release?

Sure.

### What operating system and processor architecture are you using (`go env`)?

N/A

### What did you do?

Profiled something that was using Sprintf in a minor way.

### What did you expect to see?

Less Sprintf in the profile.

### What did you see instead?

So much Sprintf.

The issue here is that most of what's happening is WAY cheaper than allocations. `strconv` has AppendInt, but that can't do formatting.

It makes sense, for most uses, that `fmt.Sprintf` is an allocator that produces a string, but there are times when you want formatted-output, but want to write into a []byte. And you can do that with `bytes.Buffer` and `fmt.Fprintf`, but creating a bytes.Buffer around a `[]byte` is... an allocation. And fmt.Fprintf does an allocation. (Curiously, if I do `fmt.Fprintf` into a bytes.Buffer I just made for that purpose, I only get the one allocation.)

What I want: Something like `Sprintf`, but that can write into a []byte, and can fail gracefully if there's not enough space to write things.

Proposed name: `fmt.Snprintf`, because `snprintf` is what you call when you already have a buffer you want written to and you have a length limit in mind.

So, `fmt.Snprintf(dest []byte, fmt string, args ...interface{}) (int, error)`, perhaps. The C standard's answer to "what if n isn't big enough" is "you report the n you would have used if n had been big enough", which exists to allow a single-pass process to figure out how much space you actually need. Alternatively, it could return number of bytes actually written, and if it didn't fit, an error with a concrete type that indicates space needed.

I note, browsing source, that fmt already has `fmtBytes`, although this doesn't do quite the thing this would need.

==== [Comments] ====

--- Comment #1 by ianlancetaylor ---
Edited to add: this doesn't work, as the fmt package pools buffers and will reuse the byte slice.

You could do this instead of adding new API;

```Go
package x_test

import (
	"bytes"
	"fmt"
	"testing"
)

type sliceStealer struct {
	b []byte
}

func (ss *sliceStealer) Write(s []byte) (int, error) {
	if len(ss.b) > 0 {
		panic("multiple calls to Write")
	}
	ss.b = s
	return len(s), nil
}

func FprintfToBytes(format string, a ...interface{}) []byte {
	var ss sliceStealer
	fmt.Fprintf(&ss, format, a...)
	return ss.b
}

func TestFprintf(t *testing.T) {
	s := FprintfToBytes("%d", 10)
	if !bytes.Equal(s, []byte("10")) {
		t.Errorf(`FprintfToBytes("%%d", 10) = %q, want %q`, s, "10")
	}
}

func BenchmarkFprintf(b *testing.B) {
	b.ReportAllocs()
	for i := 0; i < b.N; i++ {
		FprintfToBytes("%d", 10)
	}
}
```

--- Comment #2 by DeedleFake ---
~~It looks like [an allocation can be eliminated by creating a simpler type locally instead of using `bytes.Buffer`](https://play.golang.org/p/tthEL7HoNuS). Does the allocation with `bytes.Buffer` happen because of the return of a pointer from inside of `bytes.NewBuffer()`?

Edit: Ah, darn. @ianlancetaylor beat me to it.~~

Edit 2: Never mind. See https://github.com/golang/go/issues/47579#issuecomment-895139919 below.

--- Comment #3 by seebs ---
Is there any guarantee that Fprintf does only one write? Also, while that allows me to steal the buffer fprintf used, it doesn't let me write into an *existing* buffer that I have, which is the really interesting case. For instance, to put a 0-padded value in `filename[5:9]` or something. The distinction being, with that, BenchmarkFprintf could report 0 allocs/op, theoretically.

So right now, I don't think it's *possible* to loop on Fprintf without at least one allocation per call...

--- Comment #4 by josharian ---
> Also, while that allows me to steal the buffer fprintf used, it doesn't let me write into an existing buffer that I have, which is the really interesting case.

The Write method of your io.Writer could copy the buffer's contents into your existing buffer.

It does mean an extra copy of the data, which is cheap but not free. In any case that should let you avoid the allocation.

Also, I'm not sure the slice stealer is safe. IIRC package fmt pools its buffers, so the buffer passed to Write will be used again by subsequent fmt work.


--- Comment #5 by ianlancetaylor ---
> Also, I'm not sure the slice stealer is safe. IIRC package fmt pools its buffers, so the buffer passed to Write will be used again by subsequent fmt work.

Good point.

--- Comment #6 by ianlancetaylor ---
> `fmt.Snprintf(dest []byte, fmt string, args ...interface{}) (int, error)`

I think we can simplify the issues about exceeding the size of the buffer by making this

`fmt.Snprintf(dest []byte, fmt string, args ...interface{}) ([]byte, error)`

That is, just return the byte slice, which will be a new slice if the original `cap` is not large enough.  People who need to limit the size of the output, which I suspect is less common, can use `Fprintf` with a custom `Writer`.  (But with this modification `Snprintf` is not the right name.)

As it happens, I think this might be fairly simple to implement: replace the `pp.buf` field with the passed in buffer, and then remove it and restore the original `pp.buf` field before releasing the `pp`.

--- Comment #7 by josharian ---
If Sprintf is string-printf, then it seems to me that bytes-printf should be Bprintf.

--- Comment #8 by seebs ---
Bprintf would also make sense to me. Hmm. "if cap isn't large enough, then allocate" seems like a reasonable choice, but I don't see a pretty/clean way to express "if this didn't fit in the space I provided". I guess something like `if &provided[0] != &returned[0]` maybe? (This isn't *quite* safe in all theoretical cases, because the returned len could be 0, but if the returned len is 0, I don't have to worry about the allocation, do I?)

I'd thought about creating a thing which just copies into an existing buffer, but then `fmt`'s still allocating -- but if it's pooling those, I guess I care less about that than I thought I did.

got it! `fmt.Apprendf`

--- Comment #9 by josharian ---
I don’t think the function would return an error; fmt functions only return errors when writes fail. So the signature would be

```go
func Bprintf(dest []byte, format string, args ...interface{}) []byte
```

--- Comment #10 by josharian ---
> I don't see a pretty/clean way to express "if this didn't fit in the space I provided".

How about `cap(provided) != cap(returned)`? Can’t grow without modifying cap.

--- Comment #11 by seebs ---
Yeah. I just dislike the lack of a way to express "is this a different thing" separately from "does this thing have different characteristics". And I suppose I could imagine a case where the desired outcome would be "if for some reason it doesn't fit, fail rather than allocating", but that feels like a different thing.

--- Comment #12 by tdakkota ---
@DeedleFake I think your benchmark is not correct
```go
        var buf [128]byte
	allocs := testing.AllocsPerRun(128, func() {
		fmt.Fprintf(bytes.NewBuffer(buf[:0]), "This is a test.") // buf[:] -> buf[:0]
	})
	fmt.Println(allocs)
```
makes only one allocation (`bytes.Buffer` leaks to heap).
```go
fmt.Fprintf(bytes.NewBuffer(buf[:]), "This is a test.")
```
does not re-use `buf` . 
It creates a new 128-byte buffer and appends `This is a test.`.

--- Comment #13 by DeedleFake ---
@tdakkota

You're right, I don't know how I missed that. Whoops.

--- Comment #14 by bcmills ---
@ianlancetaylor 
> ```go
> fmt.Snprintf(dest []byte, fmt string, args ...interface{}) ([]byte, error)
> ```

I'm confused by this signature. Does the proposed function append to `dest` (as the `strconv.Append*` functions do) up to `cap(dest)`, or does it write to the slice from `0` to `len(dest)` and truncate output if the length is too small (as `copy` does), or does it do a third thing (like writing from `0` to `cap(dest)` and returning the final length)?

If it is like `copy` or `strconv.Append*`, how is that different from using a `bytes.Buffer` today, perhaps with a `LimitedWriter` as discussed in https://github.com/golang/go/issues/17688#issuecomment-258501524?

If it is identical except for allocation behavior, would it be better to improve the compiler's inlining and escape analysis instead? Then the only new API surface we would need is `io.LimitedWriter`, which seems much more generally useful than just a new `fmt` function.

(https://play.golang.org/p/aBpCGXDSmmw)

--- Comment #15 by bcmills ---
@josharian
> If Sprintf is string-printf, then it seems to me that bytes-printf should be Bprintf.

`Sprintf` is “print to a string”, which must return the string because Go strings are immutable.

Since slices are mutable, I would expect a function named `Bprintf` to _print to_ the passed-in slice and return the number of bytes “printed”, in the same way that `Printf` and `Fprintf` do:
```go
// Bprintf prints up to len(dst) bytes to dst, returning the number of bytes printed.
// If the output does not fit within len(dst), Bprintf returns len(dst), io.ErrShortBuffer.
func Bprintf(dst []byte, format string, args ...interface{}) (int, error)
```

For a function with the meaning “append the formatted bytes to the passed-in slice”, I would expect the name `Appendf`, because “appending” is not “printing”.
```go
// Appendf appends the formatted args to dst and returns the extended buffer.
func Appendf(dst []byte, format string, args ...interface{}) []byte
```

--- Comment #16 by rsc ---
fmt.Fprintf guarantees to do a single write to the writer.
Why is it not good enough to pass a bytes.Buffer (or your own custom writer) to Fprintf?


--- Comment #17 by rsc ---
/cc @robpike 

--- Comment #18 by rsc ---

This proposal has been added to the [active column](https://golang.org/s/proposal-status#active) of the proposals project
and will now be reviewed at the weekly proposal review meetings.
— rsc for the proposal review group


--- Comment #19 by robpike ---
I agree with @rsc's comment that Fprintf already provides enough flexibility.


--- Comment #20 by rsc ---
It seems like we are still waiting on an answer to why fmt.Fprintf into an appropriate appending writer is not good enough.


--- Comment #21 by tdakkota ---
Passing a byte slice using `bytes.Buffer` as `io.Writer` causes allocation due to type-to-interface conversion, but `fmt.Appendf([]byte, ...) []byte` will not. 

Also `Appendf` does not need `fmt` pools buffers at all.

--- Comment #22 by clausecker ---
Independently of the escape analysis issue, I like the idea of a `Bprintf` function for convenience.

--- Comment #23 by josharian ---
It'd also help with buffer re-use. Right now there's no way to get the slice back out of a bytes.Buffer when you're done with it, which makes it hard to re-use.


--- Comment #24 by bcmills ---
@josharian, can you not recover the slice using a combination of the `Reset` and `Bytes` methods?

(If that is currently disallowed by the `bytes.Buffer` API, perhaps we should consider a separate proposal to fix that.)

--- Comment #25 by DeedleFake ---
The `Bytes()` method literally just returns the underlying slice:

```go
func (b *Buffer) Bytes() []byte { return b.buf[b.off:] }
```

Does that not work for what you're looking for, @josharian?

--- Comment #26 by josharian ---
@DeedleFake it _almost_ returns the underlying slice—there’s no way I am aware of to get the full slice (starting at 0, not b.off). It is true that in the most common case, and the case that is most relevant to this issue, that’s not a problem.

--- Comment #27 by josharian ---
This issue is part of a general long-standing frustration. Sometimes you need a WriteTo method, sometimes you need an AppendTo method, sometimes you need a String method. They are hard to define in terms of each other without boilerplate and performance penalties.

Insofar as there is a lowest common denominator, it is probably byte slices (AppendTo). But that is the most annoying representation to work with, because it is the one representation that fmt doesn’t work with directly. So you either play bytes.Buffer pooling games or hand-write a sequence of strconv calls and appends.

I’d wager that if this proposal were adopted some 80–90% of my uses of bytes.Buffer would disappear in favor of plain byte slices. To my mind, that’s an indicator that bytes.Buffer is a band-aid, not a solution.

--- Comment #28 by kylelemons ---
I have often wanted `Appendf`.  The cases where I want this are precisely times where I am looking to spend a few CPU cycles more to avoid an allocation, when I either know the maximum size or know the p99 and am comfortable with that.  Pooling buffers that I write to is certainly an option (though harder to figure out how to keep to zero allocs at p99), but when I am doing careful optimizations I like to keep them as self-contained as possible so they can be easily documented clearly and can have their properties validated in a unit test. Adding more state (the pooled buffers), allowing the escape (of a new buffer), and honestly just the mechanical overhead of having to make a buffer, write to it, and then extract the slice are all in opposition to my goals of concise, clear, obvious code. I want it to be clear what has been done in the name of optimization and why, and "Appendf" feels like it would be the sweet spot here, _if_ it can avoid the buffer pooling.

--- Comment #29 by rsc ---
@josharian 

> @DeedleFake it almost returns the underlying slice—there’s no way I am aware of to get the full slice (starting at 0, not b.off). It is true that in the most common case, and the case that is most relevant to this issue, that’s not a problem.

As @bcmills noted, I think b.Reset() + b.Bytes() does what you want?

--- Comment #30 by rsc ---
> I’d wager that if this proposal were adopted some 80–90% of my uses of bytes.Buffer would disappear in favor of plain byte slices. To my mind, that’s an indicator that bytes.Buffer is a band-aid, not a solution.

That sounds like we'd be duplicating existing functionality by adding Appendf?
A bytes.Buffer is a Write-able []byte.

It's an interesting point though. Will keep thinking. 

We probably also need a name that includes 'print', so Appendf is not quite right.


