=== Fetching Proposal: MDU6SXNzdWU5MDEwOTIzMzQ= ===
Issue URL: https://github.com/golang/go/issues/46370

==== [Issue Title] ====
net/http: add Cookie.Valid method

==== [Issue Body] ====
<!--
Please answer these questions before submitting your issue. Thanks!
For questions please use one of our forums: https://github.com/golang/go/wiki/Questions
-->

### What version of Go are you using (`go version`)?

<pre>
$ go version
go version go1.16 darwin/amd64
</pre>

### Does this issue reproduce with the latest release?

Yes

### What operating system and processor architecture are you using (`go env`)?

<details><summary><code>go env</code> Output</summary><br><pre>
$ go env
GOARCH="amd64"
GOOS="darwin"
</pre></details>

### What did you do?

<!--
If possible, provide a recipe for reproducing the error.
A complete runnable program is good.
A link on play.golang.org is best.
-->

I am attempting to construct an `http.Cookie` that will be set on an `http.Server`'s response

```go
http.HandleFunc("/foo", func(w http.ResponseWriter, r *http.Request) {
	cookie := &http.Cookie{
		Name:   "my-cookie",
		Value:  "bar",
		Domain: "example.com:8080",
	}
	http.SetCookie(w, cookie)
	fmt.Fprintf(w, "cookie: %s", cookie.String())
})
```

### What did you expect to see?

Being that the [http.SetCookie](https://golang.org/pkg/net/http/#SetCookie) (or more specifically, the `cookie.String` method) function validates various fields of the cookie struct and returns no error, I would expect there to be a way to validate the cookie myself before attempting to set it. 

Unfortunately, these validator functions [are all unexported](https://github.com/golang/go/blob/master/src/net/http/cookie.go#L288-L303) and the only way I can see to achieve this today would be to re-write the validation logic in my own code, which comes with its own set of concerns.

I can see why generally there isn't always a need to validate a cookie yourself before writing, but when dealing with cookies containing lots of dynamic attribute data (e.g. an app implementing oauth/oidc flows) it becomes paramount that the cookies being returned are written as expected. 

### What did you see instead?

The `http.SetCookie` function will log to stderr (or not, depending on your logging setup) and silently discard the portion of the cookie that failed validation from the final header.

For myself, this caused the `Domain` attribute to be dropped from the final cookie in the response. That in turn caused the cookie to not be sent in subsequent requests to a subdomain on the same host, which resulted in an error.

### Proposal 

Cookies in `net/http` have a concept of validity, but what constitutes a "Go valid cookie" is deliberately left undocumented. 

Additionally, it is quite easy to construct an "invalid" cookie (by Go standards) and have it go unnoticed, due to the `(*http.Cookie).String()` method silently discarding any invalid fields.

I propose adding a new utility function that allows one to programmatically check a cookie's validity under the same rules used by `net/http`. 

This can be either a validity check method, a serialization method, or both:

```go
// Valid reports whether the cookie is valid.
func (c *Cookie) Valid() error

// Marshal returns the serialization of the cookie for use in a Cookie
// header (if only Name and Value are set) or a Set-Cookie response
// header (if other fields are set).
// If c is nil, the empty string is returned.
// If the cookie is invalid, an error is retuned.
func (c *Cookie) Marshal() (string, error)

```

### Use Cases

1. When a cookie is populated with dynamic data from an http request or some other external source. Rather than having the `(*http.Cookie).String()` method just log to stderr and discard fields (which may be entirely swallowed depending on your logging setup) you'd be able check cookie validity beforehand, and handle invalid cookies gracefully by logging your own structured error, incrementing a failure metric, returning a different http response, etc. 

```go
http.HandleFunc("/foo", func(w http.ResponseWriter, r *http.Request) {
	cookie := &http.Cookie{
		Name:   "my-cookie",
		Value:  "bar",
		Domain: r.Host,
	}
  
  err := cookie.Valid()
  if err != nil {
    log.Printf("invalid cookie: %v", err)
    http.Error(w, http.StatusInternalServerError, 500)
    return
  }
  
	http.SetCookie(w, cookie)
	fmt.Fprintf(w, "cookie: %s", cookie.String())
})
```

2. When using statically defined cookie data, a validation check can still be valuable to both assert that the value as you define it is correct, and that the meaning of a "go valid cookie" has not changed.


==== [Comments] ====

--- Comment #1 by mknyszek ---
CC @neild 

--- Comment #2 by neild ---
This seems reasonable, especially since `(http.Cookie).String` logs to stderr(!) for some (but not all!) invalid cookies. Ideally, `String` would return `""` for cookies with an invalid domain, but that's probably difficult to change at this time.

Perhaps something like:

```
// IsValid reports whether c.Name and c.Domain are valid.
func (c *Cookie) IsValid() bool
```

--- Comment #3 by gazerro ---
See related comment https://github.com/golang/go/issues/37055#issuecomment-593803138.

--- Comment #4 by nulltrope ---
> This seems reasonable, especially since `(http.Cookie).String` logs to stderr(!) for some (but not all!) invalid cookies. Ideally, `String` would return `""` for cookies with an invalid domain, but that's probably difficult to change at this time.
> 
> Perhaps something like:
> 
> ```
> // IsValid reports whether c.Name and c.Domain are valid.
> func (c *Cookie) IsValid() bool
> ```

Yeah I can't say i'm a fan of the current behavior of `(http.Cookie).String` but changing it at this point is probably out of the question. Adding a new function like `(http.Cookie).IsValid` seems the best course of action. 

I know we're in a development freeze right now but if you think this is a worthwhile change I can draft up a PR to be considered for the next release cycle. 

> See related comment [#37055 (comment)](https://github.com/golang/go/issues/37055#issuecomment-593803138).

Thanks for the context! I don't expect the change i'm proposing to expose what exact cookie values are valid/invalid. This would only be providing a method to tell whether or not the cookie as a whole is "valid" by Go standards, the specifics of which may or may not change in the future (as @vdobler pointed out). 

If anything, I think having an `(http.Cookie).IsValid` method would make these kinds of cookie validation changes safer, or at least less surprising to users. 

--- Comment #5 by gazerro ---
What is the exact meaning of "valid" for a cookie? Is it valid if it is not discarded by the `SetCookie` method? Or if all the fields of the cookie appear in the Set-Cookie header without changes? Or what else.



--- Comment #6 by nulltrope ---
My thought was to consider a cookie "valid" if no values are discarded by the `(http.Cookie).String` method. 

More specifically, `(http.Cookie).IsValid` would return `true` so long as [isCookieNameValid](https://github.com/golang/go/blob/master/src/net/http/cookie.go#L437-L442), [validCookieDomain](https://github.com/golang/go/blob/master/src/net/http/cookie.go#L288-L297), and [validCookieExpires](https://github.com/golang/go/blob/master/src/net/http/cookie.go#L299-L303) return `true`. 

Edit: Clarifying as there was some confusion here: The above is just an example and additional validation cases may be considered. As for what constitutes a "valid" cookie, I think the definition "a cookie is valid if no values are discarded by the `(http.Cookie).String` method." sufficiently describes what the method will do without giving away too many implementation details.

Any additional formatting done to the values like adding quotes etc. shouldn't make a cookie invalid, as the resulting cookie header has all the same data. On the other hand, I would consider a cookie with a malformed domain or expiration invalid, because after calling `SetCookie` the final cookie sent in the response would be missing those field(s), and will interpreted differently by browsers vs. if they were included.

--- Comment #7 by gazerro ---

Could cookies with a value or path that is changed or completely discarded by the `String` method be valid? With the previous definition they can be valid. For example this cookie would be valid

```go
&http.Cookie{Name: "c", Domain: "domain.com", Expires: time.Now(), Value: ";"}
```

but the value would be discarded by the `String` method and an error would be logged

```
2009/11/10 23:00:00 net/http: invalid byte ';' in Cookie.Value; dropping invalid bytes
c=; Domain=domain.com; Expires=Tue, 10 Nov 2009 23:00:00 GMT
```
https://play.golang.org/p/Lm-6VjMFPV7

I'm not saying the above definition is wrong, but an `IsValid` function could create expectations that may not be met.

--- Comment #8 by neild ---
Under the definition "a cookie is valid if no values are discarded by `(http.Cookie).String`", then a cookie with a Value of `";"` would clearly be invalid.

--- Comment #9 by nulltrope ---
Yes if the value is discarded and an error logged, I would consider that cookie invalid

--- Comment #10 by gazerro ---
You are right, I had considered this as a definition

> More specifically, (http.Cookie).IsValid would return true so long as isCookieNameValid, validCookieDomain, and validCookieExpires return true.

--- Comment #11 by nulltrope ---
Yeah sorry, let me edit that comment to be more clear. I think a simple definition of  "a cookie is valid if no values are discarded by (http.Cookie).String" sufficiently describes what we're trying to achieve here.

--- Comment #12 by gazerro ---
As an alternative to the `IsValid` method, I propose to add a `Serialize` method

```go
// Serialize works like String, but returns an empty string and a not nil
// error instead of discarding some fields and logging the error as String
// does.
func (c *Cookie) Serialize() (string, error)
```
It can be used like this

```go
v, err := cookie.Serialize()
if err != nil {
   // do somenthing with the error
}
w.Header().Add("Set-Cookie", v)
```

--- Comment #13 by vdobler ---
> I would expect there to be a way to validate the cookie myself before attempting to set it.

I am not sure I understand the reason for this, especially if you control the parameters of the cookie yourself: Just do not set invalid names or values.

Being able to validate something is important in all the cases you take data you do _not_ control and have to process it. But there is no real need to validate data _you_ generate. Cookies you receive (at least via the builtin cookie stuff from net/http) are valid and can be sent in Cookie and Set-Cookie headers.

The rules for proper cookie names and values are pretty trivial and well understood and documented in RFC6265. Using something else is a simple programming (or design) error and not some actionable code path.

How would somebody use a Cookie.IsValid method?

    cookie := &http.Cookie{
		Name:   "my-cookie",
		Value:  "bar",
		Domain: "example.com:8080",
    }
    if !cookie.IsValid() {
            // What action could you take here except?
            panic("cookie not valid")
            log.Println("cookie not valid")
            cookie = &http.Cookie{Name:"N", "Value": "V"} // use safe, working cookie?
    }

In my opinion there is no sensible way to react **in code** to a cookie whose IsValid method returns false. So there is no need for a IsValid method.

Pointers can be nil and you can check if they are "valid" by a simple `p != nil`. This is reasonable because using a nil pointer has a well-defined meaning and is useful (zero value of pointers, indicating absence of data, all that). A "invalid" net/http.Cookie has neither a defined meaning nor is it useful, it is just a programming/design error to generate one. Therefore one doesn't need the ability to check if it is valid or not.

If your code generates name, values, domains, expire-times, etc. dynamically from data: _Design_ these functions so that they do not generate "invalid" cookies. E.g. encode arbitrary values in base64/92/whatever. Names of cookies are part of their identity and need to be agreed on upfront in the design phase of your application, so just use valid names.

Conclusion: There is no need for a `IsValid` method on net/http.Cookie.

--- Comment #14 by gazerro ---
> I am not sure I understand the reason for this, especially if you control the parameters of the cookie yourself: Just do not set invalid names or values.

I totally agree that invalid cookies should not be created a priori, but the documentation of the `(*Cookie).String` method does not specify what exactly is intended for "invalid". There are slight differences between the cookie specification and the implementation of `String` (with good reason).

I agree that `String` should not document its implementation but in my opinion there should be a way to know if a cookie is considered valid or not by the `String` method.

We could make sure that the cookies comply with the specifications but we may want to do a second security check. For example:

```go
v, err := cookie.Serialize()
if err != nil {
        log.Printf("attempt to send an invalid cookie: %s", err)
        http.Error(w, http.StatusInternalServerError, 500)
        return
}
w.Header().Add("Set-Cookie", v)
```

We can also use the `Serialize` (or `IsValid`) method in tests to verify that the cookies created comply with the implementation of `String`. This way we can verify that a change in the `String` implementation does not go unnoticed.


--- Comment #15 by vdobler ---
> but the documentation of the (*Cookie).String method does not specify what exactly is intended for "invalid".

Any valid RFC 6265 cookie is not invalid and that's all to know.

"Use valid cookies" instead of "do not use invalid cookies". It is that simple.

> there should be a way to know if a cookie is considered valid or not by the String method.

Again, there is: Any valid cookie is valid and you know that. What counts as valid is defined by RFC 6265 not by the String method. The opposite case i.e. which cookies String considers invalid is a) not interesting, b) must not happen anyway, c) is un-actionable and d) is guaranteed to be an invalid cookie according to RFC 6265.

The reason why the String method doesn't consider _all_ "RFC-6265-invalid" cookies as "Go-invalid" is to allow compatibility with broken legacy systems, frameworks and browsers. The reason why this isn't documented is because this compatibility with real-word browsers is a) important and b) a moving target.


--- Comment #16 by networkimprov ---
cc @ianlancetaylor as likely proposal

--- Comment #17 by gazerro ---
> Any valid RFC 6265 cookie is not invalid and that0s all to know.

`"value"` is a valid cookie value for RFC 6265 but is invalid for the `String` method. Consequently I must know that the value in the `Cookie.Value` field should not be in the form `( DQUOTE *cookie-octet DQUOTE )` even though it is allowed for RFC 6265 because the `String` method handles  double quotes.


--- Comment #18 by gazerro ---
> The reason why the String method doesn't consider all "RFC-6265-invalid" cookies as "Go-invalid" is to allow compatibility with broken legacy systems, frameworks and browsers.

It allows compatibility but not documenting the level of compatibility and not providing a function to check this compatibility, you can't rely on it to write Go code that must interact with a legacy system, framework or browser.

--- Comment #19 by vdobler ---
@gazerro 

I'm not sure what you want to express with

> `"value"` is a valid cookie value for RFC 6265 but is invalid for the String method

because as stated it is wrong:  **Any** RFC-6265-valid cookie-value is considered valid by net/http.Cookie.String.

Maybe you are misinterpreting `( DQUOTE *cookie-octet DQUOTE )` in RFC 6265: The double quotes `"` are **not** part of the cookie-value. A cookie-value in RFC 6265 must not contain double quotes. RFC 6265 _allows_ valid cookie-values to be _enclosed_ in quotes _during transport_ in the HTTP header but these quotes are **not** part of the value: The value is the part _inside_ the double quotes.

> It allows compatibility but not documenting the level of compatibility and not providing a function to check this compatibility, you can't rely on it to write Go code that must interact with a legacy system, framework or browser.

The compatibility guaranteed is "If you follow RFC 6265 your cookies will work.". That is guaranteed and you can rely on this. If you have to interact with a legacy system which need non-RFC-6265-compliant cookies you have to test your code or work with raw headers.

--- Comment #20 by gazerro ---
@vdobler

> Maybe you are misinterpreting ( DQUOTE *cookie-octet DQUOTE ) in RFC 6265: The double quotes " are not part of the cookie-value.

I don't think so, the definition of cookie-value is

`cookie-value      = *cookie-octet / ( DQUOTE *cookie-octet DQUOTE )`

so `v` (octet `%x76`) is a cookie-value but also `"v"` (octets `%x22 %x76 %x22`) is a cookie-value and  cookie-value is the value of the cookie in the spec.

> A cookie-value in RFC 6265 must not contain double quotes

Apart from the first and last octet.

> RFC 6265 allows valid cookie-values to be enclosed in quotes during transport in the HTTP header

There is no reference to this statement in the RFC 6265.

> The compatibility guaranteed is "If you follow RFC 6265 your cookies will work.". That is guaranteed and you can rely on this. If you have to interact with a legacy system which need non-RFC-6265-compliant cookies you have to test your code or work with raw headers.

In this case I don't understand why `String` should deviate from the standard if the purpose is not to allow a program in Go to do so using the `String` method.

--- Comment #21 by gazerro ---
@vdobler i think the `http.sanitizeCookieValue` function has been implemented as if the syntax in the RFC 6265 is

```
cookie-pair   = cookie-name "=" ( cookie-value / ( DQUOTE cookie-value DQUOTE ) )
...
cookie-value  = *cookie-octet
```

but it is

```
cookie-pair   = cookie-name "=" cookie-value
...
cookie-value  = *cookie-octet / ( DQUOTE *cookie-octet DQUOTE )
```


--- Comment #22 by vdobler ---
@gazerro  Again. The optional DQUOTEs around the cookie value in RFC 6265 are **optional** and are **not part*" of the value. http.sanitizeCookieValue is correct. Your reading of the RFC is wrong. Sorry.

I do not have time to look it up in the RFC and prove to you that the cookie value doesn't include the optional quotes. See e.g. https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie#attributes which is pretty clear that " do not belong into a cookie value and the pair of " around a value are optional and not part of the value.
Just try it out yourself in a browser. Current Chrome, Safari, Opera and Edge all strip the DQUOTEs and use just the value inside.
The code is correct and works as documented, and intended by the relevant RFCs and all modern browsers.

--- Comment #23 by gazerro ---
@vdobler thank you for your reply, I've opened a the new issue #46443 with all the details.



--- Comment #24 by nulltrope ---
@vdobler 

> I am not sure I understand the reason for this, especially if you control the parameters of the cookie yourself: Just do not set invalid names or values.

I am primarily concerned with dynamically generated data, but I see some use for static values as well. In the case of hardcoded values, it can be a sanity check in unit tests that they are still valid should something change (either how `String()` validates cookies or the hardcoded value itself).

> In my opinion there is no sensible way to react in code to a cookie whose IsValid method returns false. So there is no need for a IsValid method.

I think @gazerro provided a good example of how one may react to a cookie whose IsValid/Serialize method returns false. Rather than having the `String()` method simply log to stderr  (which may be entirely swallowed depending on your logging setup) you'd be able to log your own error, increment failure metrics, return a different http response, etc. 

As I stated previously, simply omitting certain attributes like Domain or Expires can alter how the cookie functions. For example, when Domain is omitted, the cookie will not be sent to other subdomains on the same host, as they would be if you explicitly set the Domain. It seems preferable to react to this case early on, vs. having a cookie be set that will not work as expected and potentially break other systems depending on it. 

> If your code generates name, values, domains, expire-times, etc. dynamically from data: Design these functions so that they do not generate "invalid" cookies.

Yes, it is totally possible to write my own validation functions for each of these pieces of data (validate the domain, expiration, name, etc.) but that brings me to my original point in opening this issue: **why do the work twice, when the `String()` method already has this functionality?** It seems to me cleaner and less error prone to just use the validation logic already present in the cookie package, vs. expecting everyone to write their own (and probably nearly identical) validation functions. 

> A "invalid" net/http.Cookie has neither a defined meaning nor is it useful, it is just a programming/design error to generate one. 

I'd argue that the concept of an "invalid" `net/http.Cookie` already exists, it just is not documented or clear (and we're not provided a way to check). What would you call cookie which, when calling `String()`, causes the method to log an error and discard the field? I'd consider that cookie invalid as the `String()` method is forced to exclude data to comply with RFC 6265. 



--- Comment #25 by vdobler ---
@nulltrope 

> I think @gazerro provided a good example of how one may react to a cookie whose IsValid/Serialize method returns false. Rather than having the String() method simply log to stderr (which may be entirely swallowed depending on your logging setup) you'd be able to log your own error, increment failure metrics, return a different http response, etc.

Maybe. We have to agree that we disagree here.

> As I stated previously, simply omitting certain attributes like Domain or Expires can alter how the cookie functions. For example, when Domain is omitted, the cookie will not be sent to other subdomains on the same host, as they would be if you explicitly set the Domain. It seems preferable to react to this case early on, vs. having a cookie be set that will not work as expected and potentially break other systems depending on it.

This is the _nature_ of a cookie and an IsValid method doesn't change anything here. Especially as a IsValid method on a cookie would not be able to check whether the Domain attribute is "valid". 

>> If your code generates name, values, domains, expire-times, etc. dynamically from data: Design these functions so that they do not generate "invalid" cookies.

> Yes, it is totally possible to write my own validation functions for each of these pieces of data (validate the domain, expiration, name, etc.) but that brings me to my original point in opening this issue: why do the work twice, when the String() method already has this functionality? It seems to me cleaner and less error prone to just use the validation logic already present in the cookie package, vs. expecting everyone to write their own (and probably nearly identical) validation functions.

That was not was I was trying to explain: Do not write _validation_ functions to check whether your generated cookies are valid or not but write/design those generating functions in a way that it is _impossible_ for them to generate invalid data.

>>  A "invalid" net/http.Cookie has neither a defined meaning nor is it useful, it is just a programming/design error to generate one.

> I'd argue that the concept of an "invalid" net/http.Cookie already exists, it just is not documented or clear (and we're not provided a way to check). What would you call cookie which, when calling String(), causes the method to log an error and discard the field? I'd consider that cookie invalid as the String() method is forced to exclude data to comply with RFC 6265.

I think this argument is deeply flawed because it talks about "invalid" instead of "valid". What a valid cookie looks like is documented (and again, I'm repeating myself: these rules are damn simple). Just use RFC 6265 compliant cookies. These are valid and this is documented and you should not use anything that is not considered valid by RFC 6265.

I do understand your reasoning, but I disagree that this is a path to take.

You and @gazerro  want to stuff arbitrary data into a cookie and check _afterwards_ if Name and Value are RFC 6265 compliant (modulo the few compatibility hacks implemented by net/http to allow working with common malformed cookies).

I think this is the wrong way of doing things. Users of net/http.Cookie should generate RFC6265 compliant names and values only (this is easy and doesn't need any post-hoc validation!). In case they have to deal with malformed cookies because they have to interact with broken legacy systems: Either use net/http.Cookie but make sure it works via automated _tests_ during the build phase of your application or use the raw Cookie and Set-Cookie headers.

--- Comment #26 by gazerro ---
@vdobler

> You and @gazerro want to stuff arbitrary data into a cookie and check afterwards if Name and Value are RFC 6265 compliant (modulo the few compatibility hacks implemented by net/http to allow working with common malformed cookies).

No, I don't want to stuff arbitrary data into a cookie. I want to insert data that the `String` method does not change or discard. I think this is reasonable. To do this it was recommended to insert only standard-compliant values ​​in a `Cookie` value. And even this I think it is reasonable.

Omitting also, in this discussion for now, an alleged lack of conformity of the standard library (there is an issue on the subject), I think that there are cases where further verification of the content of the cookie is preferable or necessary. Making mistakes in your code is inevitable, and in some cases you want to prevent a possible error from spreading by causing problems elsewhere and making it difficult to identify the cause.

Also, the `Cookie` values returned from the `(*Request).Cookie`, `(*Request).Cookies` and `(*Response).Cookies` methods may not be standard compliant for the compatibility hacks implemented by net/http. I'm not saying there shouldn't be these hacks, but that your code have to deal with non-compliant cookies and a function in the standard library it might be useful.

Having said that I think I have expressed my whole point of view and it would be better if we had an opinion also from third parties.










--- Comment #27 by networkimprov ---
It would be helpful if all the common use cases for this were included in the issue text. Keep in mind that everyone on the proposal-review team may not have time to read the whole thread carefully.

--- Comment #28 by neild ---
The `net/http` package has a concept of cookie validity. The [`SetCookie`](https://pkg.go.dev/net/http#SetCookie) documentation states, for example, that "invalid cookies may be silently dropped". The [`(*Cookie).String`](https://pkg.go.dev/net/http#SetCookie) documentation states that "if c.Name is invalid, the empty string is returned".

The concept of cookie validity in `net/http` has not been "any RFC 6265 cookie" since at least 2014. Notably, `net/http` permits spaces and commas in values, and disallows the 0x7f DEL byte. See #7243 for some history; these divergences from RFC 6265 are deliberate and not accidental.

In addition, it is demonstrably the case that there is disagreement even in this issue over what valid RFC 6265 cookie values are.

Given that `net/http` has a concept of cookie validity and that it is possible to construct invalid cookies, I think there should be a way to programmatically test a `Cookie` for validity under the rules used by `net/http`.

The two plausible ways I see to do this are an explicit validity check method and/or a error-returning serialization method:

```
// IsValid reports whether the cookie is valid.
func (c *Cookie) Valid() error

// String returns the serialization of the cookie for use in a Cookie
// header (if only Name and Value are set) or a Set-Cookie response
// header (if other fields are set).
// If c is nil, the empty string is returned.
// If the cookie is invalid, an error is retuned.
func (c *Cookie) Marshal() (string, error)
```

(The name and function signature of `Valid` matches that of [`(http2.Setting).Valid`](https://pkg.go.dev/golang.org/x/net/http2#Setting.Valid), which seems analogous.)

An error-returning `Marshal` method seems strictly better than the current `(*Cookie).String`, which silently swallows some invalid data, returns the empty string for other invalid data, and logs a complaint to stderr(!) for yet other invalid data. I think we should add this.

I don't have a strong opinion on whether we should also add `(*Cookie).Valid`.

A separate question from whether we should add one or both of these methods is whether the `net/http` package should document its concept of cookie validity, or leave it unstated to avoid constraining the future. I don't have a strong opinion here either, but I don't think resolving this question should block adding `(*Cookie).Marshal`.

--- Comment #29 by nulltrope ---
> It would be helpful if all the common use cases for this were included in the issue text. Keep in mind that everyone on the proposal-review team may not have time to read the whole thread carefully.

@networkimprov I will try and summarize the examples and use-cases provided in the original issue text

--- Comment #30 by ray-harris ---
In addition to adding a `(*Cookie).Valid` method, I would also suggest changing the signature of `net/http.SetCookie` to return an error if the cookie is dropped for any reason. Silently dropping invalid data is rarely a good thing.

So change

```func SetCookie(w ResponseWriter, cookie *Cookie)```

to

```func SetCookie(w ResponseWriter, cookie *Cookie) error```

Existing code would not be impacted as the return value would be discarded.
