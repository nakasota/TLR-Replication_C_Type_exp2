=== Fetching Proposal: MDU6SXNzdWUzOTEwMDY1MTg= ===
Issue URL: https://github.com/golang/go/issues/29257

==== [Issue Title] ====
crypto/tls: allow access to net.Conn underneath tls.Conn

==== [Issue Body] ====
Currently it is not possible to access FD in tls.Conn
in tls.Conn the underlying net.Conn is not accessible except in ClientHelloInfo

Senario:
in net/http we can't access the FD for https connections but we can access it for http connections
in a WebSocket connection after Hijack, when the connection is http we can use netpoll but when its https we can't

the only workaround right now is using a https to http proxy but it's not efficient as exposing the net.Conn on tls.Conn

/cc @FiloSottile 

==== [Comments] ====

--- Comment #1 by ja-nixi ---
/cc @bradfitz 

--- Comment #2 by bradfitz ---
/cc @ianlancetaylor 

--- Comment #3 by odeke-em ---
I have marked this as a proposal for it to get the proposal treatment.

--- Comment #4 by ianlancetaylor ---
What do you actually want to do with the file descriptor?

--- Comment #5 by gopherbot ---
Timed out in state WaitingForInfo. Closing.

(I am just a bot, though. Please speak up if this is a mistake or you have the requested information.)

--- Comment #6 by blakerouse ---
It is useful to get the underlying connections file descriptor so that it can be passed into a syscall for epoll. This removes the needed to start a go routine for every websocket connection.

In my concurrent-websocket module I need to do just that so multiple websocket connections can be multiplexed through a pool of goroutines. I am currently working around this issue by using reflect and unsafe, which is really bad!

L26 below shows how I am getting the connection, and you can see on L45 how I pass that connection to `netpoll.HandleReadOnce`. It still uses the `tls.Conn` for reading and writing, but needs to pass the underlying connection for epoll to work.
 
https://github.com/blakerouse/concurrent-websocket/blob/master/channel.go#L26


--- Comment #7 by BernhardValenti ---
This is also an issue when using TLS with the new `http.Server` `ConnContext` callback, in my case I want to get syscall.TCPInfo for each connection.

```go
http.Server{
	ConnContext: func(ctx context.Context, c net.Conn) context.Context {
		// c is a tls.Conn, with apparently no way to access the actual connection
		return
	},
}
```

--- Comment #8 by odeke-em ---
Gopherbot, this is is still an issue.

--- Comment #9 by andyx719 ---
I also need to access FD

--- Comment #10 by tomerBZ ---
Same issue here +1
The file descriptor is needed when working with epoll WebSocket  

--- Comment #11 by jtorvald ---
+1 same same

--- Comment #12 by davecheney ---
Friends, rather than saying “I need this”, I’m sure the maintainers would find it vastly more useful to say _why_ you need this. Be as specific and concrete as possible. Try to answer the question _if this feature were added these are the specific ways it would enable me to do X which I currently cannot do_. Be specific about the X, not just X the feature, but how you would change your code to use X. 

Thank you

--- Comment #13 by lordspace ---
hey, I need this because I am building a static file server and wanted to restart it gracefully without interruption

--- Comment #14 by davecheney ---
@lordspace have you investigated https://godoc.org/crypto/tls#Server? 

--- Comment #15 by lordspace ---
@davecheney thanks for the link. I think I've seen it but it's still not clear to me how to get the descriptor so I can pass it to the program again when it restarts. 

--- Comment #16 by davecheney ---
To use tls.Server you would already hold the net.Conn for the listening socket.

--- Comment #17 by jtorvald ---
@davecheney I believe this is about handling websockets with epoll and working with file descriptors and it tracks back to a comment in this method: https://github.com/blakerouse/concurrent-websocket/blob/master/channel.go#L29
@lordspace probably wants to do something similar to this: https://gravitational.com/blog/golang-ssh-bastion-graceful-restarts/

--- Comment #18 by lordspace ---
yes, @jtorvald I know the ticket is for something else but I will use the descriptor for something else. The article doesn't cover HTTPS

--- Comment #19 by richiMarchi ---
I would need this to retrieve the TCPInfo struct from net.Conn

--- Comment #20 by lordspace ---
@jtorvald yep. you're absolutely right. I've spend about 15 hours on looking for a workaround and I had to resort to using nginx as a reverse proxy for my http server.

--- Comment #21 by FMLS ---
I need to access Fd too, In public cloud environment, we need this fd to parse VPC infomation

--- Comment #22 by lordspace ---
Without access to the file description it may be hard to achieve this for TLS/SSL .
https://github.com/fvbock/endless
https://tomaz.lovrec.dev/posts/graceful-server-restart/

--- Comment #23 by LeGEC ---
I have some code where I would like to call `(*TCPConn).CloseWrite()` from a TLS connection, which I currently create using `tls.Dial("tcp", ... )`.

I know my use case is not a blocker : I can create a `net.TCPConn` (or `net.UnixConn` for that matter), upgrade it using `tls.Client(...)`, and keep the two objects alive together,  
I would just say that it feels awkward to be locked away from the underlying connection.

--- Comment #24 by rsc ---
Epoll is not a good enough reason to expose the file descriptor. The Go runtime uses epoll itself to manage waiting. A goroutine blocked in Read is using epoll already, with a minimal memory footprint.

But I see other reasons here too. Something about parsing VPC information, and something about graceful restarts. I don't understand the direct connnection to the TLS file descriptor though. Can someone explain exactly how access to the TLS file descriptor helps those two cases? Thanks.


--- Comment #25 by jtorvald ---
Hi @rsc thanks for joining in this discussion. I understand that it might not seem reason enough for the websocket.
It's just that with a lot of connections the limiting of go routines is really helpful to keep memory consumption to a minimum (but yeah, I almost feel uncomfortable to write that in a reply to you ;-)). 

When using an unencrypted connection it is possible to get the FD, but not when using the wrapped TLS connection. The solutions to this at the current moment are, as far as I know: reflection (considered bad) or to terminate the TLS connection in front of the go server (which defeats the purpose of keeping a low memory footprint I guess).

What would you suggest in this case? Use reflection anyway?

Out of curiosity: Is the argument against it, that it's not possible to implement that consistent across the multiple go platforms?

--- Comment #26 by rsc ---
@jtorvald What are the memory constraints you have where a goroutine with minimal stack is too much overhead? It seems like we'd be talking about something like 2-4 kB per connection.

@FMLS, @lordspace, @LeGEC, can you elaborate about these functionality-based (as opposed to efficiency-based) motivations for getting access to the file descriptor?



--- Comment #27 by rsc ---

This proposal has been added to the [active column](https://golang.org/s/proposal-status#active) of the proposals project
and will now be reviewed at the weekly proposal review meetings.
— rsc for the proposal review group


--- Comment #28 by lordspace ---
@rsc I wanted to pass the file descriptor to the program itself when it restarts so I have graceful restart.
I had to use nginx in front of my golang server because of this

--- Comment #29 by FiloSottile ---
I don't understand why graceful restarts need access to the file descriptor **of the `tls.Conn`**. They are usually implemented by passing the listen (not connection) socket file descriptor, which is already possible with crypto/tls:

* start a new listener with `net.ListenTCP`
* hold on to the `(*TCPListener).File()`
* wrap the new listener with `tls.NewListener`
* when starting a graceful restart, pass the file descriptor
* turn the file descriptor into a listener with `net.FileListener`
* wrap that listener with `tls.NewListener`

Gracefully passing _active connections_ instead of letting the previous process run them to completion would require not just the `tls.Conn` file descriptor, but also a serialization of the whole TLS connection state, which is not something we'll stabilize.

--- Comment #30 by rsc ---
@lordspace, do you have any thoughts about @FiloSottile's reply? Did you need just the listener, or every tls.Conn? If the latter, why?

