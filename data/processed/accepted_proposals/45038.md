=== Fetching Proposal: MDU6SXNzdWU4MzIxMzEzMjE= ===
Issue URL: https://github.com/golang/go/issues/45038

==== [Issue Title] ====
bytes, strings: add Clone

==== [Issue Body] ====
Working directly with `[]byte` is very common and needing to copy it comes up fairly often. A `Clone` helper would be nice to have.

### What did you expect to see?

``` go
dup := bytes.Clone(data)
```

### What did you see instead?

``` go
dup := make([]byte, len(data))
copy(dup, data)
```

### Implementation

``` go
package bytes

// Clone returns a copy of b
func Clone(b []byte) []byte {
  b2 := make([]byte, len(b))
  copy(b2, b)
  return b2
}
```


==== [Comments] ====

--- Comment #1 by bradfitz ---
If accepted, `Clone` would probably be a more clear and matching name:

```
go1.txt:pkg html/template, method (*Template) Clone() (*Template, error)
go1.txt:pkg text/template, method (*Template) Clone() (*Template, error)
go1.8.txt:pkg crypto/tls, method (*Config) Clone() *Config
go1.13.txt:pkg net/http, method (Header) Clone() Header
go1.13.txt:pkg net/http, method (*Transport) Clone() *Transport
go1.13.txt:pkg net/http, method (*Request) Clone(context.Context) *Request
```

`Copy` makes it sounds like the built-in `copy`.

--- Comment #2 by jimmyfrasche ---
Would this be a better fit for the likely generic slices package, so it could work on any `[]T`?

--- Comment #3 by ulikunitz ---
There is already a generic way to do it in one line. 
```
b2 := append([]byte(nil), b...)
```
This approach is even faster because the allocated slice will not be initialized to zero values.


--- Comment #4 by icholy ---
@ulikunitz I think that's an argument **for** adding a `bytes.Copy` function. Most of the code I've seen uses the two step approach. A helper would probably result in more people using the faster approach.

--- Comment #5 by martisch ---
@ulikunitz 

> ```
> b2 := append([]byte(nil), b...)
> ```
> 
> This approach is even faster because the allocated slice will not be initialized to zero values.

For simple cases like in the example code at the thread start (no complex computation in length argument) make + copy should be faster than append since go1.15: https://github.com/golang/go/issues/26252#issuecomment-495910025 as the go compiler avoids the zero value intialization there too.

--- Comment #6 by DeedleFake ---
I think that even with `append()` being available for this, a simple generic `Clone()` or `Copy()` function in a `slices` package that basically just wraps that would be worth it simply to avoid the need to match the type manually:

```go
b2 := append([]byte(nil), b...)
// vs.
b2 := slices.Clone(b)
```

--- Comment #7 by zigo101 ---
@DeedleFake 
Yout don't need to write out the type `[]byte` manually in an `append` call. Just do `append(b[:0:0], b...)`. So personally, I think the `append` call is more graceful the `slices.Clone` call. The only drawback of `append` calls is that they might zero some redundant elements so they are often a little slower than `make+copy` calls since Go toolchain 1.15 (as mentioned by @martisch above).



--- Comment #8 by ericlagergren ---
> Just do append(b[:0:0], b...).

While that works, I think it's definitely confusing, especially if somebody else owns `b` (like `io.Reader`). I'd personally object to that in a code review.

That said, does this proposal also require `strings.Copy`? IIRC there has been some confusion both in the gophers slack and in GitHub issues about whether `string([]byte(s))` will always make a copy of `s`.

--- Comment #9 by icholy ---
@ericlagergren strings are immutable, there's no need to copy them.

--- Comment #10 by ericlagergren ---
There is need to copy them. For example:

```go
s := "big long string"
x := s[:3]
// no more uses of s, but x is kept
// alive for a long time, keeping the
// entirety of s in memory until x is
// collected because the GC does not
// collect partial objects. 
```

This has implications for things like string interning. 

--- Comment #11 by zigo101 ---
In Go programming, there are many cases in which a small piece of a memory block is active prevents the whole memory block being released, not limited to slices and strings.

--- Comment #12 by josharian ---
See #25834.

--- Comment #13 by earthboundkid ---
The append trick works well, but you have to have read the Go slices tricks wiki page to know to do it. If generics add a slices package, it would make sense to have `slices.Copy[T any](s []T) []T` as a function if only because it would have better discoverability for new gophers. That said, I don't think it makes any sense to add `bytes.Copy` today because we're so close to generics and the append trick works already.

--- Comment #14 by rsc ---

This proposal has been added to the [active column](https://golang.org/s/proposal-status#active) of the proposals project
and will now be reviewed at the weekly proposal review meetings.
— rsc for the proposal review group


--- Comment #15 by hherman1 ---
It would be nice to get a sense of how widely used this idiom is. As it stands, a Clone() function saves almost no lines of code, and it's a new API which contributes to the system complexity of the STL. I think this can only be worthwhile if it is extremely widely used. 

--- Comment #16 by dotaheor ---
IMHO, a [builtin `merge` function](https://github.com/golang/go/issues/23905) will have more use scenarios than `clone`.

--- Comment #17 by rsc ---
Whatever we add here will need to be in strings too (forcing a copy, to address #40200) for symmetry.
And whatever we add here will probably need to go into the yet-undefined generic slices package, for symmetry.
So we need to get the name right for all three.
Copy is no good because this is different from the builtin copy.

Clone seems OK.
In some cases Clone means "deep clone" (like in http.Request).
In other cases Clone means "shallow clone" (like in tls.Config).
This would be a shallow clone.

Any objections to Clone?


--- Comment #18 by DeedleFake ---
`bytes.Clone()` sounds good to me. What would the point of `strings.Clone()` be? Decreasing the memory footprint of heavily substringed strings? That could be useful; just have to make sure that the documentation is clear about the intent.

That being said, I don't think that it has to exist just because `bytes.Clone()` does. `strings.Equal()` doesn't. 

--- Comment #19 by dsnet ---
> What would the point of strings.Clone() be? Decreasing the memory footprint of heavily substringed strings?

I think that has benefit in itself. I occasionally see `string([]byte(s))` in source code and it's not clear to me that the author was trying to re-allocate a smaller string from some other massive string. Seeing `strings.Clone(s)` communicates intent much more cleanly.

--- Comment #20 by ianlancetaylor ---
`strings.Equal(a, b)` would be exactly the same as `a == b`.  There is no way to write the equivalent of `strings.Clone`.  Even `string([]byte(s))` is not the same, as the compiler could in principle optimize that away (and it might even be a useful optimization after inlining).

--- Comment #21 by DeedleFake ---
That's fair. I just used `strings.Equal()` as an example of something that isn't duplicated from one to the other. `bytes.Buffer` isn't exactly duplicated, either, as `strings.Builder` has a different name and API for obvious reasons, and it didn't exist at all for quite a while. `bytes.Replacer` also doesn't exist.

--- Comment #22 by creker ---
@ericlagergren 
> There is need to copy them. For example:
> 
> ```go
> s := "big long string"
> x := s[:3]
> // no more uses of s, but x is kept
> // alive for a long time, keeping the
> // entirety of s in memory until x is
> // collected because the GC does not
> // collect partial objects. 
> ```
> 
> This has implications for things like string interning.

1. Currently string literals are stored in a read-only section. They're not collected and probably treated as globals by GC.
2. Slicing string literals references the same read-only section. This also doesn't affect GC.

So there's no need to copy strings in that case. You probably meant cases where strings are built at runtime?

--- Comment #23 by ericlagergren ---
@creker yes. Sorry, I should have been more exacting. 

--- Comment #24 by rsc ---
Based on the reactions to last week's comment, retitled to include bytes.Clone and strings.Clone, as in:

```
package bytes

// Clone returns a fresh copy of b.
// Specifically, the result is like b[0 : len(b) : len(b)] but in a new backing array.
func Clone(b []byte) []byte
```

and

```
package strings

// Clone returns a fresh copy of s.
// It guarantees to make a copy of s into a new allocation,
// which can be important when retaining only a small substring
// of a much larger string. Using Clone can help such programs
// use less memory. Of course, since using Clone makes a copy,
// overuse of Clone can make programs use more memory.
// Clone should typically be used only rarely, and only when
// profiling indicates that it is needed.
func Clone(s string) string
```


--- Comment #25 by hherman1 ---
I think the comments above that suggested either rejecting this due to the one line workaround, or punting this and reevaluating in a post generics world, seem like the best options. I don’t see any reason this needs to be added now, and I think a good argument has been made that this can be better solved in the future.

--- Comment #26 by jfesler ---
I'd like to see this proposal move forward.  As we bring on more inexperienced go developers into our team,  the bytes.Clone() and strings.Clone() would be more self explanatory.  I've had to explain more than once to people why I do the append trick; and have had to resort to _always_ commenting on the line, making things more verbose than needed.


--- Comment #27 by cbandy ---
> I think the comments above that suggested either rejecting this due to the one line workaround, or punting this and reevaluating in a post generics world, seem like the best options.

I'm here for strings.Clone and its intricate semantics described in https://github.com/golang/go/issues/45038#issuecomment-824224638. Would that behavior somehow carry over to a generics implementation? I expect it would not, so a string-specific function will have to exist somewhere.

--- Comment #28 by martisch ---
The current generics proposal to be implemented will not change that there is no documented way to clone a string and have guaranteed it does not share memory with the old string. https://github.com/golang/go/issues/40200

There are ways that work with specific versions of Go but there is no contract in language spec or API that prevents a future Go compiler to not share memory when copying a string e.g. by using `string([]byte(s))`.



--- Comment #29 by hherman1 ---
I’m ok with strings.Clone, I think you’re all right that generics won’t help there. Personally I think bytes.Clone is better off delayed though.

--- Comment #30 by rsc ---
Perhaps generics will add slices.Clone, but it would probably still be worth having bytes.Clone as well just to avoid an obvious hole in the bytes API. (We are not going to deprecate the entire bytes package even once the slices package exists.)




