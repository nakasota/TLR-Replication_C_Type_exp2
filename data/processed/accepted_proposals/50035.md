=== Fetching Proposal: I_kwDOAWBuf85AAKrE ===
Issue URL: https://github.com/golang/go/issues/50035

==== [Issue Title] ====
x/time/rate: expose the number of remaining tokens

==== [Issue Body] ====
<!--
Please answer these questions before submitting your issue. Thanks!
-->
`rate.Limiter` holds the remaining tokens in a bucket here https://github.com/golang/time/blob/master/rate/rate.go#L59

The feature request is to expose this value in a read only way, perhaps as a public function `Tokens`. 

The use case is that when using a limiter it would be nice to be able to see how many tokens remain without attempting to use one. For my specific case, I want to emit a metric from my kubernetes controller indicating how many tokens are left in the client side rate limiter for a kubernetes clientset (which uses a rate.Limiter under the hood). I think this should be useful in other situations as well though.

Open to any other workarounds as well!

I'd be happy to contribute this, the Tokens func is probably just
```
// Tokens returns the remaining tokens in the bucket
func (lim *Limiter) Tokens() float64 {
	lim.mu.Lock()
	defer lim.mu.Unlock()
	lim.advance(time.Now())
	return lim.tokens
}
```
I'll create a real PR (and get my contribution environment set up) if this idea sounds reasonable. Thanks!

==== [Comments] ====

--- Comment #1 by rsc ---

This proposal has been added to the [active column](https://golang.org/s/proposal-status#active) of the proposals project
and will now be reviewed at the weekly proposal review meetings.
â€” rsc for the proposal review group


--- Comment #2 by rsc ---
/cc @Sajmani 

--- Comment #3 by Sajmani ---
If we expose the tokens, I think we'd instead expose TokensAt(time.Time), externalizing the time.Now() to the caller. 

I'm curious about the metric you want to expose, though. You can't really interpret Tokens without Burst and Limit. Since we expose SetBurst and SetLimit, in theory you'd want to read tokens, burst, and limit simultaneously with the lock held. That suggests we might want a single method StateAt(time.Time) (limit Limit, burst int, tokens float64). But perhaps this is overkill, since most use cases never call SetBurst or SetLimit.

Assuming you're OK calling TokensAt separately from burst & limit (or just saving those from construction), TokensAt seems fine. (And maybe we should include Tokens as a wrapper for TokensAt(time.Now()) for completeness).

--- Comment #4 by deefdragon ---
On surface I think this would be a good addition, but part of me feels that the default rate limiter is becoming too much of a catch-all right now.

Beyond metrics, I can see this being used to allow an N-priority messages passed the rate limiter only if there are M tokens remaining. Then Higher-priority messages could still pushed through up until the rate limiter is completely full even if swamped with lower priority messages. However, this example feels like it might be better implemented with a custom rate limiter where you can pass options to the reserve, and in a safe manner.

--- Comment #5 by Sajmani ---
It seems like a prioritized rate limiter would make sense as a wrapper
around this rate limiter; we don't want to keep making this limiter bigger.
In this case, we're exposing existing state that's documented in the API
(the number of tokens), which seems OK.
S


--- Comment #6 by ryanmcnamara ---
> I'm curious about the metric you want to expose, though. You can't really interpret Tokens without Burst and Limit. 

True, but most of the time I see this being used burst and limit aren't being changed. Narrowing to just the metric case, I'm probably going to be viewing this as a line over time, and changes to qps and limit would be very obvious (qps change means line recovers faster, limit change means line maxes out higher).

I realize that's a pretty specific justification for my use case, but just wanted to point out that a best effort mechanism was all I was looking for. Happy to see the api expanded though like you describe @Sajmani 

--- Comment #7 by rsc ---
It sounds like adding Tokens by itself is not useful, and then it's unclear how much more API to add after that.

Given that rate.Limiter is <50 lines of code, perhaps it would make sense for limiters with special requirements to just start there (or not) and live outside the x repos?

--- Comment #8 by ryanmcnamara ---
@rsc `rate.Limiter` and the code it uses is 400 lines, not 50 (afaict everything in the file I linked above is for it)
I'm not sure why you say Tokens alone isn't useful, it's useful for the reasons mentioned above
The current pitch is to just add the `Tokens` or `TokensAt` func, not more api than that, so it seems clear to me

--- Comment #9 by Sajmani ---
@rsc Given that rate.Limiter already exposes Burst and Limit as thread-safe accessors, I think it's reasonable to expose Tokens as well. Since Tokens is calculated relative to a specific time using Limiter.advance, I propose defining Tokens as TokensAt(time.Now()), and TokensAt(t) as returning the newTokens from advance(t).

--- Comment #10 by rsc ---
What is the new API being proposed?


--- Comment #11 by Sajmani ---
Add `TokensAt` method to resolve this issue:
```
func (lim *Limiter) TokensAt(t time.Time) float64 {
  lim.mu.Lock()
  _, _, tokens := lim.advance(t) // does not mutute lim
  lim.mu.Unlock()
  return tokens
}
```

Optionally add `Tokens` method for consistency with the rest of the API:
```
func (lim *Limiter) Tokens() float64 {
  return lim.TokensAt(time.Now())
}
```

--- Comment #12 by rsc ---
Does anyone object to the API in https://github.com/golang/go/issues/50035#issuecomment-1013416864?

@ryanmcnamara does that API solve your use case? Thanks.


--- Comment #13 by rsc ---

Based on the discussion above, this proposal seems like a **[likely accept](https://golang.org/s/proposal-status#likely-accept)**.
â€” rsc for the proposal review group


--- Comment #14 by rsc ---

No change in consensus, so **[accepted](https://golang.org/s/proposal-status#accepted)**. ðŸŽ‰
This issue now tracks the work of implementing the proposal.
â€” rsc for the proposal review group


--- Comment #15 by Sajmani ---
Implemented in https://go-review.googlesource.com/c/time/+/423042

--- Comment #16 by gopherbot ---
Change https://go.dev/cl/423042 mentions this issue: `rate: add TokenAt and Tokens methods to Limiter.`
