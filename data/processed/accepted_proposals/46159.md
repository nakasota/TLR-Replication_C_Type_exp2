=== Fetching Proposal: MDU6SXNzdWU4OTEzMDk0MTU= ===
Issue URL: https://github.com/golang/go/issues/46159

==== [Issue Title] ====
regexp: support encoding.TextMarshaler

==== [Issue Body] ====
### What did you do?

Marshaling a compiled regular expression, for example as part of a JSON object, results in an empty object. Example:

```golang
re := regexp.MustCompile("foo?")
data, _ := json.Marshal(map[string]interface{}{"foo":re})
fmt.Println(string(data))
```
Produces:
```
{"foo":{}}
```
([Playground](https://play.golang.org/p/gRl2CkOS7pm))

### What did you expect to see?

It would seem more intuitive for a compiled regexp to marshal to its string representation, as if `.String()` were called. Example:

```
{"foo":"foo?"}
```

I propose we implement the `encoding.TextMarshaler` interface to return the value produced by the `String()` method.

Strictly speaking, this would be a breaking change, so may need to be targeted to Go 2.  On the other hand, in a practical sense, the current behavior is completely useless, so anyone depending on the current behavior probably already has a bug in their program.  ðŸ¤·â€â™‚ï¸

==== [Comments] ====

--- Comment #1 by heschi ---
cc @rsc

--- Comment #2 by mvdan ---
This would also be nice for https://github.com/golang/go/issues/45754. cc @dsnet 

--- Comment #3 by icholy ---
@mvdan for this to be useful with #45754 it would need to also implement `encoding.TextUnmarshaler`.

--- Comment #4 by dsnet ---
Regardless of #45754, I'd be surprised as a user to find a type that implements only either `encoding.TextMarshaler` or `encoding.TextUnmarshaler` but not both.

--- Comment #5 by mvdan ---
I share @dsnet's sentiment, though I should also note that in the case of regexp, marshal/unmarshal wouldn't be really symmetric: marshal would just show the original expression string, whereas unmarshal would do a comparatively more expensive regexp compile. A compile also takes options, so I imagine those wouldn't be exposed via TextUnmarshaler.

--- Comment #6 by icholy ---
Losing the options feels like a deal-breaker.

``` go
re := regexp.MustCompile(".*")
re.Longest()
data, _ := re.MarshalText()

// Longest() call is not preserved
_ = re.UnmarshalText(data)

```

--- Comment #7 by dsnet ---
This seems to suggest that `MarshalText` should not emit the same thing as `String`, but emits sufficient information to preserve options and whether it was constructed with `Compile` or `CompilePOSIX`.

That said, I would expect `MarshalText` to be identical to `String` for the common case where no options are involved and its built with `Compile` (assuming that's the more frequently used one).

--- Comment #8 by rsc ---

This proposal has been added to the [active column](https://golang.org/s/proposal-status#active) of the proposals project
and will now be reviewed at the weekly proposal review meetings.
â€” rsc for the proposal review group


--- Comment #9 by dsnet ---
As a strawman proposal to spur discussion, `MarshalText` could output the provided regexp pattern ad-verbatim if there are no options used and the regexp pattern has no slashes, otherwise, the emits the regexp pattern ad-verbatim, but surrounded by "/" characters, and with a few single character flags at the end. This syntax draws inspiration from [RegExp literal notation from JavaScript](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp) and seems to be match similar syntaxes elsewhere (e.g., [Ruby](https://ruby-doc.org/core-2.4.1/Regexp.html)).

Examples:
```go
rx1 := regexp.MustCompile(`[0-9a-fA-F]{32}`)
rx1.MarshalText() // `[0-9a-fA-F]{32}`

rx2 := regexp.MustCompilePOSIX(`[0-9a-fA-F]{32}`)
rx2.MarshalText() // `/[0-9a-fA-F]{32}/p` with 'p' flag emitted to indicate POSIX mode

rx3 := regexp.MustCompile(`[0-9a-fA-F]{32}`)
rx3.Longest()
rx1.MarshalText() // `/[0-9a-fA-F]{32}/l` with 'l' flag emitted to indicate longest-prefix mode. 

rx4 := regexp.MustCompile(`/path/to/blah`)
rx4.MarshalText() // `//path/to/blah/` with surrounding '/' emitted to avoid possible parsing ambiguities
```

I arbitrarily used `p` to indicate POSIX and `l` to indicate longest prefix match. It could anything, and I don't know what options are commonly provided by regexp libraries in other languages and whether we can reuse common flags.

Alternatively, options could be hacked into the existing `(?x)` notation as special flags that must be specified in the top-level grouping. See [the "grouping" section under `regexp/syntax`](https://golang.org/pkg/regexp/syntax/#hdr-Syntax).

--- Comment #10 by frioux ---
Yeah at least Perl stringifies regexen such that they will produce the same thing via the grouping notation:

```bash
$ perl -E'say qr/[a-z]/'
(?^u:[a-z])
```

--- Comment #11 by rsc ---
We could invent our own custom flags for the (?...) syntax, but that would be quite a change for a pretty limited use.
Or we could say that MarshalText only works with non-Posix, non-longest regexps.
None of these sound really awesome.



--- Comment #12 by rsc ---
It sounds like we could invent a text format here, but that text format would not be the input to regexp.Compile, which negates most of the benefit. Is this still worth doing? It seems like maybe not...


--- Comment #13 by dsnet ---
I have mixed feelings about this. I'm not fond of the need to invent a new format, but adding text marshalers would be useful for #45754. I've written tools before that took in a regexp as a command-line flag.

--- Comment #14 by icholy ---
Custom (?...) flags seem like the cleaner way of doing this. Re #45754, I don't think it's a very compelling use-case considering there's `flag.Func`

--- Comment #15 by flimzy ---
> It sounds like we could invent a text format here, but that text format would not be the input to regexp.Compile

Can you elaborate on the reasoning here? If we were to (say) add new `(?...)` flags, what is the reason that `regexp.Compile` could not honor them?

--- Comment #16 by icholy ---
@flimzy those are two separate possible solutions.

--- Comment #17 by rsc ---
The reason not to add new (?...) flags is that there are too many regular expression syntaxes in the world. Today, RE2, Go, Rust, and RE2/J all agree on a single syntax. I would be reluctant for Go to deviate from that group and introduce yet another variant, however small.



--- Comment #18 by rsc ---

Based on the discussion above, this proposal seems like a **[likely decline](https://golang.org/s/proposal-status#likely-decline)**.
â€” rsc for the proposal review group


--- Comment #19 by mvdan ---
Perhaps I derailed this thread with my first comment, https://github.com/golang/go/issues/46159#issuecomment-841497913. The original request was for TextMarshaler only, returning the same value as the String method. Is that still a bad idea, ignoring TextUnmarshaler? It could be unfortunate to implement marshaling and not unmarshaling, so maybe that's still enough reason to not pursue this further.

--- Comment #20 by flimzy ---
> Perhaps I derailed this thread with my first comment, [#46159 (comment)](https://github.com/golang/go/issues/46159#issuecomment-841497913). The original request was for TextMarshaler only, returning the same value as the String method. Is that still a bad idea, ignoring TextUnmarshaler? It could be unfortunate to implement marshaling and not unmarshaling, so maybe that's still enough reason to not pursue this further.

For _my_ use case, TextMarshaler is all that matters.  But my use case may well be unique enough not to warrant an asymmetric feature.

--- Comment #21 by flimzy ---
> The reason not to add new (?...) flags is that there are too many regular expression syntaxes in the world. Today, RE2, Go, Rust, and RE2/J all agree on a single syntax. I would be reluctant for Go to deviate from that group and introduce yet another variant, however small.

I understand that, and agree that it would be unfortunate to add yet another weird Regex syntax.

Would it be reasonable to marshal only non-Posix, non-longest regexps, considering those seem non-controversial? The others could perhaps return an error when marshaled?  This could easily leave the implementation open for modification later if we ever decide supporting those (by whatever means) is appropriate.

--- Comment #22 by rogpeppe ---
I think it would be find if it just marshaled to the equivalent of `String` and unmarshaled without "longest" or Posix options. Yes, that would mean it wouldn't fully round trip, but I think that's OK and easily explainable. I suspect that in any one domain it's unusual to have both "longest" and "non-longest" regexps sitting side by side, especially as there's no way to express those options in the string that's passed to Parse. If someone _needs_ those attributes to round-trip, they can always express them out of band.

--- Comment #23 by rsc ---
The current idea is to have MarshalText/UnmarshalText use the direct regexp syntax and just accept that MarshalText will be a lossy encoding for POSIX or Longest regexps, which are relatively rare.

Do we have any other lossy marshaling? Does anyone think we shouldn't do this?

--- Comment #24 by rsc ---

Based on the discussion above, this proposal seems like a **[likely accept](https://golang.org/s/proposal-status#likely-accept)**.
â€” rsc for the proposal review group


--- Comment #25 by martin-sucha ---
> Do we have any other lossy marshaling?

* `big.Float` does not marshal precision/accuracy, but it uses full precision for marshaling. I don't know whether this classifies as "lossy" or "not-lossy":

```
// MarshalText implements the encoding.TextMarshaler interface.
// Only the Float value is marshaled (in full precision), other
// attributes such as precision or accuracy are ignored.
```

* `big.Int` is not lossy.
* `big.Rat` is not lossy, it's UnmarshalText accepts floating point number in addition to representations returned by MarshalText
* `net.IP` is not lossy, it returns an error from `MarshalText` when the IP address is invalid.
* `time.Time` uses RFC3339Nano when marshaling and RFC3339 with special handling of fractional seconds when unmarshaling, so is not lossy.

There are no other non-test implementations of TextMarshaler in the standard library.

<hr >

The documentation for TextUnmarshaler says:

> UnmarshalText must be able to decode the form generated by MarshalText. UnmarshalText must copy the text if it wishes to retain the text after returning.

Seems that technically this will hold (unless there are any POSIX regexes that cannot be parsed as re2 regex).

--- Comment #26 by flimzy ---
> - time.Time uses RFC3339Nano when marshaling and RFC3339 with special handling of fractional seconds when unmarshaling, so is not lossy.

Marshaling of `time.Time` does omit the monotonic clock reading, which might be considered "lossy" in the strictest sense.

--- Comment #27 by rsc ---
I'll do the implementation and see if I run into anything surprising.


--- Comment #28 by rsc ---

No change in consensus, so **[accepted](https://golang.org/s/proposal-status#accepted)**. ðŸŽ‰
This issue now tracks the work of implementing the proposal.
â€” rsc for the proposal review group


--- Comment #29 by flimzy ---
I would be interested in tackling this one.

--- Comment #30 by dsnet ---
> I'll do the implementation and see if I run into anything surprising.

@rsc, are you still planning on doing this? I found a use-case for this and would like to move it along.


