=== Fetching Proposal: Existing alternatives ===
Issue URL: https://github.com/golang/go/issues/48840

==== [Issue Title] ====
proposal: cmd/link: create an information section with eface type struct addresses

==== [Issue Body] ====
Unlike iface, which has itab structure and we could get to type struct (runtime/type.go), eface doesn't have one and the code (compiled with pic) gets type address directly, using lea instructions on x86.

Example : `lea 0x100050(%rip), %rax # 200500 <type.*+0x1234>`

To handle it I propose to create an information section (debug type, that could be stripped) with an array of eface type structures, so it could be easily found in a binary file.

This information is required for further handling of Golang executables by post-link-optimizer tools like Bolt to make it possible to read actual information about eface types and account it during further basic blocks reordering.

Golang support for Bolt was announced here: https://github.com/facebookincubator/BOLT/issues/154#issuecomment-842143948

Currently, we are close to upstream Golang support in Bolt, but it requires changes described in this proposal.


==== [Comments] ====

--- Comment #1 by vpachkov ---
#48765 PR contains an experimental implementation of this functionality.

--- Comment #2 by randall77 ---
Note that #48532 is probably going to need a similar (but probably more invasive) fix.


--- Comment #3 by ianlancetaylor ---
What do you mean by "eface type structures"?

Currently a value of empty interface type is a pair of pointers.  The first pointer points to the `runtime._type` structure that describes the type stored in the interface.  This is the same as the underlying structure held in a `reflect.Type` interface value returned by `reflect.TypeOf`.

Those type structures can already be identified in an executable by looking for the `runtime.types` symbol (up to the `runtime.etypes` symbol).

Do you need something more than that?  If so, what?

--- Comment #4 by rsc ---

This proposal has been added to the [active column](https://golang.org/s/proposal-status#active) of the proposals project
and will now be reviewed at the weekly proposal review meetings.
— rsc for the proposal review group


--- Comment #5 by vpachkov ---
> What do you mean by "eface type structures"?
> 
> Currently a value of empty interface type is a pair of pointers. The first pointer points to the `runtime._type` structure that describes the type stored in the interface. This is the same as the underlying structure held in a `reflect.Type` interface value returned by `reflect.TypeOf`.
> 
> Those type structures can already be identified in an executable by looking for the `runtime.types` symbol (up to the `runtime.etypes` symbol).
> 
> Do you need something more than that? If so, what?

Thank you for your reply! I looked closely at the cmd/link part and found out that every type is placed inside runtime.types. Indeed, all the types stored in runtime2.eface structure can be found there. 

--- Comment #6 by rsc ---

This proposal has been **[declined as retracted](https://golang.org/s/proposal-status#declined-as-retracted)**.
— rsc for the proposal review group

