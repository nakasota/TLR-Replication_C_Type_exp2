=== Fetching Proposal: No consensus reached ===
Issue URL: https://github.com/golang/go/issues/42201

==== [Issue Title] ====
proposal: path/filepath: add Resolve, replacing EvalSymlinks

==== [Issue Body] ====
This is a new proposal to replace #37113, which was closed for non-technical reasons.

Paraphrasing @rsc, the proposal is a new function in the path/filepath package:

```Go
// Resolve returns the path name as an absolute path that does not contain any symlinks.
// Resolve calls Clean on the result.
func Resolve(path string) string
```

The expectation is that on Unix systems this will be essentially `filepath.Abs(filepath.EvalSymlinks(path))` and on Windows it will essentially acquire a handle for the path and call `GetFinalPathNameByHandle`.

Objections to this approach (in my own words, apologies if I misrepresent some position):

* We should instead make `EvalSymlinks` work better on Windows, such that `filepath.Abs(filepath.EvalSymlinks(path))` will suffice on both Unix and Windows systems.  This may involve changing `EvalSymlinks` to call `GetFinalPathNameByHandle`.  However, any such change to `EvalSymlinks` on Windows may break programs that currently work on Windows.
* It will be tempting to think that the proposed `Resolve` function will return a canonical path, but it will not, neither on Unix nor Windows (on Unix it will not be canonical due to hard links and multiple mounts).  Therefore this function will mislead people into writing buggy programs.  In particular, `os.SameFile` can return true for two different paths returned by `Resolve`.

==== [Comments] ====

--- Comment #1 by rasky ---
I have a couple of other reasons to vote against this proposal:

 * `GetFinalPathNameByHandle` has 4 different modes where it produces different "canonical pathnames". The previous proposal was originated from git-lfs so the author needed the Go function to do exactly what git happens to do (in fact, even on Linux, git calls realpath(3), which I think it should return mostly the same result as `Abs(EvalSymlinks(path))`, but if it doesn't, we're back to step one). I disagree that `filepath.Resolve` should have an implementation which is matched against what another project does; if somebody needs absolute compatibility with something else, they should probably reimplement it outside std.
 * `Resolve` and `EvalSymlinks` would basically be duplicates. It would be very hard to explain in the documentation why we need two similar functions, and it would confuse users. If `Abs(EvalSymlinks(path))` on Windows is different from `Resolve`, we should document how and why, which would basically be an implementation detail with no real semantic meaning.

--- Comment #2 by mvdan ---
> It would be very hard to explain in the documentation why we need two similar functions, and it would confuse users.

To me, this is probably the most important drawback of the proposal.

--- Comment #3 by ericwj ---
I can add to @rasky's comment that some modes do not produce any result, depending on the link type and mode used, e.g. see #39786.

I also have objections, which I have documented in #40180 and those objections carry over to this proposal for most part because `EvalSymlinks` is implemented with `GetFinalPathNameByHandle`. All links will be resolved using that for the implementation.

For these reasons I would like to see a proposal which allows application code to determine which links in a path get resolved, and for that to be ported to Unix instead of attempting to sort of port `realpath(3)` to Windows, such that go on Unix gains functionality that adheres to the objections listed in #40180, too.

--- Comment #4 by networkimprov ---
We need a new API because EvalSymlinks is broken on Windows (how is described in #37113 & #40180), and cannot be fixed without breaking some existing callers. EvalSymlinks would be __deprecated__.

I agree with Eric that it's not correct to always resolve all symlinks in a path, but I also think we must rely on the WinApi to implement this on Windows. I don't see a way to do both. We should include in the Resolve docs Eric's suggestions from #40180 re best practices for handling paths not created by the application which resolves them.

As to the `GetFinalPathNameByHandle` mode, we'd use `VOLUME_NAME_NT` "Return the path with the volume device path" (since drive letters are mount points). This produces `\\?\Device\device_name\path\file.ext` (pls correct me if not).

https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-getfinalpathnamebyhandlew
https://docs.microsoft.com/en-us/windows/win32/fileio/displaying-volume-paths

--- Comment #5 by ericwj ---
> we must rely on the WinApi to implement this on Windows. I don't see a way to do both.

There are other ways besides `GetFinalPathNameByHandle` to resolve links, for example there is [`WNetGetUniversalName`](https://docs.microsoft.com/en-us/windows/win32/api/winnetwk/nf-winnetwk-wnetgetuniversalnamew) to translate paths with drive letters to UNC syntax. I'm sure research into the topic will yield similar API's for [reparse points](https://docs.microsoft.com/en-us/windows/win32/fileio/reparse-point-tags) and the example above already hints at volume mount points and mounted folders. I don't think there are many other types of links at all, but I'm not sure.

> This produces `\\?\Device\device_name\path\file.ext` (pls correct me if not).

I didn't get the prefix `\\?`, but that doesn't mean that cannot appear. But such paths are useless or almost useless for applications and probably very confusing, definitely without additional API's that accept such a path. Also the same file yields `\Device\Mup\ComputerName\ShareName\file.ext` when accessed over the SMB share `\\ComputerName\ShareName`, so it still doesn't canonicalize.

--- Comment #6 by networkimprov ---
What code did you find that doesn't prepend `\\?` to `\Device\...`?

Are you saying that some WinApis can't accept paths starting `\\?\Device`? If not, why would they be useless?

I assume a Volume GUID prefix wouldn't be helpful since that differs on two hosts with otherwise identical configuration.

I think we've concluded that there's no such thing as a "canonical" path.

--- Comment #7 by rasky ---
> > It would be very hard to explain in the documentation why we need two similar functions, and it would confuse users.
> 
> To me, this is probably the most important drawback of the proposal.

I note that this concern could be prevented if the proposal would also include a plan to eventually deprecate EvalSymlinks. I now notice that the issue title mentions "replacing EvalSymlinks", but there is no mention of "replacing" in the proposal text. @ianlancetaylor, can you please clarify this, by making the title and the description match one way or the other?

--- Comment #8 by ericwj ---
> What code did you find that doesn't prepend \\? to \Device\...?
>
> Are you saying that some WinApis can't accept paths starting \\?\Device? If not, why would they be useless?

They are not filesystem paths in the first place. They work with the API's used in the example - volume management API's, perhaps they also work with other kernel API's that deal with devices or with namespaces, but you cannot use them with regular file system API's like `Chdir` and so forth. I ran the API and didn't get `\\?\`. I don't know whether they can ever appear.

> I assume a Volume GUID prefix wouldn't be helpful since that differs on two hosts with otherwise identical configuration.

On GPT disks they are the [unique identifier](https://en.wikipedia.org/wiki/GUID_Partition_Table#Partition_entries_(LBA_2%E2%80%9333)) listed in the partition entry. They should be stable and unique unless we're talking about cloned disks. But there are paths for which asking for the volume GUID does not yield a result. The one case I am aware of is accessing files over SMB. I don't have a computer around that doesn't have/use UEFI/GPT and I haven't tested with external disks which are usually not GPT, or any disks formatted with the old school MBR partitioning scheme. If Windows offers a volume GUID at all, it'll be a constructed one which isn't unique and maybe not stable.

--- Comment #9 by networkimprov ---
So are you suggesting `VOLUME_NAME_GUID`? It seems to me that `VOLUME_NAME_DOS` is more generally useful.

--- Comment #10 by ericwj ---
> So are you suggesting `VOLUME_NAME_GUID`? It seems to me that `VOLUME_NAME_DOS` is more generally useful.

No, I agree with your previous statement.

> I think we've concluded that there's no such thing as a "canonical" path.

`VOLUME_NAME_GUID` and `VOLUME_NAME_DOS` produce errors depending on the link type and the configuration of the target volume or share (whether it is a share or has a DOS device name associated with it) and none of them can be compared with each other. `VOLUME_NAME_NT` I think always returns a result, but still doesn't work for files on the network - not even if the host is `localhost` (I tested that) - since the result reveals that the target was accessed over SMB, not it's original location.

--- Comment #11 by networkimprov ---
Well if `VOLUME_NAME_DOS` returns an error, can't we fall back to `VOLUME_NAME_GUID`?

--- Comment #12 by ericwj ---
And if that returns an error too, we fall back to - what? `WNetGetUniveralName`?

--- Comment #13 by ericwj ---
Sure there will certainly be ways to make the implementation complex enough such that it can resolve any and all links that it can encounter. I would say write it down, see how it can be fitted in a universally useful API. I haven't seen anyone comment on how the Unix API's behave in the presence of Samba or other file systems - would be interesting to see a discussion about that. Whether to cater to the objections listed in #40180 is a mere choice imho. I am obviously in favour of doing that. Canonicalization will not be the end result either way however. Not on Windows.

--- Comment #14 by networkimprov ---
Hm, can we use `VOLUME_NAME_NT` and either construct a `\\?\UNC\...` path for a network object, or look up the device to get a drive letter or volume GUID?

EDIT: Or try `VOLUME_NAME_DOS`, then try `VOLUME_NAME_NT` and construct UNC path, then try `VOLUME_NAME_GUID`.

Again, we're not concerned with "canonical" names, there's no such thing.

--- Comment #15 by ericwj ---
I think it depends on the use case how links should be resolved. I get a *different* drive letter using `VOLUME_NAME_DOS` for some paths, for example. Drive letters are local to a session - or a desktop - such that already just if elevation is required for (part of) an app, they might in some situations first need to obtain a path without drive letter to be sure they can access the files their non-elevated copy refers to. Store apps can use this pattern of shipping a separate full-privilege executable which can do work that requires elevation, but they cannot themselves outright elevate and terminate the non-elevated copy like a desktop app can do. This is especially essential for SMB drive mappings. One more reason to make the API slightly less trivial in terms of formal declaration.

Apps shouldn't elevate and terminate the non-elevated copy, even if it is technically possible and very handy. This is a Certification requirement for Windows Desktop Apps: [9.2 Your app s main process must be run as a standard user (asInvoker).](https://docs.microsoft.com/en-us/windows/win32/win_cert/certification-requirements-for-windows-desktop-apps#9-apps-must-follow-user-account-control-guidelines)

--- Comment #16 by networkimprov ---
I don't think we'll get agreement here on a more sophisticated API, but feel free to suggest something. Otherwise...

Try `VOLUME_NAME_GUID`, then `VOLUME_NAME_NT` and construct UNC path.

If the app wants to separately lookup the volume GUID for a drive letter, so be it.

--- Comment #17 by ericwj ---
Well, without having done the research or testing for it, nor considering all situations where there might be different requirements for resolving links, I just make up these formal declarations as I go right now, with whatever names are descriptive, regardless of whether they are suitable or consistent:

```go
// Returns the longest part of path that is a link, if there are links on path,
// or a suitable error if path is not valid, or does not contain any links.
func GetDeepestLinkPath(path string): (string result, error err)

// Returns the target of the link pointed to by path, if it points directly at a link,
// subject to the mode requested, or a suitable error if path is not valid, or is not itself a link.
func ResolveExactLinkPath(path string, mode ResolveMode): (string result, error err)
```

These could be primitives upon which an easier API could be built, something like:

```go
// A callback function that allows applications to determine whether
// the target of the link pointed to by path should be resolved or not
// and if so, how.
type ShouldResolveFunc func(path string) bool/ResolveMode

// Resolves links on path if there exist links on path below root,
// subject to the mode requested and the return value of
// shouldResolve for each link that is encountered on path below root.
// Returns the target path obtained, or a suitable error if either root 
// or path are invalid, path is not within root, or link resolution fails.
// If the callback function shouldResolve is nil, path is returned.
// Applications should conservatively and consciously decide for each link
// whether it is to be resolved and implement a suitable shouldResolve 
// callback accordingly.
// The callback will receive the exact path to links on path
// in the order GetDeepestLinkPath encounters them, recursively.
// Its return value will determine whether and how links are resolved.
// Links may have been created to solve administrative problems 
// of which most applications should remain unaware.
// Most applications should only resolve specific links that they 
// require to resolve, use the result immediately, forget the result
// and never show the result to the user, unless they have specific
// information about the link that was resolved and whether their
// resolved target is stable and can be cached.
func Resolve(root, path string, mode ResolveMode, shouldResolve ShouldResolveFunc): (string result, error err)
```

Obviously I just list stuff for which I am not sure where it should be declared everywhere it makes sense instead of making any choices. `ResolveMode` could be some enumeration of flags or discrete values, depending on what emerges as being required, at the very least with something resembling `None` which would be the default return value for `ShouldResolveFunc` if it doesn't return `bool`.

--- Comment #18 by networkimprov ---
Can you add comments describing the behaviors of your API concept? And suggestions for implementing them on Windows?

--- Comment #19 by ericwj ---
It gets to be a bit wordy, but yeah, the world is a messy place. It doesn't give any ins and outs just yet even.

My earlier comment about performance applies here - strings don't carry (much) context or (any) proof of work done. Perhaps other types of arguments allow better performance and IDE's to help write code faster at the cost of (some) API 'complexity'. Types are good for both.

Suggestions for how to implement them are exact Windows API's to resolve links. `FindFirstFile` first of all to get the reparse point tag if any. I haven't done research into how to use that subsequently in the cases where this indicates the path is a symbolic link, junction, or other reparse point that should be supported for resolution here. If the path has a drive letter, `GetDriveType` would be needed, followed by API such as `WNetGetUniversalame`, `GetVolumeNameForVolumeMountPoint`, and similar functions for other types of links. The latter works for reparse points that are mounted folders and for mapping drive letters, volume paths or mounted folders to the volume path; the former yields the path in UNC syntax for paths that start with an SMB drive mapping.

The `shouldResolve` callback may use (new proposal) new public API to great effect that classifies links in a portable way but with enough detail that it can discriminate how to resolve them as well. What that looks like depends on how things work on *nix and how e.g. can be determined that a path refers to a remote file over SMB or in the cloud.

How precisely this all works would have to be written down in code and tested, preferably reviewed by Windows experts, before deciding what the API actually will exactly have to look like.

--- Comment #20 by ericwj ---
I would even say before it is *actually included* in any standard library, it'll have to be battle tested, especially the part that tries to summarize application scenario's for resolving links and makes the right choices for each of those.

--- Comment #21 by networkimprov ---
The `ShouldResolveFunc` callback is an interesting idea! But I think the right place to prototype it is probably a more widely used language than Go (e.g. Python, Java, C#, C) where it would see more users and use cases, esp on Windows.

Re a simple filepath.Resolve API, what do you think of my last suggestion for `VOLUME_NAME_x`?

--- Comment #22 by ianlancetaylor ---
Good point about looking at other languages.

Python has `os.path.realpath(path)` (https://docs.python.org/2/library/os.path.html#os.path.realpath).

Java has `os.File.getCanonicalPath()` (https://docs.oracle.com/javase/7/docs/api/java/io/File.html#getCanonicalPath()).

C++ has `std::filesystem::canonical` (https://en.cppreference.com/w/cpp/filesystem/canonical).

What do those functions do on Windows?

--- Comment #23 by ericwj ---
I think those have ported from *nix, or in the case of C++ have taken POSIX semantics (hear say), without the considerations we are having here and will have the issues we identified.

Certainly the C++ version, which has been [linked](https://github.com/microsoft/STL/blob/master/stl/inc/filesystem#L3077) before, with the implementation actually [here](https://github.com/microsoft/STL/blob/5f736efd868f0cc32dd4c89d43f8ad9923742647/stl/inc/filesystem#L3023). It is pretty mangled code, but appears to use `GetFinalPathNameByHandle` and request `VOLUME_NAME_DOS` and if that fails `VOLUME_NAME_NT`, then strips both `\\?\` and `\\?\UNC\` prefixes and then adds the prefix `\\?\GLOBALROOT` if the result was obtained from `VOLUME_NAME_NT`. I'm not exactly sure what the consequences are or what `LR"(\\?\GLOBALROOT)"sv` exactly does - correct me if I am wrong.

> Re a simple `filepath.Resolve` API, what do you think of my last suggestion for `VOLUME_NAME_x`?

If any attempt at canonicalizing is deemed needed for code compatibility reasons, I would port the C++ version of it. It won't work to canonicalize files accessed over SMB, nor will it yield afaik paths that can be used with other file system API's, but it might about always return some result that can at least be compared between local files and between remote files, but not the remote with the same file accessed locally and it won't substitute drive letters for the imho better alternative of volume GUID paths. So I would actually have the implementation also try `VOLUME_NAME_GUID`.

`PowerShell`'s `Get-ChildItem` aka `dir` shows link targets as well. It has the problem that it doesn't indicate in any way that hardlinks are links. The list in #40180 uses this to show what the result should be, but for hardlinks I believe I hardcoded it. This could be an issue with `GetFinalPathNameByHandle` itself, in which case this is a persistent problem with this approach.

--- Comment #24 by ericwj ---
 > I think the right place to prototype it is probably a more widely used language than Go (e.g. Python, Java, C#, C)

Perhaps I would be able to create a C# version, even to propose such a thing to become part of .NET, which would be awesome because it'd have to be reviewed by Microsoft themselves. If such a proposal would be deemed useful or recommended to expose to the general public in the first place. And if it is accepted, the cadence is one release per year in November - it could take 1 or 2 years before they get to it.

ADDITION: It would also have to be portable to a wide array of Linux versions, MacOS, probably Android, with that work *also* reviewed by Microsoft.

--- Comment #25 by networkimprov ---
Actually, it prepends `\\?\GLOBALROOT` to result of `VOLUME_NAME_NT`, and strips `\\?\` otherwise, so the prefix is inconsistent. I guess long paths fail for `*_NAME_DOS`? From https://github.com/microsoft/STL/blob/master/stl/inc/filesystem#L3023

I believe we can yield a consistent, general-purpose result via `\\?\GLOBALROOT\Device\device_name\path\file.ext` -- which is most likely to be useful across hosts with identical configuration, unlike drive letters and volume GUIDs. An app can look up either of the latter from that value.

BTW hardlinks are not at issue here (but are one reason the term "canonical" isn't appropriate).

--- Comment #26 by ericwj ---
Yes, that is what I understood but didn't exactly write down. I understand it just prefers to return no prefix, but these are simple to add back. I don't think there are limitations, not with any of the flags, but maybe the caller has to know to include a prefix when necessary. We'd have to test that and see what happens.

I think it is pointless to try to make anything consistent across hosts. Hosts can only see the volume GUID's of their local partitions and paths using those *actually work* with other filesystem API's. In the case where `go` programs go fancy and talk with themselves accross hosts using local paths, well, they would have to store which computer each path originates from anyway and *could* be optimistic enough to assume they encounter only unique volume GUIDs.

I don't know how device names are generated, but I'm sure `\Device\HarddiskVolume15\Path\File.Ext` isn't going to be more canonical than the volume GUID. Perhaps it doesn't persist across reboots, or it won't in certain ways configurations can change on a computer. Even if multiple hosts mount the same cloned volume they won't be telling anyone (over SMB at least).

There *is no* volume GUID known from the remote host, the servername and sharename are the indirection where the information hiding starts and neither `VOLUME_NAME_DOS` nor `VOLUME_NAME_NT` are able to distinguish remote files any further. `SameFile` can in that case be used to establish uniqueness, as long as either one of the files being compared is a local file and the other points at something referring to the local computer, the server names are the same, or can be established to match by other means (e.g. IP-address, NetBIOS name, or whatever).

--- Comment #27 by tandr ---
(very meta) 
Folks, I think there is a bit of irony(?) hiding in there somewhere - you are discussing things about internals of Microsoft's software on platform that belongs to Microsoft. Why won't we ask someone from Microsoft? Would it be possible to tag some @microsoft folks to pipe in? Like, I don't know, @markrussinovich who might know a bit about Windows internals, or @oldnewthing (Raymond Chen) about what "canonical" might mean on Windows and what is the best way to go forward? (Sorry Mark and Raymond, your names came first to my mind - if you know anyone who might help please direct them here.)

--- Comment #28 by networkimprov ---
cc @jstarks who often comments here...

--- Comment #29 by networkimprov ---
Eric, I believe the device name is configurable, and it would be ideal to get the same result for Resolve() when you move an application to a mirror or failover host with identical configuration. At the very least the device name is more readable than the volume GUID, and potentially more meaningful.

My understanding is that `\\?\GLOBALROOT\Device\device_name\...` is a valid path name for WinAPIs.

And we should consistently use the `\\?\` prefix to be long-path safe.

https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-setvolumelabela

--- Comment #30 by tandr ---
To use `\\?\` as a path prefix I think (but I might be wrong) an executable needs to pack a manifest file to indicate that it can handle long paths.

(Re: https://github.com/golang/go/issues/17835)
