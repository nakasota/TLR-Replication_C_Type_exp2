=== Fetching Proposal: Breaking Go's principles ===
Issue URL: https://github.com/golang/go/issues/44550

==== [Issue Title] ====
proposal: cmd/go: make major versions optional in import paths

==== [Issue Body] ====
Semantic Import Versioning (SIV) is a novel idea for supporting multiple versions of a package within the same program. To my knowledge and experience, it's the first example of a strategy for supporting multiple versions of a project / dependency in the same application. More importantly though, its clever introductory design allowed it to offer multi-versioned packages in a Go program while maintaining Go's compatibility guarantee.

Multi-versioned packages in a single program can be quite powerful -- for instance, imagine a Web service where you'd like to maintain backwards compatible support for your consumers, you can simply use an older import path from the same origin repository and versioning control, and quite elegantly continue to support those older API versions.

Although SIV may be an elegant solution in the scenario described above, it also adds unnecessary complexity, cost, code noise, discoverability and ergonomics for the majority of packages (publicly and privately) which may not ever have a mutli-version requirement (I'd argue most packages, and simply we can look to other ecosystems to see this is true). I am sure the Go team has heard a lot of feedback on the friction of SIV. https://twitter.com/peterbourgon/status/1236657048714182657?s=21 and https://peter.bourgon.org/blog/2020/09/14/siv-is-unsound.html offers some excellent points as well.

Clearly there is a case for SIV as an elegant solution for supporting multiple versions of a package in a single application, and there is also a strong case to make SIV optional.

It's clear to me there is a design trade-off at hand, and there is no single correct answer. As I consider the 80/20 rule in making an architectural decision between two trade-offs of capability and usability, I prefer to go with the 80% case so long as it doesn't forego the 20% ability. Which design is the best to optimize for if we can still support both? In the case with Go today, its not possible to opt-out of SIV, or opt-into SIV -- I believe both approaches can yield a happy solution. If we were starting from the beginning, I'd suggest to have SIV be opt-in, but maybe at this point its better for it to be an opt-out design to maintain backwards compatibility with history.

---

I'd like to propose a path to make SIV opt-out at the level of an application developer consuming a package, while being backwards compatible with current packages and tools. 

I'd like to use https://github.com/go-chi/chi as an example for this proposal which adopted semver ahead of Go modules and SIV, and is built for developer simplicity and ergonomics intended for pro Go developers, but also making it familiar and accessible for developers who are new to Go -- these are my design goals for chi as an author and maintainer as started back in 2017. My present goal is to release Chi v5 without a SIV requirement and the only way I can do so is with the proposal below:

---

**Proposal, by example:**

*github.com/go-chi/chi/go.mod:*
```go
module github.com/go-chi/chi/v5

go 1.16
```

then, git tag chi as `v5.0.0` to make the release.

Application developers may consume the package via `go get github.com/go-chi/chi@latest` or with `@v5` or `@v5.0.0` and the expected import path will be "github.com/go-chi/chi", however "github.com/go-chi/chi/v5" import path would also be valid and usable.

In the above case, we're specifying the go.mod as expected with current behaviour with SIV from a library perspective. However, from the application perspective when fetching or consuming the library, I may opt-out of the "/v5" suffix in the import path and only adopt it in the scenario when I'd like to support "/v5" and "/v4" (or some other prior version), where I require the handling of multiple versions simultaneously in my program.

I believe the implementation of the above to be backwards compatible as developers would continue to use "github.com/go-chi/chi/v5" with older version of Go as SIV is implied, but optionally developers could make their choice of multiple-version support for the package by handling the import paths themselves and import "github.com/go-chi/chi" to utilize v5.x.x as specified by go.mod.

I believe changes to the Go toolchain for such support would be minimal and would be isolated to the components which build module lists.

Thank you for reading my proposal, and its consideration.

==== [Comments] ====

--- Comment #1 by peterbourgon ---
> Application developers may consume the package via `go get github.com/go-chi/chi@latest`

I believe this would represent a breaking change, as it is currently (?) parsed as the latest minor.patch version of major version v0 or v1. That's an artifact of what is I think the major problem with any form of optional SIV: the unversioned module path is, unfortunately, interpreted not as "no version specified" but instead as major version 0 or 1.

--- Comment #2 by theckman ---
@peterbourgon I'm not sure the Go toolchain has ever been covered under the compatibility guarantee, based on other "breaking" changes that have been made. The guarantee explicitly says

> Compatibility is at the source level.

--- Comment #3 by theckman ---
I'm currently a maintainer of the https://github.com/PagerDuty/go-pagerduty package, which was also incepted before Modules and never had 0.x releases. This decision for not using 0.x was made because they wanted to commit to not breaking the current version of the API, because PagerDuty is a critical service, while relying on the ease of major version bumps to have consumers pick up breaking changes as they get made within the library. This was the way they were going to iterate going forward, so that folks could lock into "stable" versions because they didn't want pulling in a 0.x release subtly breaking a consumer.

As of now I'm planning a `v1.5.0` breaking release to work around SIV not being optional. There is a bug that makes the current API not work reliably (two conflicting fields trying to be unmarshaled into), and removing the erroneous field may result in some people needing to update their code to use the `.ID` field instead of `.Id`.

I cannot in good faith justify forcing people to update all of their files that use our Go Module with the SIV for a one character change that they may use in one file. I'm sorta justifying the breaking change to myself because the API has never been stable due to the conflicting field names.

It would be ideal if the SIV component of the import was optional, if only one major version of a dependency is present in the `go.mod` file. That way folks could update their dependency, and only update the actual files that need to be changed. Likewise, we are still able to support more complex projects who need to roman-ride the major versions while doing the transition.

I genuinely believe it would be a great idea for us to really consider this proposal, and that it would be a nice improvement to the user experience of the Go Toolchain and Modules. I am confident that the need to roman-ride between two major versions of a package will only be needed by a small subset of the larger Go Ecosystem, and so I wonder if it makes sense to make it a requirement for all. I believe accepting this proposal would decrease the cognitive hurdles that may need to be overcome when trying maintain a Module, while also giving us the ability to be flexible for those who really need it.

**Edit:** Instead of reacting with :-1: this comment, could you comment below quoting what you disagree with and why? I think that would result in a much more constructive interaction.

--- Comment #4 by theckman ---
@nbys I see you ðŸ‘Ž on my comment. I'm sorta gonna put you on the spot and ask if you can explain what part of that you disagree with and why you disagree with it?

--- Comment #5 by peterbourgon ---
> I am confident that the need to roman-ride between two major versions of a package will only be needed by a small subset of the larger Go ecosystem . . .

And even for that tiny fraction of the ecosystem, the requirement typically exists only transiently, during a dependency upgrade process that requires multiple steps. And this might be worth stating explicitly, because I'm not sure it's understood by all the stakeholders: codebases which need to allow multiple major versions of a dependency in a single compilation unit in order to make a complicated upgrade tractable _are pathological_, not normal. Getting into that state isn't an inevitable   outcome of writing software, it's a product of a specific set of conditions representing a super-minority of projects in the overall ecosystem.

--- Comment #6 by thrawn01 ---
I'm the maintainer of https://github.com/mailgun/mailgun-go and I do understand this pain. The process of updating the mailgun-go library to v4 involved not only updating all the import paths but also every single golang code snippet in the mailgun documentation. This was a huge under taking that we don't wish to do again. 

Our hope is that https://github.com/golang/go/issues/32014 will get approved and standard tooling will exist to make upgrading import paths simple for both library devs and users. While this doesn't solve the need to update all our example snippets it should help ease the some of the pain that library maintainers have in this manner.

--- Comment #7 by pkieltyka ---
Respectfully, https://github.com/golang/go/issues/32014 is not a real solution to solving the challenges with SIV. As you said yourself, all of your documentation had to change as well, and that is just the beginning of the permanent tax on developer experience that SIV imposes for a niche use-case of multi-version support in a single program.

--- Comment #8 by bcmills ---
@theckman, I commented on your specific example in https://github.com/PagerDuty/go-pagerduty/issues/218#issuecomment-784486255.

I'm somewhat skeptical that a breaking change is really necessary there, but even if it is, it seems like the sort of fix that would be allowed within a major version under a Go-1-style compatibility policy. So I personally don't find that example particularly compelling.

--- Comment #9 by theckman ---
@bcmills The latter part of that post was showing a case where we ran into that problem that would only be a one-character change in consumer projects, but the SIV would make it so much larger. There is also this, which is a similar class of issue https://github.com/PagerDuty/go-pagerduty/pull/251 which I don't believe can be easily resolved without a BC. Let's focus on this overall need / desire instead:

> This decision for not using 0.x was made because they wanted to commit to not breaking the current version of the API, because PagerDuty is a critical service, while relying on the ease of major version bumps to have consumers pick up breaking changes as they get made within the library. This was the way they were going to iterate going forward, so that folks could lock into "stable" versions because they didn't want pulling in a 0.x release subtly breaking a consumer.

How would you address this need in Modules?

--- Comment #10 by ulikunitz ---
**Making it costly to break compatibility is a feature not a bug.**

@rsc has explained it here: https://research.swtch.com/vgo-import. I don't agree with Russ on everything (#38776) but I agree with him here.

Breaking changes are bad. Who is using Perl 6? Python 3 was a pain. Successful software usually takes compatibility seriously. Windows fakes internal structures to allow major applications still to run. 

Linus Torvalds wrote this:
> Breaking user programs simply isn't acceptable. (â€¦) We know that people use old binaries for years and years, and that making a new release doesn't mean that you can just throw that out. You can trust us.

I may also may remind on the Go 1 compatibility guideline was a huge factor for its success. You might want to read it again: https://golang.org/doc/go1compat

So if compatibility is such a huge factor for software success, why want to make it easy to make incompatible changes?









--- Comment #11 by nbys ---
> @nbys I see you ðŸ‘Ž on my comment. I'm sorta gonna put you on the spot and ask if you can explain what part of that you disagree with and why you disagree with it?

I am sorry if my downvote in some way offended you. 

> I cannot in good faith justify forcing people to update all of their files that use our Go Module with the SIV for a one character change that they may use in one file. I'm sorta justifying the breaking change to myself because the API has never been stable due to the conflicting field names.

I could add my cents only from a library-user perspective.
I do not think of the necessity to change imports for a new major version as something bad. SIV enforces us to consider an update to the major version as a serious change. 
In my opinion, it is worth to grep the project, change the import paths and actually revisit library usage. 
The proposal won't change anything for me. But I believe @latest will be then a common thing in a lot of libraries. And only because it is just easier.

P.S. sorry for my English

--- Comment #12 by theckman ---
@nbys absolutely no offense, a :-1: just doesn't help me challenge the ideas / opinions I have. Thank you so much for taking the time to reply so that I can understand where you're coming from. ðŸ‘ 

P.S. Your English was great!

--- Comment #13 by peterbourgon ---
> Making it costly to break compatibility is a feature not a bug.

The cost of breaking compatibility isn't constant, it's a function of many variables that can be different from project to project.

> Breaking changes are bad.

Not universally. Breaking changes are sometimes necessary, or even good.

--- Comment #14 by deltamualpha ---
I have a question about a specific part of the proposal from an application developer POV:

> Application developers may consume the package via go get github.com/go-chi/chi@latest or with @v5 or @v5.0.0 and the expected import path will be "github.com/go-chi/chi", however "github.com/go-chi/chi/v5" import path would also be valid and usable.

I import and use "github.com/go-chi/chi" and get version 5. (Assume, for the sake of argument, that no other libraries I use affect which version of chi MVS resolves to.) The chi developers tag and release v6.0.0. I install a new library, and run `go mod tidy`. Do I now find myself depending upon chi v6?

--- Comment #15 by pkieltyka ---
@deltamualpha no, upgrading to major versions should not be implicit via `go mod tidy`. Once a module in go.mod is set with a specific major version (similar to how every other package manager works in other ecosystems), a developer must explicitly instruct the module system to upgrade to a new major version.

`@latest` would imply the current major version which would be recorded in go.mod as the latest major at the time. In order to upgrade to v6.0.0 one would do `go get -u github.com/go-chi/chi@v6.0.0` or `go get -u github.com/go-chi/chi/v6`. However, I would argue that if one calls `go get -u github.com/go-chi/chi@latest` after a go.mod is set, then in this case it would also upgrade to the latest major release + version, in your example as v6.0.0.

However, the above notes are easily debatable and I don't hold any strong opinions on version management (other then of course go mod tidy should certainly not implicitly upgrade to a major version if one is already set in a go.mod).

--- Comment #16 by bcmills ---
@theckman 

> > This decision for not using 0.x was made because they wanted to commit to not breaking the current version of the API, because PagerDuty is a critical service, while relying on the ease of major version bumps to have consumers pick up breaking changes as they get made within the library. This was the way they were going to iterate going forward, so that folks could lock into "stable" versions because they didn't want pulling in a 0.x release subtly breaking a consumer.
>
> How would you address this need in Modules?

Honestly, I would not â€œ[rely] on the ease of major version bumpsâ€ at all. If a downstream user needs a fix for bug, and that fix is after a breaking change, then their only options are to either backport the fix to some fork of the package (possibly a release branch), or to stop and upgrade their code before they can fix it.

Instead, for the few cases where existing, previously-supported API is unsalvageable (such as the erroneous `Id` field, and perhaps the erroneous `Targets` fields in https://github.com/PagerDuty/go-pagerduty/pull/251), I would rely more heavily on [deprecation](http://golang.org/wiki/Deprecated) and/or compatibility shims (such as `{Marshal,Unmarshal}JSON` methods, for those examples).

--- Comment #17 by bcmills ---
(On a bit of a side-note, someone in the community recently showed me Rich Hickey's excellent [Spec-ulation](https://youtu.be/oyLBGkS5ICk) talk, which goes into great detail about the various dimensions of compatibility, versioning, and namespaces. It's worth a watch!)

--- Comment #18 by D1CED ---
> > Breaking changes are bad.
> 
> Not universally. Breaking changes are sometimes necessary, or even good.

This debate is not about ever making a breaking change but frequency and scope of them.

One camp is in favor of low frequency large breaking changes and the
other prefers more frequent and small breaking changes.

This proposal is a complaint of the second camp that they have to edit all imports on a 
release of a new major version to upgrade.

Either approach has its advantages and disadvantages but the community has to
decide what to encourage/discourage.

--- Comment #19 by peterbourgon ---
> This debate is not about ever making a breaking change but frequency and scope of them.

Yes.

> One camp is in favor of low frequency large breaking changes and the other prefers more frequent and small breaking changes.

No. One "camp" (i.e. Go modules) asserts that breaking changes are always very costly and should always be avoided. The other "camp" (i.e. myself and others) observes that breaking changes are not always very costly and do not necessarily need to be avoided.

> Either approach has its advantages and disadvantages but the community has to decide what to encourage/discourage.

Go the language can take very opinionated stances on a wide variety of topics, because it's just one programming language among many. If any of its opinions are a problem for a potential user, that user can simply opt out and not become a Gopher. But Go modules doesn't have the same license to assert what is and isn't allowed, because it has a monopoly on package management in the Go ecosystem. If any of its opinions are a problem for a potential user, that user cannot reasonably opt out and use another tool. By and large, modules, and other mandatory tooling, has to meet users where they are, not direct them to where the authors feel they ought to be.

--- Comment #20 by ulikunitz ---
Thinking further about it: Go's target was it to make software work at scale. And at scale every breaking change creates huge costs due to the number of imports of a module. Semantic import versioning actually reduces the cost of a breaking change at scale by giving it another name. And if you publish your code on the Internet you are working at scale, if you want it or not.

@bcmills Thank you for providing the [link](https://www.youtube.com/watch?v=oyLBGkS5ICk&feature=youtu.be) to Rich Hickey's talk. I can add him now to the people that think compatibility is a factor for successful software.

--- Comment #21 by theckman ---
> And at scale every breaking change creates huge costs due to the number of imports of a module.

@ulikunitz what if 99.99% of those who import you don't use the functionality you're breaking in the major version change, and as such it's a no-op to upgrade to your new major version. Wouldn't it be a much larger cost to force everyone to update their imports?

--- Comment #22 by peterbourgon ---
> Thinking further about it: Go's target was it to make software work at scale. And at scale every breaking change creates huge costs due to the number of imports of a module . . . And if you publish your code on the Internet you are working at scale, if you want it or not.

Not all Go modules get published to the public internet. Many are kept private, in corporate or other organizations. 

Not all modules are widely imported. Many are used by just one, or just two, consumers â€” especially private modules.

Not all modules, even widely imported modules, create huge costs when they make a breaking change. Consumers pin to a version and use it without interruption, regardless of the rate of iteration on the major (or minor, or patch) version numbers.

And not all modules contain code that _should_ work at scale, in the sense that you mean. Go is a general-purpose programming language, suitable for more than one type of user.

These are all normative claims about how the Go ecosystem should be, according to some specific (i.e. non-universal) set of assumptions. They don't describe the Go ecosystem as it actually exists.

--- Comment #23 by peterbourgon ---
> @ulikunitz what if 99.99% of those who import you don't use the functionality you're breaking in the major version change, and as such it's a no-op to upgrade to your new major version. Wouldn't it be a much larger cost to force everyone to update their imports?

Well, hopefully the goal here is to make it easier to consume major version updates, not to make it easier to violate semver ðŸ˜‰ 

--- Comment #24 by theckman ---
> Well, hopefully the goal here is to make it easier to consume major version updates, not to make it easier to violate semver ðŸ˜‰

I thought that's what I was communicating, making the cost to upgrade proportional to the change needed. ðŸ¤” 

--- Comment #25 by bytheway ---
I'm just a go user, but I really liked the idea of SIV. I feel like I understood the benefits, even if there was some pain.

Now that it is mandatory, however, I've watched public, useful libraries actively avoiding incrementing the major version when it would be the natural/semver thing to do, instead opting to rev a minor version number and "break" with semver guidelines. 

We've faced similar challenges and decisions with internal libraries at my company.  What could be a quick communication about an incompatibility and a one-line update to the go.mod to get the latest package can quickly turn into a large change set, touching many, many files.

I would love an option to opt-in to SIV when appropriate, with a less invasive default which doesn't require large changes to codebases, documentation, etc. in both the the package and importers of the package when a major version is  bumped.

Whatever the benefits of SIV are in theory, they are being rendered moot by the practice of library authors. I would love to see mandatory SIV revisited.

--- Comment #26 by veqryn ---
I actually like SIV.  I just wish it wasn't so hard to use SIV and so costly for small projects.
If I could go back in time, I would have forced all v0 and v1 modules to have that in their module path. Such as:
```
module github.com/veqryn/someproject/v0

go 1.16
```

and

```
module github.com/veqryn/someotherproject/v1

go 1.16
```

and

```
module github.com/veqryn/somematureproject/v2

go 1.16
```

Then, a small project might require these repos:

```
module github.com/veqryn/smallproject

go 1.16

require (
	github.com/veqryn/someproject/v0 v0.1.5
	github.com/veqryn/someotherproject/v1 v1.80.234
	github.com/veqryn/somematureproject/v2 v2.0.0
)
```

And then in the small project's code, they could use imports without the "vX" in them, so long as their go.mod never had multiple versions of that repo:


```go
package smallproject

import (
	"github.com/veqryn/someproject"
	"github.com/veqryn/someotherproject"
	"github.com/veqryn/somematureproject"
)
```

However, as soon as a project (or its dependencies) use more than one version, it would be suddenly required to add the "vX" to its imports:
```
module github.com/veqryn/bigproject

go 1.16

require (
	github.com/veqryn/somematureproject/v1 v1.9.1
	github.com/veqryn/somematureproject/v2 v2.0.1
)
```

Required to add the vX to the path, or else compiler error:
```go
package bigprojectold

import "github.com/veqryn/somematureproject/v1"
```
and
```go
package bigprojectnew

import "github.com/veqryn/somematureproject/v2"
```

If a dependency uses (requires) `github.com/veqryn/somematureproject/v2`, and your project uses (requires) `github.com/veqryn/somematureproject/v1`, then they both end up in your project's mod file, and you would be forced in your project to specify the "v1" path on all imports in your project.
The go compiler would be smart enough when compiling your dependencies to know that if the dependency only requires one version in its own mod file, then any imports in that dependency would use that version in the dependency's mod file, even if they don't have the "vX" in them.

I feel like this would be similar to how "embedding" structs in Golang lets you call member's function, until you have a conflict between multiple members with the same function name, and then Golang forces you to declare the function in the parent to resolve the conflict.

I think this would have solved a lot of problems, but I also don't see how to get there in an easily backwards compatible way. Go mod would have to declare all projects missing v0 and v1 in their module name as "incompatible", and have special logic for dealing with them.


--- Comment #27 by beoran ---
How about, in stead of this proposal, adding a `go mod upgrade` or such which installs the new major version of the dependency but also automatically updates all related imports in all go files in the module? Like that some of the pain of upgrading can be lessened already, in cases where the API didn't change all that much.

--- Comment #28 by Merovius ---
> I am confident that the need to roman-ride between two major versions of a package will only be needed by a small subset of the larger Go ecosystem . . .

I do not understand this confidence. As far as I can tell, [the need arises](https://research.swtch.com/vgo-import) for any module a) that has a diamond in its dependency graph and b) where the bottom of that diamond bumps their major version at some point. I do not understand why you think that would be a small subset of the Go ecosystem. Alternatively, you don't think those criteria are sufficient to imply the need, which seems entirely non-obvious to me as well - personally, I consider the argument Russ makes to be very convincing.

--- Comment #29 by Merovius ---
@pkieltyka In the proposal text, you distinguish between "the application perspective" and "the library perspective". As far as I'm aware, the only meaning of this in the Go ecosystem is "a `package main`" and "any other package" - but ISTM that's unlikely to be the meaning you intend (for one, most Go modules containing a `package main` also contain other packages. Also I can't imagine that your proposal really only targets imports written in a `package main`). I think it would be helpful if you could explain what you mean by that.

Note, in particular, that the author of the main module often has little control over whether or not they need multiple major versions in their package - if any part of their dependency graph requires it, they do too. So a priori, I think, there are more than two perspectives - you have leaf modules, intermediate modules (that both have dependencies and are dependencies) and main modules and each of those might or might not specify major versions in their import paths. And we need to consider how a major version bump in any of those cases affects the others. That matrix can probably be reasonably simplified down (for example, we probably only need to worry about major version bumps in leaves), but all these cases need to be covered somehow.

For example, say we have a leaf module `A` which module `B` and `C` depend on. Say `B` and `C` have opted out of SIV and want to use `v2` and `v3` of respectively. Now a fourth module `D` wants to import both `B` and `C`. Is that simply impossible, until they convince the authors of `B` and `C` to switch to SIV (or convince`B` to move to `A@v3`)? What major version would `D` use? Assume `A` declares a type `T` and `C` type-assert an argument to a function on `A.T` - if `D` passes an `A.D` from `B` to `C`, does that type-assertion fail?

Note that even if we accept "it only affects a minority of Go programs", that still doesn't absolve us from specifying the semantics when it does. I think the proposal needs a bit of elaboration on that front. Currently, an import path uniquely identifies a package, in a single build. Under your proposal, we both have a) different import paths referring to the same package and b) the same import path referring to different packages. It's not super clear to me how that would work, in respect to changes to the compiler and linker and `reflect`, for example. One appeal of SIV as a solution is that it's transparent to the language - the compiler doesn't have to know about modules and major versions, it just sees packages in opaque import paths.

--- Comment #30 by peterbourgon ---
> I do not understand why you think that would be a small subset of the Go ecosystem.

I have personally had what I consider to be substantial exposure to an enormous amount of Go code, due to my position in the OSS ecosystem, as well as my consulting work. That exposure includes, importantly, a huge amount of code maintained in private repositories. I have no way of knowing, but I suspect the only person in the Go community who may have seen more Go code than I have is Bill Kennedy. With that context, I can state without hesitation that the need to include two major versions of the same dependency in one compilation unit is _extraordinarily rare_, and in those rare circumstances that it does arise, it is almost always due to pathological conditions in the dependency graph.
