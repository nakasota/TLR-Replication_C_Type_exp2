=== Fetching Proposal: Limited use cases ===
Issue URL: https://github.com/golang/go/issues/53353

==== [Issue Title] ====
proposal: encoding/binary: 32-bit and 16-bit values

==== [Issue Body] ====
<!--
Our proposal process is documented here:
https://go.dev/s/proposal-process
-->

`encoding/binary` has constants defined for varints of sizes 16, 32, and 64, but no corresponding functions for 16 and 32.

https://github.com/golang/go/blob/55590f3a2b89f001bcadf0df6eb2dde62618302b/src/encoding/binary/varint.go#L33-L37

I propose the following new functions to be implemented for `src/encoding/binary/varint.go`

Uvarint32
```go
func Uvarint32(buf []byte) (uint32, int) {}
func ReadUvarint32(r io.ByteReader) (uint32, error) {}
```

Varint32
```go
func Varint32(buf []byte) (int32, int) {}
func ReadVarint32(r io.ByteReader) (int32, error) {}
```

Uvarint16
```go
func Uvarint16(buf []byte) (uint16, int) {}
func ReadUvarint16(r io.ByteReader) (uint16, error) {}
```

Varint16
```go
func Varint16(buf []byte) (int16, int) {}
func ReadVarint16(r io.ByteReader) (int16, error) {}
```


==== [Comments] ====

--- Comment #1 by randall77 ---
`AppendVarint32(buf, x)` is identical to `AppendVarint(buf, int64(x))` (where `x` is an `int32`). Similar for the other functions, I believe. I'm not sure we need separate functions.


--- Comment #2 by alzeih ---
`ReadUvarint` provides bounds checking based on the `MaxVarintLen64`. Does the alternative offered provide this checking ability?

--- Comment #3 by alzeih ---
@randall77 Thanks for the feedback. I've removed the `AppendUvarint` and `PutUvarint` functions from the proposal as the bounds checking only applies to the `Uvarint` and `ReadUvarint` functions.

--- Comment #4 by randall77 ---
@alzeih That's a fair point for the reading variants.


--- Comment #5 by rsc ---
We've gotten through over ten years without the lack of these being a problem. If there's a performance issue with AppendVarint(buf, int64(x)) for int32-valued x, maybe we can look at the implementation. But it doesn't seem like we need APIs for smaller ints, which are becoming less and less common.



--- Comment #6 by rsc ---

This proposal has been added to the [active column](https://golang.org/s/proposal-status#active) of the proposals project
and will now be reviewed at the weekly proposal review meetings.
— rsc for the proposal review group


--- Comment #7 by alzeih ---
As previously discussed, this proposal is concerned with reading varints, not writing them.

What about a func that allows for a caller specified maximum number of bytes to read? This would work for legacy (16, 32-bit), non-standard (24-bit?), and future (128-bit) varint sizes. The existing constants could be provided as an argument.

--- Comment #8 by ianlancetaylor ---
What is the actual use case here?

Can you just read a varint and then verify that it is in range?

--- Comment #9 by alzeih ---
Reading a uvarint32 from a binary file format and not wanting the func to take more than it should out of the buffer, which would affect reading the rest of the file.



--- Comment #10 by ianlancetaylor ---
The varint encoding is self-delimiting.  The limit of `MaxVarintLen64` is to catch erroneous data.  For correct data it will never be used.  For erroneous data, it doesn't matter whether it affects reading the rest of the file, because the data is erroneous anyhow.

--- Comment #11 by alzeih ---
Okay. I was under the impression that reading more of the buffer than intended could be a bad thing (#41185). I can see this proposal is unlikely to proceed based on the feedback. Thanks for the input.



--- Comment #12 by rsc ---

Based on the discussion above, this proposal seems like a **[likely decline](https://golang.org/s/proposal-status#likely-decline)**.
— rsc for the proposal review group


--- Comment #13 by rsc ---

No change in consensus, so **[declined](https://golang.org/s/proposal-status#declined)**.
— rsc for the proposal review group

