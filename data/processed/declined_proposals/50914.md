=== Fetching Proposal: Breaking Go's principles ===
Issue URL: https://github.com/golang/go/issues/50914

==== [Issue Title] ====
proposal: cmd/vet: report unused type parameters

==== [Issue Body] ====
### What version of Go are you using (`go version`)?

<pre>
$ go version
go version go1.18beta1 darwin/arm64
</pre>

### What operating system and processor architecture are you using (`go env`)?

<details><summary><code>go env</code> Output</summary><br><pre>
$ go env
GO111MODULE=""
GOARCH="arm64"
GOBIN=""
GOCACHE="/Users/vegarsti/Library/Caches/go-build"
GOENV="/Users/vegarsti/Library/Application Support/go/env"
GOEXE=""
GOEXPERIMENT=""
GOFLAGS=""
GOHOSTARCH="arm64"
GOHOSTOS="darwin"
GOINSECURE=""
GOMODCACHE="/Users/vegarsti/go/pkg/mod"
GONOPROXY=""
GONOSUMDB=""
GOOS="darwin"
GOPATH="/Users/vegarsti/go"
GOPRIVATE=""
GOPROXY="https://proxy.golang.org,direct"
GOROOT="/Users/vegarsti/sdk/go1.18beta1"
GOSUMDB="sum.golang.org"
GOTMPDIR=""
GOTOOLDIR="/Users/vegarsti/sdk/go1.18beta1/pkg/tool/darwin_arm64"
GOVCS=""
GOVERSION="go1.18beta1"
GCCGO="gccgo"
AR="ar"
CC="clang"
CXX="clang++"
CGO_ENABLED="1"
GOMOD="/Users/vegarsti/dev/go-generic-test/go.mod"
GOWORK=""
CGO_CFLAGS="-g -O2"
CGO_CPPFLAGS=""
CGO_CXXFLAGS="-g -O2"
CGO_FFLAGS="-g -O2"
CGO_LDFLAGS="-g -O2"
PKG_CONFIG="pkg-config"
GOGCCFLAGS="-fPIC -arch arm64 -pthread -fno-caret-diagnostics -Qunused-arguments -fmessage-length=0 -fdebug-prefix-map=/var/folders/rp/9sx14sg570j1_s4lmkmgwm9r0000gn/T/go-build1502445601=/tmp/go-build -gno-record-gcc-switches -fno-common"
</pre></details>

### What did you do?
File `main.go` contains

```go
package main

func f[T int]() {}
```
and run `go1.18beta1 vet main.go`.

### What did you expect to see?
Something like "`f: type parameter T is not used`"

### What did you see instead?
No output; exit code 0 indicating no issues found in file.


### Rationale
`go vet` doesn't report on unused arguments.
This is nice, because you may need to conform to a certain interface even though you don't use all arguments.
In this example program, we specify a type parameter, but we don't apply the argument to anything.
This is different, in my opinion, because the type parameter list is simply redundant in this case.
Implementing this may help for example where a user has started out implementing a function as generic, decided not to, but forgot to remove the type parameter list.

I apologize if this has been discussed already! I didn't find anything on here.

==== [Comments] ====

--- Comment #1 by vegarsti ---
Thanks @seankhliao!

--- Comment #2 by ianlancetaylor ---
That would make it difficult to write code like

```Go
type Zero[T any] struct{}
func (Zero[T]) Get() T {
    var zero T
    return zero
}
```

That's a fairly simple version but one can imagine more complicated ones.

For functions, it's possible to imagine having a family of functions that all share the same type parameters, even if they don't all use them.

Giving an error for unused local variables is helpful because they normally indicate a bug in the program.  That is less clear for unused type parameters.

--- Comment #3 by vegarsti ---
Thanks for the quick reply @ianlancetaylor!

> For functions, it's possible to imagine having a family of functions that all share the same type parameters, even if they don't all use them.

That makes sense. I can see that it would be annoying to get an error from vet in such cases. And as you say, there's probably other scenarios where reporting an error would have a negative effect.

I don't quite see how the example you posted with a type is the same kind as with the function example above. You don't have to, of course, but could you explain why this is similar? I would think that there are no unused type parameters in the method `Get()`, since `T` is used as a return type.
I admit I haven't spent time trying out generic _types_ yet, so that might be why I don't see it.

As for this issue, I was probably too quick! I'm fine with this being closed.

--- Comment #4 by timothy-king ---
I think in the spirit of the suggestion for named types with methods, the vet check would likely require checking if the type parameter type is used in the underlying type or within any method for the named type.
```
type N[T any} struct {
  x T
}
```

AFAICT a pattern this does rule out is to use generic functions for type assertions for tilde and bar types.
```
type S int

func (S) Bar() {}
func f[T interface {
	Bar()
	~int | ~string
}]() {
}
func _() {
	f[S]()
}
```
Seems somewhat reasonable?

--- Comment #5 by bcmills ---
This proposal seems analogous to reporting unused function arguments, which we also don't do today.

I don't think we should report on unused type parameters going forward, either. It may be that the implementation of a struct or function initially depends on all of its type parameters but is then refactored such that one or more of the parameters is no longer needed. However, the extra parameter cannot be removed without breaking compatibility: existing users may already instantiate it explicitly.

This seems like a fine check for more aggressive linters, but I think the false-positive rate will be too high in the long run for `cmd/vet`.

--- Comment #6 by rsc ---

Based on the discussion above, this proposal seems like a **[likely decline](https://golang.org/s/proposal-status#likely-decline)**.
— rsc for the proposal review group


--- Comment #7 by rsc ---

No change in consensus, so **[declined](https://golang.org/s/proposal-status#declined)**.
— rsc for the proposal review group

