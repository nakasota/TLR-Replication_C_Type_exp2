=== Fetching Proposal: Poor feasibility ===
Issue URL: https://github.com/golang/go/issues/47459

==== [Issue Title] ====
proposal: spec: allow omitting type parameters in methods that don't use them

==== [Issue Body] ====
In the current generics proposal, all methods on a generic type must mention the type's type parameters.

For example:

```
type Foo[T1, T2 any] struct {...}

func (f *Foo[T1, T2]) Something() {}
```

It seems to be very common that methods like this don't actually need to mention the type parameters by name, which makes it tedious to declare them. One possibility is to avoid giving them names:

```
func (f *Foo[_, _]) Something() {}
```

but that doesn't help the extra verbosity much.

I propose that the type parameter clause in methods should only be required if the method body actually uses the type parameters.

This also makes it easier to refactor code when we might wish to add or remove type parameters to a type without undue code churn.

So we'd allow this, even though `Foo` is a generic type:

```
func (f *Foo) Something() {}
```


==== [Comments] ====

--- Comment #1 by ianlancetaylor ---
CC @griesemer 

--- Comment #2 by griesemer ---
@rogpeppe Do you have a sense for how common this situation might be? (Things like `func (recv T) Len() int` where we don't care about the element type of a generic container come to mind. But is that about it?)

--- Comment #3 by mvdan ---
> Do you have a sense for how common this situation might be? (Things like `func (recv T) Len() int` where we don't care about the element type of a generic container come to mind. But is that about it?)

That's the data point that a colleague encountered at work, which made me ask Roger about this feature yesterday, triggering the proposal :) Essentially, someone was trying type parameters on a large existing codebase, and a type with dozens of methods only needed to use the receiver's type parameters in about half of its methods. The other methods all had to gain repetitive `[_, _]` bits.

It's just one data point, so I can't argue how often this will be the case with methods on generic types. But it seems like an easy win to make this optional, just like other bits of a function declaration (return parameters, receiver, parameter names) are also optional.

--- Comment #4 by rogpeppe ---
> @rogpeppe Do you have a sense for how common this situation might be? (Things like func (recv T) Len() int where we don't care about the element type of a generic container come to mind. But is that about it?)

In my experience refactoring and writing generic code, it's considerably more common than not. There are often auxiliary methods that don't touch the generic type at all, but also even methods that _do_ touch the generic types can often do so without mentioning the type name specifically.

Here's an example of the latter from a trie container type that I converted to use generics:

```
func (i *Iter[Key, Value]) pop() {
	i.stack = i.stack[0:len(i.stack)-1]
}
```

Although `i.stack` is made of generic values, there's no need for the signature or the body of the function to mention the type parameters, so they seem redundant.

Basically, ISTM that any place that one might use `_` as the name of all type parameters it would be nicer to be able to omit them completely.


--- Comment #5 by beoran ---
I will go against the flow here. I think func (f *Foo[_, _]) Something() {} is fine. It's explicit, yes, but then it's very clear that we are defining a method of a generic type. 

Please consider that the method Something might be defined in a different file than the type Foo, e g. in case of code generation. Then, allowing to omit the type parameters is confusing because it seems like we are defining a method on a normal type.

So for the sake of readability and explicitness, I respectfully oppose this proposal.

--- Comment #6 by rogpeppe ---
> Then, allowing to omit the type parameters is confusing because it seems like we are defining a method on a normal type

Why do you think it helps to know that we're defining a method on a generic type vs a normal type?

--- Comment #7 by beoran ---
Because the generic type has additional parameters that may or may not influence functionality, just like normal parameters do. 

For example , a method `func (f *Foo[_,_]) Something(Bar)` is a great way of saying, "This generic method doesn't use the type parameters and has a regular parameter of type Bar that is also unused". 

I tend to use cheap old computers without IDE nor gopls. When I look at a file with my editor I can only see what is in it. 
If I'm looking at different file than where type Foo[T, U] is defined, and I see  a method `func (f *Foo) Something(Bar)` there, then in this case I will wrongly assume Foo is not a generic type.  I have to go to the trouble of of finding out where Foo is defined and opening the other file where Foo is defined to see that my assumption is wrong. With the "pants operator" `[_,_]` it is immediately clear that the type is generic without having to open the file with the definition.

And why its it important to know whether a type is generic or not? When defining or even reading a method on a type one must know the details of that type, and the fact that it is generic is an important detail.

--- Comment #8 by rogpeppe ---
> And why its it important to know whether a type is generic or not? When defining or even reading a method on a type one must know the details of that type, and the fact that it is generic is an important detail.

There are lots of other details of that type that are important details too (for example: is it a struct or some other type?) that aren't encoded in the method definition. Why does this particular aspect deserve to be different?


--- Comment #9 by velovix ---
Should we be concerned about this causing confusion about the nature of Go generics? I believe there's no other place in the language where a generic type can be referenced without type parameters, and that reflects Go's lack of support for passing around "meta-types" or using "raw types", as they're called in Java. This consistency seems desirable to me.

That said, I am sympathetic to the motivation behind this proposal. I wonder if syntax that keeps the brackets but avoids enumerating the type arguments would be more clear, maybe by using ellipses:

```go
func (f *Foo[...]) Something() {}
```

This syntax is still preferable to using underscores, because it never needs to be changed as the number of type parameters changes.

--- Comment #10 by beoran ---
Type parameters are also parameters. For normal parameters in the case of , say `func DoesNotUseParams (_ ...string)`, I certainly wouldn't argue for a special notation to be able to simplify that definition.  Same for the type parameters. 

Also it's not because a method doesn't use the type parameters now that it might not need to use them in the future. Better leave them visible so they are easily used when they turn out to be needed.

Edit: So, I consider it incidental whether or not a parameter or type parameter is actually used. Such incidents usually don't warrant special syntax.


--- Comment #11 by rogpeppe ---
> Type parameters are also parameters. For normal parameters in the case of , say `func DoesNotUseParams (_ ...string)`, I certainly wouldn't argue for a special notation to be able to simplify that definition. Same for the type parameters.

We already _have_ a special notation to simplify that definition: `func DoesNotUseParams(... string)`.

> Also it's not because a method doesn't use the type parameters now that it might not need to use them in the future. Better leave them visible so they are easily used when they turn out to be needed.

Surely they're trivial to add when needed (just like function parameter names) ?


--- Comment #12 by rsc ---
This seems like a premature optimization.
Also the signal in the method that Foo is a parameterized type seems important to preserve.


--- Comment #13 by beoran ---
Ok, so we have func DoesNotUseParams(... string). But we don't have func DoesNotUseParams {...}. The mere presence of the argument list is an important signal. Same for type parameters.

--- Comment #14 by rsc ---

This proposal has been added to the [active column](https://golang.org/s/proposal-status#active) of the proposals project
and will now be reviewed at the weekly proposal review meetings.
— rsc for the proposal review group


--- Comment #15 by rsc ---

Based on the discussion above, this proposal seems like a **[likely decline](https://golang.org/s/proposal-status#likely-decline)**.
— rsc for the proposal review group


--- Comment #16 by rsc ---

No change in consensus, so **[declined](https://golang.org/s/proposal-status#declined)**.
— rsc for the proposal review group


--- Comment #17 by rogpeppe ---
Sorry, I missed this comment and the "likely decline" comment, so responding too late, sorry!

@rsc 
> Also the signal in the method that Foo is a parameterized type seems important to preserve.

I don't understand why it's an important signal to preserve. If you're not mentioning the parameterised type by name in the method, then it doesn't make any difference whether the type is parameterised or not - the type comes from "elsewhere" and the fact that it's a method on a generic type doesn't really affect how you read the body of the method AFAICS. The type parameters are just annoying noise to type (and actively get in the way when refactoring to add or remove type params).

Still, we can revisit this at a later date when we get more experience.
