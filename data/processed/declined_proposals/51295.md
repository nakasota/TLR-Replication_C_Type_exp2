=== Fetching Proposal: Lack of knowledge ===
Issue URL: https://github.com/golang/go/issues/51295

==== [Issue Title] ====
proposal: encoding/base64: add Encoding.EncodeString to match DecodeString

==== [Issue Body] ====
The DecodeString() method exists as a single function, an EncodeString() method should be added as it will not break forward compatibility and conform to a standard naming structure and module offering.

https://pkg.go.dev/encoding/base64

This is not a duplicate of a bug, I was asked to make it a proposal regardless of it being a bug or proposal. 

This is a proposal in writing to a software repository.

==== [Comments] ====

--- Comment #1 by klauspost ---
`DecodeString` is (b64 encoded string) -> (unencoded []byte).

The reverse is `EncodeToString`, which does (unencoded []byte) -> (b64 encoded string).

I am not sure what else you are looking for.

--- Comment #2 by seebs ---
Is the function `EncodeToString` the behavior you want, and you think it should be named `EncodeString`?

--- Comment #3 by ianlancetaylor ---
What is the exact API that you are proposing?

We currently have

```Go
// DecodeString returns the bytes represented by the base64 string s.
func (enc *Encoding) DecodeString(s string) ([]byte, error)

// EncodeToString returns the base64 encoding of src.
func (enc *Encoding) EncodeToString(src []byte) string
```

What are you suggesting that we add?  Thanks.

--- Comment #4 by andrewhodel ---
@ianlancetaylor 

Do you not understand that the input arguments to those functions are different?

If there is an Encode function there should be a Decode function with the same name structure and:

* the same input argument types
* the same output argument types

I realize what happened, someone was building it and needing to encode a byte array to a string so they wrote that function, then needed to decode a string to a byte array so they wrote that function.

When people read the documentation first, they are confused by the lack of a common naming structure and input/output type structure.

That should be cleaned and reorganized so that when people are working and reading the 1000's of Go functions (certainly impossible to remember all) they will not get frustrated by constant flipping between string and []byte and a lack of a naming structure that can be quickly remembered because it adheres to both common function names per functionality and input/output type.

--- Comment #5 by andrewhodel ---
You must understand, your company can afford to pay people to do things like that and have a team leader structure that respects who actually made things.

That's why you have things like Gmail and Go, because you let people work and then lead other people to finish their work, not tried to confuse them with constant changes that no single person understands.

It was the same way at Ford, it was the same way at Chevy, it is the same way at Boeing, Lockheed Martin, etc....

--- Comment #6 by randall77 ---
@andrewhodel Help us out a bit if you want us to consider your change. Please tell us exactly what method you want added. You've more than adequately defined the motivation - but we're still not clear on what exactly the changes you're proposing are. Write us a prototype of the function/method you want, and a 1-2 sentence godoc description of what it does. Thanks.



--- Comment #7 by andrewhodel ---
@randall77 

`EncodeString()` and `DecodeString()` should both exist because one of them does and the concept of encoding/decoding is fundamentally bound together.

I didn't read every function, but you should and you should adhere this naming structure and ensure that all relevant sets exist.

In other words

`Encode([]byte)` means there should be `Decode([]byte)`

`function_1_group_with_3_total()` should include `function_2_group_with_3_total()` and `function_3_group_with_3_total()` and so on.  For example, with hash functions there is usually a standard naming format due to the required functions, that of `input`, `parse`, `decode`, `inputMore` etc.

Then when someone is working for example with the encoding/base64 library, they can set a number of days or hours aside to work with the library then get used to the functions.  In other words, they can type Encode and Decode and EncodeString and DecodeString enough times to not need to deal with remembering arguments to every single function instead only needing to remember the top level function names as they all follow a common naming pattern.

--- Comment #8 by randall77 ---
Ok, but you still haven't answered my question - what exactly are you proposing to add to `encoding/base64`?


--- Comment #9 by andrewhodel ---
@randall77 

I answered your question in the first sentence of the original reply to your original comment/question.

EncodeString() and DecodeString() should both exist because one of them does and the concept of encoding/decoding is fundamentally bound together.

These are functions in Go of the encoding/base64 library.  One exists, one doesn't.  Again, these are functions in Go.

--- Comment #10 by ianlancetaylor ---
@andrewhodel That is not an answer to the question that @randall77 asked and it is not an answer to the question I asked.

I will repeat:

We currently have

```Go
// DecodeString returns the bytes represented by the base64 string s.
func (enc *Encoding) DecodeString(s string) ([]byte, error)

// EncodeToString returns the base64 encoding of src.
func (enc *Encoding) EncodeToString(src []byte) string
```

What are you suggesting that we add? Please write it in the exact form that I wrote it.  This is a programming language. 
 Precision matters.  Please write down exactly what you mean.  Don't describe what you mean in words.  Write it in Go.  Thanks.

--- Comment #11 by andrewhodel ---
```
func (enc *Encoding) EncodeString(s string) ([]byte, error)
```

You should also read and make sure all the other pairs exist for encoding and decoding of, with respect to both input and output:

* byte arrays
* strings

If you want me to write it, then provide commit access.

--- Comment #12 by ianlancetaylor ---
You can write any change you like without commit access, as described at https://go.dev/doc/contribute.  Thanks.

--- Comment #13 by andrewhodel ---
@ianlancetaylor then make:

@ianlancetaylor 
@prattmic 
@findleyr 
@cherrymui 

All work that way for every commit or stop with the absurdity.

--- Comment #14 by ianlancetaylor ---
We do all work that way for every commit.  Why do you think we don't?

--- Comment #15 by andrewhodel ---
@ianlancetaylor 

That's not true, you push changes directly to the repository.

--- Comment #16 by ianlancetaylor ---
@andrewhodel That is not correct.  Why do you think it is?

All changes to the Go repository must be reviewed and approved by somebody else, as described at https://go.dev/doc/contribute#review.  That is true for everybody.

What is different for people with approval access is that they only require one reviewer, not two reviewers.  See https://go.dev/wiki/GerritAccess.

--- Comment #17 by andrewhodel ---
You are adjusting time and commits to dev while calling it changes. 

Thank You,
Andrew Hodel

> On Feb 22, 2022, at 10:58 AM, Ian Lance Taylor ***@***.***> wrote:
> 
> ﻿
> @andrewhodel That is not correct. Why do you think it is?
> 
> All changes to the Go repository must be reviewed and approved by somebody else, as described at https://go.dev/doc/contribute#review. That is true for everybody.
> 
> What is different for people with approval access is that they only require one reviewer, not two reviewers. See https://go.dev/wiki/GerritAccess.
> 
> —
> Reply to this email directly, view it on GitHub, or unsubscribe.
> You are receiving this because you were mentioned.


--- Comment #18 by ianlancetaylor ---
> You are adjusting time and commits to dev while calling it changes.

I'm sorry, I don't understand what you mean.

--- Comment #19 by andrewhodel ---
I map all that stuff out with https://github.com/andrewhodel/rrd based on word counts and frequency to prove it to people. 



Thank You,
Andrew Hodel

> On Feb 22, 2022, at 11:06 AM, Andrew Hodel ***@***.***> wrote:
> 
> ﻿You are adjusting time and commits to dev while calling it changes. 
> 
> Thank You,
> Andrew Hodel
> 
>>> On Feb 22, 2022, at 10:58 AM, Ian Lance Taylor ***@***.***> wrote:
>>> 
>> ﻿
>> @andrewhodel That is not correct. Why do you think it is?
>> 
>> All changes to the Go repository must be reviewed and approved by somebody else, as described at https://go.dev/doc/contribute#review. That is true for everybody.
>> 
>> What is different for people with approval access is that they only require one reviewer, not two reviewers. See https://go.dev/wiki/GerritAccess.
>> 
>> —
>> Reply to this email directly, view it on GitHub, or unsubscribe.
>> You are receiving this because you were mentioned.


--- Comment #20 by randall77 ---
I don't see why `EncodeString` should return an error. The other `Encode` functions do not. Base64 encoding and decoding are not symmetric in that encoding should always succeed, whereas decoding might not.

Other than that, seems like a reasonable function to have.  Do you have a situation where you have a `string` source and wish to encode it to a `[]byte` output? Just wondering if this is a function you actually ran into a need for, or if you just were confused about the lack of a symmetric API.



--- Comment #21 by ianlancetaylor ---
In any case, thanks for defining precisely what you suggest that we add (although you omitted the doc comment).  I gather you are thinking of something along the lines of

```Go
// EncodeString returns the base64 encoding of s.
func (enc *Encoding) EncodeString(s string) ([]byte, error) {
    buf := make([]byte, enc.EncodedLen(len(s)))
    enc.Encode(buf, []byte(src))
    return buf, nil
}
```

I think the argument that you are making is that this is parallel to the existing `DecodeString` method.

How often does a need for this method come up in practice?  Do you have any examples of code that would use it?  Thanks.

--- Comment #22 by andrewhodel ---
Start counting them you will find out. It is basic manipulation of words causing the new words to exist. 

If you count the number of times someone commits vs the changes approved in that list you will get it. 



Thank You,
Andrew Hodel

> On Feb 22, 2022, at 11:07 AM, Ian Lance Taylor ***@***.***> wrote:
> 
> ﻿
> You are adjusting time and commits to dev while calling it changes.
> 
> I'm sorry, I don't understand what you mean.
> 
> —
> Reply to this email directly, view it on GitHub, or unsubscribe.
> You are receiving this because you were mentioned.


--- Comment #23 by andrewhodel ---
Lack of symmetry. 

Yes you need an error, what if the memory bound is reached while reading?

Thank You,
Andrew Hodel

> On Feb 22, 2022, at 11:09 AM, Keith Randall ***@***.***> wrote:
> 
> ﻿
> I don't see why EncodeString should return an error. The other Encode functions do not. Base64 encoding and decoding are not symmetric in that encoding should always succeed, whereas decoding might not.
> 
> Other than that, seems like a reasonable function to have. Do you have a situation where you have a string source and wish to encode it to a []byte output? Just wondering if this is a function you actually ran into a need for, or if you just were confused about the lack of a symmetric API.
> 
> —
> Reply to this email directly, view it on GitHub, or unsubscribe.
> You are receiving this because you were mentioned.


--- Comment #24 by ianlancetaylor ---
> I map all that stuff out with https://github.com/andrewhodel/rrd based on word counts and frequency to prove it to people.

OK, great.  Do you want to try to prove it to me?

I mean, I know that I am telling you the truth about our code review process.  I don't understand what you could do to demonstrate that I am not telling the truth.  But I am mildly curious as to where the misunderstanding arises.

--- Comment #25 by ianlancetaylor ---
> Yes you need an error, what if the memory bound is reached while reading?

If a Go program runs out of memory, it will crash.  There is no way for a function to return an error because it has run out of memory.

--- Comment #26 by ianlancetaylor ---
> If you count the number of times someone commits vs the changes approved in that list you will get it.

Again, I'm sorry, but I don't understand what you mean.  If you have actual data, can you simply show it?

--- Comment #27 by andrewhodel ---
Again. This is why other libraries have per iteration input functions, for reading streams etc. 

That isn’t to say that you could read the input string length, then read the available memory and know what difference the encoding process will require (bytes per chunk for input and output + anything else) and return an error when that is greater than n*available. 

That is how things work. 



Thank You,
Andrew Hodel

> On Feb 22, 2022, at 11:13 AM, Ian Lance Taylor ***@***.***> wrote:
> 
> ﻿
> If you count the number of times someone commits vs the changes approved in that list you will get it.
> 
> Again, I'm sorry, but I don't understand what you mean. If you have actual data, can you simply show it?
> 
> —
> Reply to this email directly, view it on GitHub, or unsubscribe.
> You are receiving this because you were mentioned.


--- Comment #28 by andrewhodel ---
It is because you aren’t respecting the development branch as a place to read changes before versioned approval. 

In other words, why do you have release candidates?

Thank You,
Andrew Hodel

> On Feb 22, 2022, at 11:12 AM, Ian Lance Taylor ***@***.***> wrote:
> 
> ﻿
> I map all that stuff out with https://github.com/andrewhodel/rrd based on word counts and frequency to prove it to people.
> 
> OK, great. Do you want to try to prove it to me?
> 
> I mean, I know that I am telling you the truth about our code review process. I don't understand what you could do to demonstrate that I am not telling the truth. But I am mildly curious as to where the misunderstanding arises.
> 
> —
> Reply to this email directly, view it on GitHub, or unsubscribe.
> You are receiving this because you were mentioned.


--- Comment #29 by andrewhodel ---
These truths of memory testing (especially when it is very low resource usage to do so) are similar to network programming in a day and age that testing is sold for entertainment as blocking certain tcp packets against protocol. 

In other words it has to be dealt with anytime network traffic is greater than the packet MTU so may as well exist at the memory level. 

Thank You,
Andrew Hodel

> On Feb 22, 2022, at 11:23 AM, Andrew Hodel ***@***.***> wrote:
> 
> ﻿Again. This is why other libraries have per iteration input functions, for reading streams etc. 
> 
> That isn’t to say that you could read the input string length, then read the available memory and know what difference the encoding process will require (bytes per chunk for input and output + anything else) and return an error when that is greater than n*available. 
> 
> That is how things work. 
> 
> 
> 
> Thank You,
> Andrew Hodel
> 
>>> On Feb 22, 2022, at 11:13 AM, Ian Lance Taylor ***@***.***> wrote:
>>> 
>> ﻿
>> If you count the number of times someone commits vs the changes approved in that list you will get it.
>> 
>> Again, I'm sorry, but I don't understand what you mean. If you have actual data, can you simply show it?
>> 
>> —
>> Reply to this email directly, view it on GitHub, or unsubscribe.
>> You are receiving this because you were mentioned.


--- Comment #30 by rsc ---
The current helper methods assume that base64 is applied to binary data, which is almost always a []byte.
And it is applied to create text data, which is often a string.
So the API uses []byte for the binary (unencoded) data, and string for the text (encoded) data.
This has worked very well in practice. 
There is no obvious reason we should add the other pairs, which would at the very least confuse me when reading the API.



