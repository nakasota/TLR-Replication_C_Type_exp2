{
  "generated_at": "20250627_132602",
  "statistics": {
    "total_proposals": 5,
    "successful_proposals": 2,
    "failed_proposals": 3,
    "total_files": 2,
    "total_functions": 2
  },
  "results": [
    {
      "proposal_file": "/workspace/data/preprocess/accepted_proposals/test_proposals/26535.md",
      "cl_number": "123478",
      "status": "NEW",
      "subject": "compress/lzw: optimize code hash table to reduce collisions",
      "modified_files": [
        {
          "file_path": "src/compress/lzw/writer.go",
          "modified_functions": [
            {
              "name": "Write",
              "start_line": 122,
              "end_line": 196,
              "context_before": "\t}\n\treturn nil\n}\n\n// Write writes a compressed representation of p to w's underlying writer.",
              "function_code": "func (w *Writer) Write(p []byte) (n int, err error) {\n\tif w.err != nil {\n\t\treturn 0, w.err\n\t}\n\tif len(p) == 0 {\n\t\treturn 0, nil\n\t}\n\tif maxLit := uint8(1<<w.litWidth - 1); maxLit != 0xff {\n\t\tfor _, x := range p {\n\t\t\tif x > maxLit {\n\t\t\t\tw.err = errors.New(\"lzw: input byte too large for the litWidth\")\n\t\t\t\treturn 0, w.err\n\t\t\t}\n\t\t}\n\t}\n\tn = len(p)\n\tcode := w.savedCode\n\tif code == invalidCode {\n\t\t// This is the first write; send a clear code.\n\t\t// https://www.w3.org/Graphics/GIF/spec-gif89a.txt Appendix F\n\t\t// \"Variable-Length-Code LZW Compression\" says that \"Encoders should\n\t\t// output a Clear code as the first code of each image data stream\".\n\t\t//\n\t\t// LZW compression isn't only used by GIF, but it's cheap to follow\n\t\t// that directive unconditionally.\n\t\tclear := uint32(1) << w.litWidth\n\t\tif err := w.write(w, clear); err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t\t// After the starting clear code, the next code sent (for non-empty\n\t\t// input) is always a literal code.\n\t\tcode, p = uint32(p[0]), p[1:]\n\t}\nloop:\n\tfor _, x := range p {\n\t\tliteral := uint32(x)\n\t\tkey := code<<8 | literal\n\t\t// If there is a hash table hit for this key then we continue the loop\n\t\t// and do not emit a code yet.\n\t\thash := (key>>12 ^ key) & tableMask\n\t\tfor h, t := hash, w.table[hash]; t != invalidEntry; {\n\t\t\tif key == t>>12 {\n\t\t\t\tcode = t & maxCode\n\t\t\t\tcontinue loop\n\t\t\t}\n\t\t\th = (h + 1) & tableMask\n\t\t\tt = w.table[h]\n\t\t}\n\t\t// Otherwise, write the current code, and literal becomes the start of\n\t\t// the next emitted code.\n\t\tif w.err = w.write(w, code); w.err != nil {\n\t\t\treturn 0, w.err\n\t\t}\n\t\tcode = literal\n\t\t// Increment e.hi, the next implied code. If we run out of codes, reset\n\t\t// the writer state (including clearing the hash table) and continue.\n\t\tif err1 := w.incHi(); err1 != nil {\n\t\t\tif err1 == errOutOfCodes {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tw.err = err1\n\t\t\treturn 0, w.err\n\t\t}\n\t\t// Otherwise, insert key -> e.hi into the map that e.table represents.\n\t\tfor {\n\t\t\tif w.table[hash] == invalidEntry {\n\t\t\t\tw.table[hash] = (key << 12) | w.hi\n\t\t\t\tbreak\n\t\t\t}\n\t\t\thash = (hash + 1) & tableMask\n\t\t}\n\t}\n\tw.savedCode = code\n\treturn n, nil\n}",
              "context_after": "\n// Close closes the [Writer], flushing any pending output. It does not close\n// w's underlying writer.\nfunc (w *Writer) Close() error {\n\tif w.err != nil {"
            }
          ]
        }
      ]
    },
    {
      "proposal_file": "/workspace/data/preprocess/accepted_proposals/test_proposals/21865.md",
      "cl_number": "162297",
      "status": "MERGED",
      "subject": "crypto/rc4: remove false guarantees from Reset docs and deprecate it",
      "modified_files": [
        {
          "file_path": "src/crypto/rc4/rc4.go",
          "modified_functions": [
            {
              "name": "NewCipher",
              "start_line": 33,
              "end_line": 51,
              "context_before": "\treturn \"crypto/rc4: invalid key size \" + strconv.Itoa(int(k))\n}\n\n// NewCipher creates and returns a new [Cipher]. The key argument should be the\n// RC4 key, at least 1 byte and at most 256 bytes.",
              "function_code": "func NewCipher(key []byte) (*Cipher, error) {\n\tif fips140only.Enabled {\n\t\treturn nil, errors.New(\"crypto/rc4: use of RC4 is not allowed in FIPS 140-only mode\")\n\t}\n\tk := len(key)\n\tif k < 1 || k > 256 {\n\t\treturn nil, KeySizeError(k)\n\t}\n\tvar c Cipher\n\tfor i := 0; i < 256; i++ {\n\t\tc.s[i] = uint32(i)\n\t}\n\tvar j uint8 = 0\n\tfor i := 0; i < 256; i++ {\n\t\tj += uint8(c.s[i]) + key[i%k]\n\t\tc.s[i], c.s[j] = c.s[j], c.s[i]\n\t}\n\treturn &c, nil\n}",
              "context_after": "\n// Reset zeros the key data and makes the [Cipher] unusable.\n//\n// Deprecated: Reset can't guarantee that the key will be entirely removed from\n// the process's memory."
            }
          ]
        }
      ]
    }
  ]
}