=== Fetching Proposal: Deprecated proposals ===
Issue URL: https://github.com/golang/go/issues/29824

==== [Issue Title] ====
proposal: x/tools: move cmd/internal/edit to a public package

==== [Issue Body] ====
`cmd/internal/edit` is incredibly useful when modifying code, particular as compared to manually constructing an AST for go/printer to print. That's not surprising; it is the reason that Russ wrote it. I have a half dozen copies of `cmd/internal/edit` floating around, so that I can use it tools that I write.

Given its general utility when writing tools, I propose that we move cmd/internal/edit to x/tools, and then vendor it back into core.


==== [Comments] ====

--- Comment #1 by mvdan ---
/cc @rogpeppe 

--- Comment #2 by josharian ---
Ping. I just made yet another copy of this package.

Who is the decision maker for this?

--- Comment #3 by thepudds ---
Hi @mvdan, I see you commented here earlier. Do you know who the decision maker is for this?

--- Comment #4 by mvdan ---
@rsc added the package and @ianlancetaylor approved it. This is used for cmd/cover, so I guess @bcmills could also make a decision here. I'm not sure.

--- Comment #5 by ianlancetaylor ---
I changed the milestone so that it will be looked at sooner rather than later.

--- Comment #6 by josharian ---
We just made yet another copy of this package. And I have a minor improvement I'd like to upstream. It'd be nice if we could move this to x/tools so I can send a CL, and then vendor it back in Go 1.19.

> I changed the milestone so that it will be looked at sooner rather than later.

Looks like that didn't work. :( The work here is minimal (code movement), and I'm happy to do it. I'm just looking for a green light.

--- Comment #7 by ianlancetaylor ---
What should we call the public package?  x/tools/edit?

--- Comment #8 by josharian ---
`x/tools/edit` works for me. The package name works well already (e.g. `edit.Buffer`), I don't see any obvious existing subdir to put it in, and I can't think of any obvious future subdir that it belongs to.

--- Comment #9 by findleyr ---
This package is small and useful. Adding it to x/tools makes sense to me.

--- Comment #10 by rsc ---
Why do you keep making new copies of this package instead of making one public copy, like rogpeppe did with txtar? :-)

I will take a look at the API and see whether I'm happy with it being exported.


--- Comment #11 by rsc ---

This proposal has been added to the [active column](https://golang.org/s/proposal-status#active) of the proposals project
and will now be reviewed at the weekly proposal review meetings.
— rsc for the proposal review group


--- Comment #12 by josharian ---
> Why do you keep making new copies of this package instead of making one public copy, like rogpeppe did with txtar? :-)

Honest answer: Because I believed that the request was trivial enough that it would be green-lighted quickly, and I didn't want to create a competing package.

--- Comment #13 by gopherbot ---
Change https://golang.org/cl/370880 mentions this issue: `edit: add new package for applying edits to byte streams`

--- Comment #14 by rsc ---
Looked over the API. 
It has some 'panic on usage mistake' that probably don't belong in a public package. 
I revised the API a bit and sent CL 370880. 

```
package edit // import "golang.org/x/tools/edit"

Package edit implements buffered position-based editing of byte slices.

TYPES

type Buffer struct {
	// Has unexported fields.
}
    A Buffer is a queue of edits to apply to a given byte slice. The queued
    edits must not overlap.

func NewBuffer(data []byte) *Buffer
    NewBuffer returns a new buffer to accumulate changes to an initial data
    slice. The returned buffer maintains a reference to the data, so the caller
    must ensure the data is not modified until after the Buffer is done being
    used.

func (b *Buffer) Apply() ([]byte, error)
    Apply returns a new byte slice containing the original data with the queued
    edits applied. It returns an error if any of the queued edits overlap or
    refer to invalid string positions.

func (b *Buffer) Delete(start, end int)

func (b *Buffer) Insert(pos int, new string)

func (b *Buffer) Replace(start, end int, new string)
```


--- Comment #15 by josharian ---
LGTM, Russ. Thanks.

Incidentally, the "minor improvement" I have been carrying around that I might attempt to upstream is https://github.com/josharian/go/commit/a9136127a812ecd97f378a49a544de0aed42acc2. It doesn't impact the API, and looks like it would apply obviously/cleanly to the new code.


--- Comment #16 by rsc ---
That change does seem reasonable. I originally used this package in rf, but it ended up wrapped in a more idiomatic API for that setting, with different ways to specify positions, and it ended up not pulling its weight. I worry just a little bit about that here too, but it won't bother anyone for it to exist. The other possible place for it would be bytes.Editor (arguably a nicer name), but it doesn't seem important enough for the standard library.

--- Comment #17 by rogpeppe ---
in passing, I'm sure it fitted the use case at the time, but it perhaps feels a bit odd that it's created with a byte slice and produces a byte slice but the operations are in terms of strings not byte slices.

--- Comment #18 by rsc ---
I agree about that []byte vs string issue, which is another concern I have. If you use []byte you have to say that the buffers can't be reused, or you have to say they can be and make copies yourself. 

It's also also somewhat concerning that when I went to use this code in rf I first wrapped it and then ended up replacing it entirely, because in a larger program the API I needed was sufficiently different that the code wasn't pulling its weight. It really is a fairly trivial loop when it comes down to it.



--- Comment #19 by rsc ---
I'm still a bit unsure that the API weight here is enough to be worth having in a public x/tools package.

@josharian, which flavor of the API were you looking for?


--- Comment #20 by josharian ---
Every context where I've used this, the performance go/types dwarfs the costs of string/[]byte conversions. I would be happy with either flavor of API.

I'm also happy to just hard fork the package. Whatev.


--- Comment #21 by rsc ---
My plan is to publish a copy under rsc.io.


--- Comment #22 by rsc ---

Based on the discussion above, this proposal seems like a **[likely decline](https://golang.org/s/proposal-status#likely-decline)**.
— rsc for the proposal review group


--- Comment #23 by rsc ---
Published https://pkg.go.dev/rsc.io/edit@v1.0.0.


--- Comment #24 by rsc ---

No change in consensus, so **[declined](https://golang.org/s/proposal-status#declined)**.
— rsc for the proposal review group

