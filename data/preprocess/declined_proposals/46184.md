=== Fetching Proposal: Poor feasibility ===
Issue URL: https://github.com/golang/go/issues/46184

==== [Issue Title] ====
proposal: syscall: ReleaseCallback for Windows

==== [Issue Body] ====
Now a callback generated by `syscall.NewCallback` or `syscall.NewCallbackCDecl` is never released based on the current implementation (especially `runtime/syscall_windows.go`).

My understanding is that it is hard or impossible to release them automatically. Would it be possible to have a function to release a callback like `ReleaseCallback`? Or, what about changing the return type of `NewCallback` to a new type `Callback` and letting it have `Release` function?

CC @mknyszek

==== [Comments] ====

--- Comment #1 by networkimprov ---
cc @alexbrainman @mattn @zx2c4 

@gopherbot add OS-Windows

--- Comment #2 by ianlancetaylor ---
What should happen if a released callback is called?

--- Comment #3 by hajimehoshi ---
Just panic, maybe? This should be the same situation as calling a released `syscall/js.Func`.

--- Comment #4 by alexbrainman ---
@hajimehoshi 

Why do you need new `syscall.ReleaseCallback` function? What would you be able to do that you cannot do now?

I don't see any use for `syscall.ReleaseCallback`.

Thank you.

Alex

--- Comment #5 by hajimehoshi ---
My understanding is that there is a limit for the number of the callbacks. If the number of calls of NewCallback reaches the limit, you can no longer create a new callback. Is that correct?

Or, at least, I'd want the documentation to make it explicit that a callback created by NewCallback is never released.

--- Comment #6 by hajimehoshi ---
Actual example is [`waveOutOpen`](https://docs.microsoft.com/en-us/windows/win32/api/mmeapi/nf-mmeapi-waveoutopen). This takes a callback each time when an audio stream is opened. If I didn't consider the limitation of `NewCallback(CDecl)`, I would run into the issue of the limitation. So, I wanted a function to release the callback so that I could release it the audio stream ends, or I wanted to know the limitation so that I could avoid the limitation by reusing the same callback.

--- Comment #7 by zx2c4 ---
You're best off having one global callback for that, and using the dwInstance field in order to index into a map of actual callbacks.

(Alternatively, that function takes an event handle instead.)

--- Comment #8 by mknyszek ---
I agree that `NewCallback` should document its limitations (I'll write up a CL for that soon if nobody beats me to it), but I think there are problems with something like `ReleaseCallback`. Like, if the callback is passed deep into a library, especially one that can trigger the callback asynchronously, the failure mode of releasing the callback without "de-registering" it is that either:
1. The slot is empty, and the callback attempts to jump to nil and crashes (that's fine), or
2. The slot is reused, and the callback calls into something totally unrelated.

(2) Is the case I'm worried about, because we can't really detect it and panic, at least not the way callbacks are implemented today. There might be some way to work around this, though. The limitation today stems from the fact that we identify the slot based on the return PC passed into `callbackasm1`, I'm not sure how else we can signal which callback we should use while still going down a single common path through the runtime to set up all the Go scheduler things that need to happen on the potentially external thread.

--- Comment #9 by alexbrainman ---
> Actual example is [`waveOutOpen`](https://docs.microsoft.com/en-us/windows/win32/api/mmeapi/nf-mmeapi-waveoutopen). This takes a callback each time when an audio stream is opened.

I would do what @zx2c4 suggested in https://github.com/golang/go/issues/46184#issuecomment-842245411. I think one callback function should be enough in your scenario.

I also share @ianlancetaylor (https://github.com/golang/go/issues/46184#issuecomment-841948580) and @mknyszek (https://github.com/golang/go/issues/46184#issuecomment-843286690) concerns. There is no general way to inform external code to stop calling your callback function before you release it. This will cause memory corruption and crashes. It is not worth the trouble.

Alex

--- Comment #10 by gopherbot ---
Change https://golang.org/cl/321133 mentions this issue: `syscall: document NewCallback and NewCallbackCDecl limitations`

--- Comment #11 by hajimehoshi ---
> There is no general way to inform external code to stop calling your callback function before you release it. This will cause memory corruption and crashes. It is not worth the trouble.

I think this is the same situation as `syscall/js.Func`'s `Release`, and if we had `ReleaseCallback`, using this should be the user's responsibility.

Based on https://github.com/golang/go/issues/46184#issuecomment-843286690, I'm now convinced that implementing `ReleaseCallback` would be difficult: calling a released callback cannot panic safely.

--- Comment #12 by rsc ---

This proposal has been added to the [active column](https://golang.org/s/proposal-status#active) of the proposals project
and will now be reviewed at the weekly proposal review meetings.
— rsc for the proposal review group


--- Comment #13 by rsc ---
> Based on #46184 (comment), I'm now convinced that implementing ReleaseCallback would be difficult: calling a released callback cannot panic safely.

So it sounds like we should not add ReleaseCallback then?


--- Comment #14 by hajimehoshi ---
I don't think we should not, but I'm not sure how feasible this would be. @mknyszek what do you think?

--- Comment #15 by rsc ---

Based on the discussion above, this proposal seems like a **[likely decline](https://golang.org/s/proposal-status#likely-decline)**.
— rsc for the proposal review group


--- Comment #16 by rsc ---

No change in consensus, so **[declined](https://golang.org/s/proposal-status#declined)**.
— rsc for the proposal review group

