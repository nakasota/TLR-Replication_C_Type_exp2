=== Fetching Proposal: Deprecated proposals ===
Issue URL: https://github.com/golang/go/issues/38193

==== [Issue Title] ====
proposal: errors: support returning a wrapped error without nil checks

==== [Issue Body] ====
I use github.com/pkg/errors, and it allows me to do:

    func f() error {
        return errors.Wrap(f2(), "f")
    }

errors.Wrap() will return nil if the error is nil, so this works as expected both in cases of errors and no errors. I use this pattern quite a lot in my code, since it removes the need for many err != nil checks.

I looked in to using the new (well, new-ish) error wrapping from the stdlib last week, but it's quite a lot more verbose:

    func f() error {
        err := f2()
        if err != nil {
            return fmt.Errorf("f: %w", err)
        }
        return nil
    }

In my own code, there are many cases where I'll have to replace a return errors.Wrap(err, "..") with err != nil checks. It seems to me that the errors.Wrap() method is quite a bit more ergonomic.

I think it's a useful enough pattern to investigate if it's worth supporting something like this in the standard library.

I'm not especially attached to the Wrap() function call as such â€“ it's just what currently being used by github.com/pkg/errors. Perhaps there is a better name for the function, or a better way to get the same effect. Either way, I think it might be worth investigate supporting returning errors without a nil check in some way.


==== [Comments] ====

--- Comment #1 by arp242 ---
For the time being, I just added this to my application by the way; but I'm not a huge fan of wrapping stdlib stuff as-such, and I miss it in various libraries where it's not available (and don't really want to add it to every library I write).

```go
// Package errors adds Wrap() and Wrapf() to stdlib's errors.
//
// This removes the need for quite a few if err != nil checks.
package errors

import (
    "errors"
    "fmt"
)

func New(text string) error                 { return errors.New(text) }
func Unwrap(err error) error                { return errors.Unwrap(err) }
func Is(err, target error) bool             { return errors.Is(err, target) }
func As(err error, target interface{}) bool { return errors.As(err, target) }

// Wrap an error with fmt.Errorf(), returning nil if err is nil.
func Wrap(err error, s string) error {
    if err == nil {
        return nil
    }
    return fmt.Errorf(s+": %w", err)
}

// Wrapf an error with fmt.Errorf(), returning nil if err is nil.
func Wrapf(err error, format string, a ...interface{}) error {
    if err == nil {
        return nil
    }
    return fmt.Errorf(format+": %w", append(a, err)...)
}
```


--- Comment #2 by rsc ---
It seems like this can be implemented very easily outside the standard library if that's the pattern you want (as you have). Personally, when I see an error constructor I expect it means there is a real (non-nil) error, not that it might be a success case sliding through.

We're taking a break from new error APIs for a while, to get a few years more experience with the recent changes. 

--- Comment #3 by arp242 ---
> We're taking a break from new error APIs for a while, to get a few years more experience with the recent changes.

Yeah, that sounds reasonable :+1: It's just a UX/convenience issue that I've run in to; I don't know if it's just me. Probably should checked this out sooner when it was still x/errors, but also been busy ðŸ˜…

--- Comment #4 by rsc ---
Based on the discussion above, this sounds like a **likely decline**.


--- Comment #5 by rsc ---
No change in consensus. Declined.

