=== Fetching Proposal: No consensus reached ===
Issue URL: https://github.com/golang/go/issues/44571

==== [Issue Title] ====
proposal: io: change Copy error to distinguish reader from writer

==== [Issue Body] ====
I encountered a need where different operation is performed based on the error from io.Copy is a read error or write error. 

Currently I can only guess the following:
1. ```err != nil && n > 0``` likely be a write error, but can be a successful write followed by a failed read
2. ```err != nil && n == 0``` can be either a failed read or failed write

It would be good such check as below is valid.
```go
_, err := io.Copy(dst, src)

if errors.Is(err, io.WriteError) {
  // do some stuff
} else if errors.Is(err, io.ReadError) {
  // do other stuff
}
```


I am happy to contribute is if this is nice  to have.

==== [Comments] ====

--- Comment #1 by davecheney ---
If you were able to determine that the reader, or the writer, was the cause of the error, what would that let you do?

--- Comment #2 by ianlancetaylor ---
Can you give an example of the case which you need to distinguish?  In many cases I would expect the error would be an `os.PathError`, so you could look at the `Path` field.

--- Comment #3 by rsc ---
At this point I'm not at all sure we can change the errors being returned here.

We could potentially provide Reader and Writer wrappers that remember errors so that you can check them after the call, but they'd have to forward ReadFrom etc checks, which would require other changes to Copy. 

--- Comment #4 by rsc ---

This proposal has been added to the [active column](https://golang.org/s/proposal-status#active) of the proposals project
and will now be reviewed at the weekly proposal review meetings.
— rsc for the proposal review group


--- Comment #5 by rockmenjack ---
> Can you give an example of the case which you need to distinguish? In many cases I would expect the error would be an `os.PathError`, so you could look at the `Path` field.

```
                    tcp svr           vsock
                    +-----+          +-----+
            <-------+     +<---------+     |  // io.Copy(tcp_conn, vsock_conn) call it copy1
some client         |     |          |     |
            ------->+     +--------->+     |  // io.Copy(vsock_conn, tcp_conn) call it copy2
                    +-----+          +-----+

                | -----my go program ----- |
```

Condiser below scenarios:

1. in ```copy1```, if client actively closed receive side, then it is a write error, so I won't close ```vsock_conn,```  because client may still sending in ```copy2```
2. in ```copy2```, for some reason, write to vsock_conn failed, still a write error, so I won't close ```tcp_conn```, as client may still receiving in ```copy1```
3. in both ```copy1``` and ```copy2```, if it is a read error, I just close the connections.




--- Comment #6 by rockmenjack ---
> At this point I'm not at all sure we can change the errors being returned here.
> 
> We could potentially provide Reader and Writer wrappers that remember errors so that you can check them after the call, but they'd have to forward ReadFrom etc checks, which would require other changes to Copy.

Is it feasible to change in below way?
```go
type ErrWrite struct{ err error }
func (e ErrWrite) Unwrap() error {return e.err}
type ErrRead struct{ err error }
func (e ErrRead) Unwrap() error {return e.err}

// ...  code snippets from copyBuffer
		nr, er := src.Read(buf)
		if nr > 0 {
			nw, ew := dst.Write(buf[0:nr])
			if nw < 0 || nr < nw {
				nw = 0
				if ew == nil {
					ew = ErrWrite{errInvalidWrite} // wrap
				}
			}
			written += int64(nw)
			if ew != nil {
				err = ErrWrite{ew} // wrap
				break
			}
			if nr != nw {
				err = ErrWrite{ErrShortWrite} // wrap
				break
			}
		}
		if er != nil {
			if er != EOF {
				err = ErrRead{er} // wrap
			}
			break
		}
	}
// ...
```



--- Comment #7 by rsc ---
This seems like something that does not come up a lot. It is also specific to io.Copy.
However, the more general problem of "was the failure due to I/O or something else" comes up more often.
For example https://go.googlesource.com/tools/+/refs/heads/master/godoc/server.go#512 has an error-saving writer wrapper so that it can tell whether a template execution failed due to a real template problem or a (not very important) I/O problem writing to an HTTP client.
If we provided general error-saving wrappers for Reader and Writer then that could be more useful.
And then when you wanted to answer the question for Copy, you'd just add one or both.

We just need names for the wrappers. I wrote one of these a few weeks ago and called it a WriteErrorSaver, which I'm not wild about. Any better, shorter names?



--- Comment #8 by rsc ---
OK, in the absence of better names, it sounds like the proposal is

```
type WriteErrorSaver struct { W io.Writer; Err error }
func (w *WriteErrorSaver) Write(b []byte) (int, error) {
    n, err := w.W.Write(b)
    if err != nil {
        w.Err = err
    }
    return n, err
}
```

and similarly for Read. This has the property of breaking the io.Copy optimizations for ReadFrom and WriteTo.
(I suppose io.Copy could special case this implementation.)

Thoughts?




--- Comment #9 by kortschak ---
Given the impact on the optimisations, the size of the code required, and the frequency of need; would it not be better to have this as an example showing how specific `io.Reader`/`io.Writer` error capture can be implemented?

--- Comment #10 by rockmenjack ---
> (I suppose io.Copy could special case this implementation.)

In this way we can still have the optimizations.


--- Comment #11 by rsc ---
People can write the wrappers I listed above themselves. There's no clear reason they must be in the standard library. 
Given the lack of enthusiasm here, it sounds like maybe we shouldn't make any changes.


--- Comment #12 by rockmenjack ---
Maybe just append some guide in the doca?

--- Comment #13 by rsc ---

Based on the discussion above, this proposal seems like a **[likely decline](https://golang.org/s/proposal-status#likely-decline)**.
— rsc for the proposal review group


--- Comment #14 by rsc ---

No change in consensus, so **[declined](https://golang.org/s/proposal-status#declined)**.
— rsc for the proposal review group

