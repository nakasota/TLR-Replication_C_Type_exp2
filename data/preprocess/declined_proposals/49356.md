=== Fetching Proposal: Poor feasibility ===
Issue URL: https://github.com/golang/go/issues/49356

==== [Issue Title] ====
proposal: x/tools/go/analysis/passes/errorstringcompare: new check that warns when programmers compare against Error() strings

==== [Issue Body] ====
## Problem

On GitHub, there are too many projects that strictly compare error strings outside of test code: [`.Error() == "..."](https://sourcegraph.com/search?q=context:global+timeout:1m+lang:go+-file:_test.go%24+-file:%5Evendor/+.Error%28%29+%3D%3D+%22...%22&patternType=structural)

[Go 1 and the Future of Go Programs](https://golang.org/doc/go1compat) does not explicitly promise that error strings are protected, nor do we want to encourage this amongst third-party libraries. See @neild’s https://github.com/golang/go/issues/49172#issuecomment-954071349.

## Proposed Implementation

Now that error wrapping was introduced in [Working with Errors in Go 1.13 - go.dev](https://go.dev/blog/go1.13-errors), we should encourage developers to use [errors.Is](https://pkg.go.dev/errors#Is) and [errors.As](https://pkg.go.dev/errors#As) whenever possible.

Linting is one way of providing this hint. I propose writing an optional analysis pass that detects when errors strings are compared for equality, substrings, or with regular expressions. This analysis pass _should not_ be incorporated into go vet, because any reported errors are not guaranteed to be bugs.

1. Add x/tools/go/analysis/passes/errorstringcompare that implements the following Analysis.Doc string:
   ``` go
   const Doc = `report code that compares error strings when alternatives exist
   
   The errorstringcompare analysis reports when code compares error strings,
   when the underlying error supports the errors.Is interface.
   
   Examples of such comparisons include:
   
   	if err.Error() == "..." { }
   	if err.Error()[i:j] == "..." { }
   	if err.Error()[i] == '.' { }
   	if strings.Contains(err.Error(), "...") { }
   	if strings.HasPrefix(err.Error(), "...") { }
   	if strings.HasSuffix(err.Error(), "...") { }
   	if re.MatchString(err.Error()) { }
   	if re.FindString(err.Error()) != "" { }
   
   The -ignorepkgs flag specifies a comma-separated list of packages which
   will be ignored by the analysis.
   `
   ```
   **Proposed algorithm:**
   1. Find error string comparisons in the current package, where the Error method is compared against another string. If the developer has assigned the error string to a variable or used fmt.Sprintf, assume they know what they’re doing.
   2. For each of the errors that had their Error method called, try to determine the underlying type:
      1. Determine if the error was directly initialized, or created by concrete type assertion, and record its actual sum type. Errors wrapped with fmt.Errorf can be handled in this step.
      2. Determine if the error was the result of a static function call, and add it to the list of errors to inspect.
      3. If the type of the error is indeterminate, drop the error from the analysis, since we want to avoid false positives.
   3. After resolving the sum type for each error, keep the errors that can only be exported error sentinels or that implement the errors.Is interface. The Is method implies that there are exported error sentinels to check against.
   4. Report these remaining errors with a message like `fmt.Sprintf("prefer using errors.Is for %s", err.Name())`.

2. Add this to [gopls Analyzers](https://github.com/golang/tools/blob/master/gopls/doc/analyzers.md), after deciding whether to enable it by default.

3. Encourage metalinters like [golangci-lint](https://github.com/golangci/golangci-lint) to add this to their corpus of checks.

## Concerns

- Some of these warnings might be encounter too many false positives. We should run errorstringcompare against a representative corpus of Go code to see how noisy it would be.
- Some packages may have tests that actually do promise backwards-compatibility for their APIs, which is why the -ignorepkgs flag exists.

## See also

- #49358 which can catch more edge cases if they are covered by tests.

==== [Comments] ====

--- Comment #1 by dgryski ---
This is easy to accomplish outside of the `vet` framework.

Here's are examples of checks for existing tools that could easily be generalized:

* semgrep: https://github.com/dgryski/semgrep-go/blob/master/errclosed.yml
* ruleguard: https://github.com/dgryski/semgrep-go/blob/master/ruleguard.rules.go#L358

--- Comment #2 by guodongli-google ---
I agree that it is not uncommon that existing code uses string comparison to check errors such as
```
if err.Error() == "..." { }
```
and
```
case strings.Contains(err.Error(), "err: ..."): ...
case strings.Contains(err.Error(), "err: ..."): ...
```
However it is valid to perform such comparisons although using the newer features `errors.Is` and `errors.As` is better.    This check is certainly useful, but vet is not the right place for it due to vet's strict FP requirement. 
If we have data to show that these old patterns are actually error-prone, e.g. `strings.Contains(err.Error(), "err: xxx")` may mess up the comparison since there are multiple `err: xxx` in the error string, then developing a vet checker makes more sense.

--- Comment #3 by sfllaw ---
> This is easy to accomplish outside of the `vet` framework.

@dgryski The point of this proposal, and related proposals, is to explore how strongly we want to discourage comparing error strings. This analysis pass would be the point on the spectrum where tooling that understands the standard analysis framework (_e.g._ gopls, golangci-lint, GoLand, _etc._) are easily able to enable this check.

That’s not to discount the work of ruleguard or semgrep. I think that your errclosed check is good evidence that the problem exists. Perhaps we should be more emphatic by moving the check into the golang.org/x ecosystem?

> This check is certainly useful, but vet is not the right place for it due to vet's strict FP requirement.

@guodongli-google This proposal explicitly mentions that it should not be enabled for go vet, since an error string match might not actually be a bug with a given set of dependencies, and we don’t want to overwhelm developers with spurious errors.

Note that errstringcompare is very similar to [deepequalerrors](https://pkg.go.dev/golang.org/x/tools@v0.1.7/go/analysis/passes/deepequalerrors), which is also an analysis pass that isn’t enabled for go vet, but is widely used to warn about a similar footgun. In deepequalerrors’s case, it is about comparing the error value itself.

--- Comment #4 by timothy-king ---
If this is not enabled in `go vet`, there is a question of whether such an Analyzer should be in golang.org/x/tools/go/analysis/passes. Is something else in golang.org/x going to use this? (gopls?) If none of the tools the Go team distributes uses this, I think it makes more sense for another repo to host and maintain such an Analyzer.

--- Comment #5 by guodongli-google ---
It looks like we all agree that this is a valuable checker, esp. considering its predecessor is the deepequalerrors checker (see https://github.com/golang/lint/issues/232, which actually recommends "checking whether a substring is present in the error message".
I think that it is OK to activate this checker for new written code to encourage using `.As()` and `.Is()`, but enforcing it on existing code may be annoying since many tests use string comparisons and they actually work fine. If it goes into vet, then it can be an optional checker that is disabled by default.


--- Comment #6 by sfllaw ---
> Is something else in golang.org/x going to use this? (gopls?)

@timothy-king We should definitely integrate this into [gopls Analyzers](https://github.com/golang/tools/blob/master/gopls/doc/analyzers.md), if we want to discourage people from this anti-pattern.

Whether to enable this by default, like we do for deepequalerrors, is something I don’t have a strong opinion about. I’m guessing that I’ll have a stronger opinion after I implement it and see how it behaves against actual Go code. It looks like gopls has a more relaxed policy than go vet. Gopls seems to have analysis checkers enabled by default as long as the number of false positives remains low.

--- Comment #7 by timothy-king ---
> If it goes into vet, then it can be an optional checker that is disabled by default.

IIRC disabled by default checkers are not a feature of cmd/vet today. (Running a different default subset within `go test` is a different matter.) I recommend a different proposal if folks want this feature.

--- Comment #8 by sfllaw ---
> > If it goes into vet, then it can be an optional checker that is disabled by default.
> 
> IIRC disabled by default checkers are not a feature of cmd/vet today. (Running a different default subset within `go test` is a different matter.) I recommend a different proposal if folks want this feature.

@timothy-king You are correct, go vet either knows about a checker or it doesn’t. This proposal explicitly calls out that this analysis pass doesn’t belong there.

--- Comment #9 by rsc ---
> The point of this proposal, and related proposals, is to explore how strongly we want to discourage comparing error strings.

For me at least it seems like the answer is not particularly strongly.

> We should definitely integrate this into gopls Analyzers, if we want to discourage people from this anti-pattern.

Again, I'm not convinced this is something we should add to gopls and warn users about. It is not nearly at the correctness level that we usually strive for. There will be many of these, users will learn to ignore them, and then they will start ignoring _other_ more precise reports.



--- Comment #10 by rsc ---

This proposal has been added to the [active column](https://golang.org/s/proposal-status#active) of the proposals project
and will now be reviewed at the weekly proposal review meetings.
— rsc for the proposal review group


--- Comment #11 by dottedmag ---
I have checked one middle-sized (200K lines of Go code) codebase, and has found the following:

16 uses of `err.Error() == "..."` and `string.Contains(err.Error(), ...)`.

Two checks are against errors returned by standard library, to distinguish `errServerMisbehaving` https://github.com/golang/go/blob/master/src/net/dnsclient_unix.go#L39 from other DNS errors.

Other checks are against errors in third-party libraries that are quite large, break often and do not bring any particular benefits being up-to-date, so updating them is aways a chore.

If this rule is introduced to `go vet`, then we'll have to unconditionally turn it off and probably leave it disabled, because even when these libraries catch up it probably won't pay off to upgrade them just to make the linter happy.

--- Comment #12 by sfllaw ---
> Again, I'm not convinced this is something we should add to gopls and warn users about. It is not nearly at the correctness level that we usually strive for. There will be many of these, users will learn to ignore them, and then they will start ignoring other more precise reports.

@rsc I wonder if this analyzer could be more precise, where it could detect that there is an exported error sentinel, either bare or wrapped, that would be better handled with errors.Is? I have updated the proposal with a potential algorithm.

> I have checked one middle-sized (200K lines of Go code) codebase, and has found the following:
> 
> 16 uses of `err.Error() == "..."` and `string.Contains(err.Error(), ...)`.
> 
> Two checks are against errors returned by standard library, to distinguish `errServerMisbehaving` https://github.com/golang/go/blob/master/src/net/dnsclient_unix.go#L39 from other DNS errors.

@dottedmag This is excellent data. I can see why you would do this, since (*net).DNSError doesn’t export platform-specific errors and also predates error wrapping. 

> Other checks are against errors in third-party libraries that are quite large, break often and do not bring any particular benefits being up-to-date, so updating them is aways a chore.

@dottedmag Do those third-party libraries also return opaque errors?

> If this rule is introduced to go vet, then we'll have to unconditionally turn it off and probably leave it disabled, because even when these libraries catch up it probably won't pay off to upgrade them just to make the linter happy.

@dottedmag This _would not_ be introduced to go vet.

--- Comment #13 by dottedmag ---
> Do those third-party libraries also return opaque errors?

@sfllaw Yes, a mix of `return fmt.Errorf("....")` and `/* package-level declaration */ var errSomething = errors.New("..."); ..... /* in function */ return errSomething`.


--- Comment #14 by sfllaw ---
> > Do those third-party libraries also return opaque errors?
> 
> @sfllaw Yes, a mix of `return fmt.Errorf("....")` and `/* package-level declaration */ var errSomething = errors.New("..."); ..... /* in function */ return errSomething`.

@dottedmag After our discussion, I have revised this proposal to only report problems when the error value is an exported error sentinel or supports the errors.Is interface by implementing the Is method. Do you think that would be a reasonable gopls warning? If there were existing code that could take advantage of this, would you be inclined to ignore the warning in your editor?

This also reminds me of the noCopy convention, https://github.com/golang/go/issues/8005#issuecomment-190753527, which is used in the [copylock](https://pkg.go.dev/golang.org/x/tools@v0.1.7/go/analysis/passes/copylock) checker.

--- Comment #15 by dottedmag ---
@sfllaw We already look for this during code review: every instance of string comparison I have found carries a comment explaining why `.Is`/`.As` can't be used there.

So it will be a welcome hint.

Moreover, revised rule will be useful for us as a linter check too.


--- Comment #16 by guodongli-google ---
Adding this revised version of the checker into **gopls** will be a little better than into **vet** since a user can get this hint/advice during editing. Refactoring the existing code, as discussed above, may be cumbersome. Also, this checker shall ignore the test packages. Using string comparisons is sometimes handy to write unit tests. 

Fundamentally, "deepequalerrors" and this proposed checker address the pointer/value comparison issue. String comparison is a way to compare the values of two errors, and is often valid by avoiding the pointer comparison pitfall.  "deepequalerrors" is error-prone because any minor update on the error message will break the comparison. For the same reason using `==` is also bad:
```
if err.Error() == "..."
```
In contrast, `strings.Contains` is better since it is less likely to break.

For package-level declaration, I think that a direct pointer comparison can be used:
```
var errSomething = errors.New("...");
if err == errSomething {
  ...
}
```
So this isn't a clear pattern for the best-practice.

--- Comment #17 by sfllaw ---
> Also, this checker shall ignore the test packages. Using string comparisons is sometimes handy to write unit tests.

@guodongli-google I think it might be best if we don’t ignore test packages, especially since they can contain examples. Looking at a large codebase I have access to, it looks like our code has very few string comparisons in their tests, none of which are equality (`==`). But even then, it should be easy to work around this by not doing a direct comparison, especially in table-driven tests:

``` go
_, err := os.Open("file.txt") // err is actually an *fs.PathError

wantErr := "open file.txt: no such file or directory"
if err != nil && err.Error() != wantErr { // warning because an *fs.PathError can be unwrapped
	t.Fatalf("err %v, want %s", pathErr, wantErr)
}

if err != nil && string(err.Error()) != wantErr { // suppress the warning
	t.Fatalf("err %s, want %s", gotErr, wantErr)
}

// ErrString is a really common helper, because errors can be nil.
func ErrString(err error) string {
	if err == nil {
		return ""
	}
	return err.Error()
}
if ErrString(err) != wantErr { // also suppress the warning
	t.Fatalf("err %v, want %s", err, wantErr)
}
```

> So this isn't a clear pattern for the best-practice.

I’m pretty sure that if an error exposes an Is method to implement the errors.Is interface, it’s asking you to use it. That is what this proposed checker will implement. If the error is opaque, or otherwise indeterminate, then the checker will not warn.

--- Comment #18 by zpavlinovic ---
@findleyr @hyangah Would gopls benefit from such a checker?

--- Comment #19 by hyangah ---
I think it's a great candidate for organization and project's custom linter - unfortunately, `gopls` doesn't support a custom linter. Moreover, `gopls` does not provide much flexibility in tuning an individual analyzer (like `-ignorepkgs` per analyzer) beyond completely turning it on/off. Can popular checkers with more flexible customization options (e.g., `staticcheck` or `golangci-lint`) be a better place? 

@findleyr does `gopls` have criteria for adding analyzers? Even though `gopls` is less strict than `vet`, we still need to think about long-term maintenance cost and benefit for Go users.

Comparing against the Error() string is not the best practice, but _personally_ I don't feel strongly about enforcing it widely because I think whether a package provides stability guarantee on their Error return values and employs a policy like Go 1 compatibility guarantee is up to the package owners.  But people with more experience in this domain have different thoughts.


--- Comment #20 by rsc ---

Based on the discussion above, this proposal seems like a **[likely decline](https://golang.org/s/proposal-status#likely-decline)**.
— rsc for the proposal review group


--- Comment #21 by sfllaw ---
@rsc Is this a likely decline even though the proposal has been narrowed to only errors that indicate they shouldn’t be compared by error string, because they support the errors.Is interface? I believe that this addresses the concerns raised about false positives and correctness.

--- Comment #22 by timothy-king ---
@sfllaw I'm not proposal review group. But I will point out that the current proposal is proposed to not go into vet and there is push back on gopls being a good fit. So that seems to eliminate tools the Go team distributes. As I mentioned in https://github.com/golang/go/issues/49356#issuecomment-964341142, it is not clear to me why golang.org/x/tools/go/analysis/passes is a good place for this logic to live if it is not going to eventually be used by some tool the team distributes.

--- Comment #23 by findleyr ---
> @findleyr does gopls have criteria for adding analyzers? Even though gopls is less strict than vet, we still need to think about long-term maintenance cost and benefit for Go users.

Thanks @hyangah, and sorry for my latency. We don't have a published criteria for adding analyzers, but should. I agree that analyzers added to gopls need to be carefully considered.  Any analyzer that is enabled by default must have a low rate of false positives -- not as low as cmd/vet, but still low enough that diagnostics are not distracting.  This generally rules out many analyzers that would produce false positives on pre-existing code, even though coding style or language features have evolved.  While a diagnostic may not be as disruptive as a vet failure, it is still takes valuable attention from the developer.

For disabled-by-default analyzers we are again more tolerant of false positives, but they also impact fewer users.  Every analyzer, including those that are disabled by default, carries with it a maintenance burden. Disabled analyzers have to be relatively _more_ valuable in order to offset this cost. (note that this heuristic might not hold for some of the analyzers we currently have; we have been more lax in the past).

While I agree that the proposed `errorstringcompare` analyzer could be useful, I think it is probably too noisy to be on-by-default in gopls, and not useful enough to be off-by-default. It seems like the type of analysis that would be most useful either (1) within an organization, or (2) run as a one-off from the command line or in CI.  In neither of those workflows does the analyzer need to be distributed with gopls.  In the future gopls may do a better job of integrating with those workflows, by making it easier to compile-in custom analyzers, and by allowing triggering "noisy" analysis on a path or range as a one-off.

--- Comment #24 by sfllaw ---
I guess I’m really not understanding how the proposed implementation will have a lot of false positives? Are we concerned that an error type will become unwrappable and cause gopls to start warning about error string comparisons because the API was extended? As a library author, I’d hope that people would adopt better error handling, if I introduced it.

Maybe the next step is to write the analyzer and see whether it produces as many false positives as we’re worried about? Is that the primary objection, or is there a more fundamental problem with coercing developers down a particular style of error handling?

@rsc, if you think that more research would help decide this proposal, then feel free to change this status to [**hold**](https://github.com/golang/proposal#hold) while I write a prototype.

--- Comment #25 by findleyr ---
> I guess I’m really not understanding how the proposed implementation will have a lot of false positives?

The algorithm in https://github.com/golang/go/issues/49356#issue-1045033681 does look like it eliminates many of the "unfixable" edge cases. I suspect many of the proposed heuristics would be difficult to implement in practice, though @timothy-king, @guodongli-google, and @zpavlinovic would know better.

Assuming that it is possible to eliminate false or unactionable positives, the question then becomes: how strongly do we want to discourage what remains? Per https://github.com/golang/go/issues/49356#issuecomment-965818016, perhaps not that strongly.  When weighed against the complexity of the proposed heuristics, I am disinclined to want to support this in gopls.

> As a library author, I’d hope that people would adopt better error handling, if I introduced it.

Past history, such as with golint, has shown that opinionated linters tend to get turned off. If the diagnostic is not highlighting a bug _that you should fix right now_, it will often be unactionable due to disagreement with its findings, not wanting to touch legacy code, or not owning the code that has the diagnostic. Unactionable diagnostics negatively affect the value of diagnostics as a whole. I am not 100% convinced that would be the case here, but I suspect it could be so.

An exception to this (IMO) is when the diagnostic is highlighting a coding style that is explicitly disallowed by an organization, or when the user is intentionally asking for "noisy diagnostics" to search for bugs.

> Maybe the next step is to write the analyzer and see whether it produces as many false positives as we’re worried about?

You are of course free to do this, and more information would be interesting, but I would caution that the heuristics from vet still apply to gopls (though to a lesser degree): the analyzer must find real bugs, with a low false positive rate, and true positives must be frequent.  Even if false positives are eliminated, the rate of real bugs must be high enough to justify supporting the analyzer.

If you decide to work on this, I think we should just move this issue out of the proposal queue. If we decide to add this analyzer to gopls (in `internal/lsp/analysis`), it doesn't need to go through the proposal process.

--- Comment #26 by rsc ---
FWIW I am not at all convinced that implementing errors.Is means you shouldn't use string compare in tests. Those two are orthogonal things.


--- Comment #27 by rsc ---

No change in consensus, so **[declined](https://golang.org/s/proposal-status#declined)**.
— rsc for the proposal review group

