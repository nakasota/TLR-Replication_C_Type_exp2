=== Fetching Proposal: Poor feasibility ===
Issue URL: https://github.com/golang/go/issues/39357

==== [Issue Title] ====
proposal: encoding/xml: Unmarshal comment with tag

==== [Issue Body] ====
### What did you do?

```xml
<mapper namespace="TEST">

  <!-- Multi-table -->
  <select id="MULTI" parameterType="java.util.Map" resultType="Map">
    SELECT * FROM information_schema.COLUMNS, COLUMNS, ${schema}.TABLES
  </select>

  <!-- Join -->
  <select id="JOIN" parameterType="java.util.Map" resultType="Map">
    SELECT * FROM information_schema.COLUMNS JOIN TABLES
  </select>
<mapper namespace="TEST">
```

```go
type (
	Mapper struct {
		XMLName   xml.Name
		Namespace string `xml:"namespace,attr"`
		Select    []sql  `xml:"select"`
		Insert    []sql  `xml:"insert"`
		Update    []sql  `xml:"update"`
		Delete    []sql  `xml:"delete"`
	}

	sql struct {
		Comment string `xml:",comment"`
		Id      string `xml:"id,attr"`
		SQL     string `xml:",innerxml"`
	}
)

func test(path string)  {
	model := Mapper{}
	xml.Unmarshal(util.ReadByte(path), &model)
}
```

### What did you expect to see?

```
Mapper.Select[0].Comment == "Multi-table"
Mapper.Select[1].Comment == "Join"
```

if
```go
	Mapper struct {
		XMLName   xml.Name
		Namespace string `xml:"namespace,attr"`
		Comment []string `xml:"select,comment"`
		Select    []sql  `xml:"select"`
		Insert    []sql  `xml:"insert"`
		Update    []sql  `xml:"update"`
		Delete    []sql  `xml:"delete"`
	}
```
then
```
Mapper.Comment[0] == "Multi-table"
Mapper.Comment[1] == "Join"
```

### What did you see instead?

```
Mapper.Select[0].Comment == ""
Mapper.Select[1].Comment == ""
```

if
```go
	Mapper struct {
		XMLName   xml.Name
		Namespace string `xml:"namespace,attr"`
		Comment string `xml:",comment"`
		Select    []sql  `xml:"select"`
		Insert    []sql  `xml:"insert"`
		Update    []sql  `xml:"update"`
		Delete    []sql  `xml:"delete"`
	}
```
then
```
Mapper.Comment  == "Multi-table Join"
```

==== [Comments] ====

--- Comment #1 by rsc ---
I understand this request to be asking for a way to collect comment text in XML unmarshaling, same as the ability to collect inner CDATA text. That's interesting but I am not sure whether we should go down that road. If there is any data structure to unmarshal in the XML, it seems like it should be in non-comment form. 

It would be especially problematic to have to attach comments to the XML elements that _follow_ them, as in the example (`<!-- Multi-table -->` and `<!-- Join -->` are in the same overall XML element but are being attached to sibling elements instead of the parent!). I don't think this is tenable for encoding/xml to take on.

Note that using xml.Token it is possible to read the data stream and do whatever you like. If you know that there is a stream of comment/object/comment/object/... then you can use an xml.Decoder to use Decode.Token to get the comment, then Decoder.Decode to get the object, and repeat.

--- Comment #2 by rsc ---

This proposal has been added to the [active column](https://golang.org/s/proposal-status#active) of the proposals project
and will now be reviewed at the weekly proposal review meetings.
‚Äî rsc for the proposal review group


--- Comment #3 by rsc ---

Based on the discussion above, this proposal seems like a **[likely decline](https://golang.org/s/proposal-status#likely-decline)**.
‚Äî rsc for the proposal review group


--- Comment #4 by LinWanCen ---
There may not be other languages ‚Äã‚Äãthat support parsing comments. Golang is the only one I know, but connecting comments together is not very practical.  

Developers can do it through complex coding, but this is a bit difficult for ordinary people. 

 I think this way of parsing is similar to parsing documentation comments on functions, which is very elegant and practical.

--- Comment #5 by LinWanCen ---
> Â¶ÇÊûúÂú® XML ‰∏≠Êúâ‰ªª‰ΩïË¶ÅËß£ÁªÑÁöÑÊï∞ÊçÆÁªìÊûÑÔºåÂÆÉ‰ºº‰πéÂ∫îËØ•ÊòØÈùûÊ≥®ÈáäÂΩ¢Âºè„ÄÇ

This is indeed the case. My demand actually comes from parsing the stock code written by others in a large project. They use this kind of annotation method to describe the service configuration. I need to find all the services and bring an annotation explanation. I started  I didn't have time to study how to write it. In order to realize it quickly, regular expressions were used at the time, but it was quite complicatedüòÑ.
I very much hope that this problem can be solved simply and without bugs.

--- Comment #6 by rsc ---

No change in consensus, so **[declined](https://golang.org/s/proposal-status#declined)**.
‚Äî rsc for the proposal review group

