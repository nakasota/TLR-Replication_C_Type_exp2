==== [Issue Title] ====
cmd/go: remove -buildmode=shared (not c-shared)

==== [Issue Body] ====
-buildmode=shared has been broken since modules, and it is apparently unused.
See https://github.com/golang/go/issues/47257#issuecomment-897243256.
Let's remove it.


==== [Comments] ====

--- Comment #1 by rsc ---

This proposal has been added to the [active column](https://golang.org/s/proposal-status#active) of the proposals project
and will now be reviewed at the weekly proposal review meetings.
â€” rsc for the proposal review group


--- Comment #2 by electricface ---
I really want to use this buildmode=shared mode. 

--- Comment #3 by scott-cotton ---
@rsc how has it been broken since modules?



--- Comment #4 by ainar-g ---
Just to clarify, this is **not** related to `--buildmode=plugin`, right?

--- Comment #5 by ianlancetaylor ---
@electricface Why do you want to use it?  Are you using it today?

@scott-cotton You can't use `-buildmode=shared` with a module and then use `-linkshared` to link against it from other modules.  The whole idea of `-buildmode=shared` doesn't fit very well with modules.  Each separate program can be linked against different versions of dependent modules, so if it did work people would in practice wind up with many different versions of the shared libraries of the same modules.

@ainar-g Correct, this is not about `-buildmode=plugin`, although plugins have their own, different, problems.

--- Comment #6 by electricface ---
@ianlancetaylor 
I am a debian-baseed Linux Desktop Environment developer. Our team have developed lot of daemon programs with golang. But these programs have significantly larger binary file size and use more ram than C or C++ programs. We currently working on these two problems. An idea is making some modules pluggable, which means only load modules that we need.

As other C or C++ programs are using shared-library, we are researching on some shared-library-like mechanism of golang. Inspired by `buildmode=plugin` and [goloader](https://github.com/pkujhd/goloader), we found a way that bases on `buildmode=shared` to make modules pluggable recently, you can found a demo [here](https://github.com/electricface/eleplugin). This solution has not been using in production environment, because of some problems hasn't been solved yet. I found out that programs built with `-linkeshared` can not be debugged using gdb and dlv.

After [this commit](https://github.com/golang/go/commit/73268bec86787cb8061baf9ab6f0fee3da1be7a4), our "unoffical plugin" solution can work fine with go 1.14.9~1.16.7. Programs built in this way can run stably. But this won't work on go 1.17. Program will exit with a "fatal error: unreachable method called. linker bug?"

Plan of remove `buildmode=shared` make me feel bad.

--- Comment #7 by ianlancetaylor ---
@electricface It sounds like you want plugins, which are supported (though not very well) by `-buildmode=plugin`.  We aren't going to support `-buildmode=shared` just to support plugins, since we already have `-buildmode=plugin`.

--- Comment #8 by electricface ---
@ianlancetaylor
I know that using static linking can eliminate the problems caused by the mismatched version of the dependent dynamic library.
But in the linux desktop system ecosystem, C or C++ languages are mostly used. These languages generally use dynamic libraries to save memory. The main reason for not using `-buildmode=plugin` is that static linking cannot save memory. For example, if the modules are divided into smaller ones and a lot of modules are added, each module occupies a relatively large amount of memory, and the overall occupancy will eventually become unacceptably large. Compared with C or C++ languages, they only use less memory to implement these functions, while the golang implementation uses several times the memory.
There is even an idea in our team that we must change the development language if we can't reduce the memory. I personally like to use golang for development, so I plan to study this part of the technology.

--- Comment #9 by rsc ---
"I want to use it" is different from "I am using it today".
We believe that it is not possible to use it today, and furthermore it is difficult to provide.
We shouldn't advertise something that doesn't actually work.


--- Comment #10 by rsc ---

Based on the discussion above, this proposal seems like a **[likely accept](https://golang.org/s/proposal-status#likely-accept)**.
â€” rsc for the proposal review group


--- Comment #11 by mewmew ---
Just to confirm, this proposal suggests to remove `--buildmode=shared` while keeping `--buildmode=c-shared`? I am using `--buildmode=c-shared` for a number of projects and would be very sad to see it go.

--- Comment #12 by ianlancetaylor ---
This proposal is only about `-buildmode=shared`.

--- Comment #13 by rsc ---

No change in consensus, so **[accepted](https://golang.org/s/proposal-status#accepted)**. ðŸŽ‰
This issue now tracks the work of implementing the proposal.
â€” rsc for the proposal review group


--- Comment #14 by rasky ---
@rsc not sure if this is a good place to give feedback about the proposal process, but this is the first time (since the proposal process exists) that I missed an issue. I was mildly interested in this (not enough now to vehemently protest), but even if I'm subscribed to the proposal process issue and I normally read minutes every week, I missed this. I took 10 days off for vacation, and those 10 days covered the only 2 emails where this issue was mentioned, before today when it was approved. Again, I don't mind about this specific issue at this point but I wanted to raise a general point.

Maybe a proposal should stay a minimum time in the proposal process before being closed, so that even people that don't work on Go full time have time to notice and react even with personal life happening in-between.

--- Comment #15 by zhouguangyuan0718 ---
To limit binary file size, I use command `go install -buildmode=shared std` to install libstd.so. And I build my application by `go build -linkshared`. I have been using this in  production environment for a long time. I hope I can still use it in the furture.
Can we keep ` -buildmode=shared std`, it's useful.


--- Comment #16 by Jason7602 ---
Our company has been using the `shared` mode to reduce the binary size for a long time. The `plugin` mode is not useful in some scenarios cause the entire `runtime package` needs to be compiled and packed. So we strongly hope that `shared` mode can be reserved.

--- Comment #17 by mlaventure ---
We also use `buildmode=shared` to reduce binary size / allow pages to be shared across several binaries using a common set of packages when running in on devices with (relatively) low RAM. Hopefully a solution can be found to make this viable with modules, but I'd prefer for the option to not disappear. Without this, we would have to resort to a `busybox` like binary which is not ideal as each binary is maintained by a different set of people and released independently.


--- Comment #18 by gopherbot ---
Change https://golang.org/cl/359096 mentions this issue: `cmd/go: remove support for -buildmode=shared`

--- Comment #19 by grolfcry ---
It's very strange decision to remove shared completely. I think shared or plugin mode was not well designed and now, we can't  use golang with something like java jars.


--- Comment #20 by ianlancetaylor ---
@grolfcry Note that `go build -buildmode=c-shared` still works.  I don't see how `-buildmode=shared` is related to Java jars.

--- Comment #21 by grolfcry ---
How I can build go dependencies  as external libs now if I cant build shared libs and link shared? Java jars relate go shared libs and java fat jar like default go build (one executable).

--- Comment #22 by ianlancetaylor ---
So, just to be clear, you are mentioning Java jars as an analogy?  You're not literally trying to use Go with Java jars?

Yes, this is functionality that will no longer be available.  But it already didn't work for anything other than the standard library.  Perhaps we can introduce some similar functionality in a way that can actually work, but it won't be `go build -buildmode=shared`.

--- Comment #23 by grolfcry ---
Of course, java jars it's analogy.
I can use any go module (any lib) as external dependency with shared mode and link shared, not only for standard modules in golang earlier 1.16 -  https://github.com/golang/go/issues/47455#issuecomment-942648877.
Now it's impossible, and it's very strange way of language evolution  - If we can't do it right, we won't do it at all.

--- Comment #24 by ianlancetaylor ---
Yes: it used to work, but it wasn't possible to make it work with modules.

My apologies for the loss of functionality.

--- Comment #25 by gopherbot ---
Change https://golang.org/cl/359575 mentions this issue: `Revert "cmd/go: remove support for -buildmode=shared"`

--- Comment #26 by rsc ---
@ianlancetaylor, @bcmills, and I talked a bit more about this yesterday.
I had not seen the comments from Sept 2 onward until the last couple days.
(I can't keep up with all the GitHub mail I get,
and once a proposal is accepted I tend not to watch it.)

We've decided to leave -buildmode=shared alone (not delete it) for Go 1.18,
but it's not going to work any better than it does today.
In particular, we're not fixing any bugs in it anymore,
and we still intend to remove it in a future release.
However, I would like to better understand how to serve existing use cases, if that's possible.

The most fundamental bug is that -buildmode=shared stores state in $GOROOT/pkg (#22196),
making that directory not a cache that can be deleted and recreated at any time.
This made a little bit of sense when you had to `go install` individual packages
in order to use them in future builds, but not really, and especially not now that
`go install` is completely unnecessary for packages.

A second important bug is that nothing about the shared objects is cached properly (#24034).
Consider this pair of commands:

	go install -buildmode=shared std
	go build -linkshared helloworld.go

The `go build` repeats all the work of the first `go install`,
rebuilding the entire standard library in shared mode and creating a new `libstd.so`,
installing it over the (identical) existing one.
If you run the `go build` again, it does all the work yet again.
Every time.

This makes builds using `-linkshared` incredibly slow,
and it also means that they don't work at all without write access to $GOROOT.

A third important bug is that the toolchain fundamentally assumes that packages
are being compiled against the exact versions of the packages they import (#19389, #21510).
For example, suppose `draw.Point` is `struct { X, Y int }`
and you build the standard library into `libstd.so`
and then you build a graphics program against it.
And suppose then the standard library changes to add `Z int` to `Point`.
Any stack allocation of a `Point` in the graphics program is now failing to reserve enough space,
which will probably lead to memory corruption when invoking any function that takes or returns a `Point`,
or invalid address arithmetic accessing `points[i]` for `var points []draw.Point`.
The problem is that the compiled client code assumes something about `draw.Point`,
namely that it is two words long, so that can't change in `libstd.so` without recompiling the clients.
Escape analysis, inlining, and other optimizations make the same kinds of assumptions:
if `draw.Point.Add` has been inlined into the client code, then changing the copy in `libstd.so`
will have no effect (or, worse, inconsistent effects depending on inlining decisions).
And if a function parameter that didn't escape starts escaping,
optimizations applied in the client code are no longer valid.

These may seem like obvious examples, especially to people familiar with shared library gotchas.
We could of course add even more special logic to the toolchain,
so that it knows where the shared library boundaries are,
and then we could disable any use of escape analysis results
or inlining of function bodies across those boundaries.
But we are never going to disable things like doing a simple multiplication to access `points[i]`.
The result would be too horribly inefficient.
Instead we change the ABI hash when almost any detail of the original source changes,
which means that you can basically never drop in a new `libstd.so` and use it with
programs compiled against an older `libstd.so` (#23405).

On top of those fundamental problems, there are many corner cases that don't work,
most of which @seankhliao helpfully closed (thanks!):

- [cmd/go: go install buildmode=shared doesn't work without first building the standard library #12136](https://golang.org/issue/12136)
- [test: nilptr.go fails on ppc64le when externally linked #13436](https://golang.org/issue/13436)
- [cmd/link: -buildmode=shared includes dead symbols #14578](https://golang.org/issue/14578)
- [cmd/link: panic: runtime error: invalid memory address or nil pointer dereference when using -buildmode=shared -linkshared on ppc64le #15770](https://golang.org/issue/15770)
- [build: run more buildmode=shared tests #16602](https://golang.org/issue/16602)
- [cmd/link: using -linkshared dies if compile not passed -p option #16632](https://golang.org/issue/16632)
- [cmd/go: -buildmode=plugin -linkshared -> build failure #18671](https://golang.org/issue/18671)
- [cmd/internal/dwarf: incorrect or missing dwarf information in libstd.so on ppc64le, amd64 #20328](https://golang.org/issue/20328)
- [cmd/link: seg fault in shared buildmode from main package with exported variable #22566](https://golang.org/issue/22566)
- [cmd/go, cmd/link: support buildmode=shared on darwin #23126](https://golang.org/issue/23126)
- [runtime: segfault in sync.Pool when using a shared runtime #24640](https://golang.org/issue/24640)
- [cmd/link: run tests failed with lots of cases in buildmode=shared #26400](https://golang.org/issue/26400)
- [cmd/link: run test in -linkshared mode failed #26582](https://golang.org/issue/26582)
- [cmd/go: cannot use packages ... from different roots #33037](https://golang.org/issue/33037)
- [cmd/go: Building a shared library in modules mode produces empty library #37675](https://golang.org/issue/37675)
- [cmd/link: buildmode=shared with many packages produces "file name too long" error #38330](https://golang.org/issue/38330)
- [cmd/link: dynamic linking cannot be stepped through using gdb #38378](https://golang.org/issue/38378)
- [cmd/go: executable created using linkshared option is not linking .so created by buildmode=shared with go modules enabled #38499](https://golang.org/issue/38499)
- [cmd/go: Mac Catalina 10.15.6 -buildmode=shared not supported on darwin/amd64 #40532](https://golang.org/issue/40532)
- [cmd/go: crashes when -buildmode=shared is set and modules enabled #42189](https://golang.org/issue/42189)
- [cmd/link: can't build shared time/tzdata #44073](https://golang.org/issue/44073)
- [cmd/link: building a package that uses cgo errors out with "cannot implicitly include runtime/cgo in a shared library" #47183](https://golang.org/issue/47183)
- [cmd/link: panic: runtime error: makeslice: cap out of range #47455](https://golang.org/issue/47455)

We can leave those closed, by the way.

There are two main reasons that people reach for shared libraries.
First, the argument goes, shared libraries make it possible to handle a security fix for a library
by updating the one copy of the library and to avoid updating all programs using it.
Second, shared libraries result in smaller binaries.

The security fix argument basically doesn't hold up at all.
Even in C, it only works if you are incredibly careful in the first place
and don't need to change any details of the library headers, such as
struct layouts, #defined macros, and so on.
In Go, as noted above, it works approximately never. Never has.
Even if we solved the escape analysis and inlining problems,
it's not uncommon to need to add a new field to a struct in order to fix a security problem.
If you have been using Go's -buildmode=shared to make security fixes easier to deploy,
you probably have unpatched or unstable programs and should reconsider that decision immediately.

That leaves smaller binaries.
The last three comments above all mention binary size as the reason for using -buildmode=shared.
And I appreciate that hello world linked against `libstd.so` is only 1.6% the size of its statically linked cousin!
(A more realistic example: the go command is 31% the size when std is dynamically linked.)

Assuming that smaller binaries is the only use case we need to support, 
I think it would work to simplify down to supporting only a single .so,
which you can build with -buildmode=shared but then have to provide
explicitly to future builds as â€œthis is the .so I want to share code with.â€
Those future builds read what they need from the .so (bypassing $GOROOT entirely),
and they fail if the .so is stale.

The current idiom

	go install -buildmode=shared std
	go build -linkshared helloworld.go

would be replaced with:

	go build -buildmode=shared -o libmyshared.so std
	go build -linkshared=libmyshared.so helloworld.go

Of course, it wouldn't have to be just std: it could be std plus other packages.
But you only get one .so, and you have to manage installing it
and providing it to future go build commands.
All the .shlibname code in cmd/go gets deleted.

Distributions might choose to do

	go build -buildmode=shared -o libgo1.17.2.so std golang.org/x/...
	go build -linkshared=libgo1.17.2.so cmd1
	go build -linkshared=libgo1.17.2.so cmd2
	go build -linkshared=libgo1.17.2.so cmd3

And then if they need to support multiple Go versions, it's obvious what to do.

Glancing through the bug titles above, it looks like this design would eliminate
the vast majority of the issues we've had. It definitely addresses the most serious
problems that I mentioned above. The only problem I'd still be concerned
about is the handling of debug information, but that should be doable.

We are already planning to keep -buildmode=plugin and -buildmode=c-shared,
so I am hoping that the amount of extra code for this more limited -buildmode=shared
will not be a significant burden.

To everyone, but especially to @rasky, @zhouguangyuan0718, @Jason7602, and @mlaventure:
would this alternate UX for -buildmode=shared work for your current use cases?

Thanks.


--- Comment #27 by rsc ---
Bumped this back into "Likely Decline" so that we can include the status update in the next proposal minutes.


--- Comment #28 by mlaventure ---
> To everyone, but especially to @rasky, @zhouguangyuan0718, @Jason7602, and @mlaventure:
would this alternate UX for -buildmode=shared work for your current use cases?

Thanks for reopening and considering this use case @rsc .

Your proposal would work for me indeed. Not as flexible as having every module as a separate library, but given the added complexity, I find the one library to be a nice compromise. :+1: 


--- Comment #29 by rasky ---
Thanks for reopening. It would work for me. My use case is embedded system with limited flash where you want to deploy multiple binaries written in Go. The current workaround is to link all unrelated applications in a single binary and then use symlinks and check argv[0] to internally dispatch to the right entrypoint (ala busybox). 

Putting common code (std + other packages) in a single `.so` file would surely solve my problem.

--- Comment #30 by thanm ---
Russ wrote:
>>The only problem I'd still be concerned about is the handling of debug information, but that should be doable

One thing we can do that would make the problem more tractable in general would be to move DWARF type DIE generation out of the linker and into the compiler (this is an idea that we've toyed with the in the past but haven't gotten to).  Doing that would definitely help for the "link shared against libstd.so" use case.

