==== [Issue Title] ====
proposal: errors: add Errors as a standard way to represent multiple errors as a single error

==== [Issue Body] ====
# Description 
It is common practice in golang to return an error from a func in the event of a problem during its execution (e.g. `func myFunc() error { ... }`). 

However, there are a few cases, such as field validation on a struct, where it is useful to return multiple errors from a function (e.g. `func validate(m *Model) []error`). Sometimes these errors need to be 'bubbled up' through a call stack that only returns one error. So, I find myself having to re-implement custom errors that represent many errors in each of my projects. 

I think a generic solution could be added to the standard libraries' `errors` package that serves this purpose.

## Example Implementation
I've updated the example implementation to incorporate the feedback from @neild and @D1CED
```go
package util

import (
	"fmt"
)

// Errors are many errors that can be represented as a single error
type Errors interface {
	Errors() []error
	error
}

// NewErrors combine many errors into a single error
func NewErrors(errs ...error) error {
	if lenErrs := len(errs); lenErrs == 0 {
		return nil
	} else if lenErrs == 1 {
		return errs[0]
	}
	var es manyErrors
	for _, err := range errs {
		// Merge many slices of errors into a single slice
		if errs, ok := err.(Errors); ok {
			es = append(es, errs.Errors()...)
			continue
		}
		es = append(es, err)
	}
	return es
}

// manyErrors combines many errors into a single error
type manyErrors []error

// Is works with errors.Is
func (es errors) Is(find error) bool {
        for _, e := range es {
                if Is(e, find) {
                        return true
                }
        }
        return false
}       

// As works with errors.As
func (es errors) As(find interface{}) bool {
        for _, e := range es {
                if As(e, find) {
                        return true
                }
        }
        return false
}

// Errors implements the Errors interface
func (es manyErrors) Errors() []error {
	return []error(es)
}

// Error implements the error interface
func (es manyErrors) Error() string {
	return fmt.Sprintf("[%v", []error(es))
}

```

## Example Usage
```go
import "errors"

type Model struct {
	FieldOne   string `json:"field_one"`
	FieldTwo   string `json:"field_two"`
	FieldThree string `json:"field_three"`
}

func (m *Model) Validate() error {
	var errs []error
	if len(m.FieldOne) < 1 {
		errs = append(errs, errors.New("'field_one' is required"))
	}
	if len(m.FieldTwo) < 1 {
		errs = append(errs, errors.New("'field_two' is required"))
	}
	if len(m.FieldThree) < 1 {
		errs = append(errs, errors.New("'field_three' is required"))
	}
	return errors.NewErrors(errs...)
}
```
# Conclusion
Whether or not this proposal is accepted, I'm curious how others have approached this problem in the past and if there's already a commonly referenced solution that I'm unfamiliar with. Thanks üôè

==== [Comments] ====

--- Comment #1 by neild ---
If `err` contains multiple errors, what does `errors.Is(err, fs.ErrExist)` return?

* `true` if all errors in `err` are `fs.ErrExist`?
* `true` if at least one error in `err` is `fs.ErrExist`?
* always `false`?

If we use `errors.As` to convert a multierror value to a `*os.PathError`, does it:

* return `true` if at least one error in `err` is an `*os.PathError`, and extract one of the `*os.PathError`s?
* return `true` if the only error in `err` is an `*os.PathError`?
* always return `false`?

--- Comment #2 by marksalpeter ---
Thanks for the feedback @neild! Handling wrapped errors certainly complicates things.

**Full disclosure: I don't generally use wrapped errors in production, so I would defer to the wisdom of those who do.**

That said, here are my thoughts:

I think `errors.Is` can either remain as is (always `false`) or  be modified to return `true` if at least one error in `err` is `fs.ErrExists` - whichever seems more useful or backwards compatible. If the former is deemed better, then it will be up to developers to use `Contains` instead of `Is` when they intend to check multiple errors. If the latter is deemed better, then we can combine the logic in `Contains` with the logic inside of `Is` and remove the `Contains` method altogether.

The `errors.As` implementation should match the behavior of `errors.Is`. So, if its decided that `errors.Is` should always return `false`, then so should `errors.As`. If it's decided that `errors.Is` should return `true`, then `errors.As` should return `true` and copy the first `*os.PathError` that it finds. In this case, the order of the errors in the slice returned by `Errors.Errors()` would be significant. 

If all of the `*os.PathError`s are required from the `err`, we could modify `As` to handle something like `As(err, NewErrors(nilTypeOneErr, nilTypeTwoErr, nilTypeThreeErr))`. Then, theoretically, we would be able to extract multiple errors (potentially of multiple types) from a single call to the `As` func without the addition of any other methods.

Which way would you prefer @neild, @D1CED? 

--- Comment #3 by marksalpeter ---
Thinking some more about your questions, maybe there's a simpler solution that wouldn't require modifying `errors.Is` or `errors.As`:

```go
// Errors are many errors that can be represented as a single error
type Errors interface {
	Errors() []error
	error
}

// NewErrors combine many errors into a single error
func NewErrors(errs ...error) Errors {
	if len(errs) == 0 {
		return nil
	}
	var es errors
	for _, err := range errs {
		// Merge many slices of errors into a single slice
		if errs, ok := err.(Errors); ok {
			es = append(es, errs.Errors()...)
			continue
		}
		es = append(es, err)
	}
	return es
}

// errors combines many errors into a single error
type errors []error

// Unwrap works with errors.Unwrap
func (es errors) Unwrap() error {
	if len(es) > 0 {
		return es[1:]
	}
	return nil
}

// Is works with errors.Is
func (es errors) Is(err error) bool {
	if len(es) == 0 {
		return err != nil
	}
	return err.Error() == es[0].Error()
}

// Errors implements the Errors interface
func (es errors) Errors() []error {
	return []error(es)
}

// Error implements the error interface
func (es errors) Error() string {
	return fmt.Sprintf("%v", []error(es))
}
```

Thoughts @neild, @D1CED?

--- Comment #4 by D1CED ---
First let me start out by saying that there seems to be a clear need for this feature as seen by looking for 'multi error' on pkg.go.dev. 
From the ones I skimmed through none had (documented) support for As or Is.
Providing the most information possible is still the right call here IMO. If we don't provide Is and As the users have to explicitly check for the Errors interface. One issue here you also targeted is that of performance. On a very large error slice Is and As would be (multiple) linear searches. Not great. A more efficient implementation here would be fairly difficult I assume.

--- Comment #5 by D1CED ---
@marksalpeter Your implementation of Is and Unwrap is incorrect here. For example if Errors only contains a single error Unwrap discards it instead of returning it unwrapped and Is does a string comparison on just the first error?! 

--- Comment #6 by marksalpeter ---
@D1CED My apologies. As I said before, I'm unfamiliar with the use case. My understanding of `Unwrap` is that it returns one frame down the error "call stack". So for example `errors.Is` would call `err.Is` and if that failed, it would call `err.Unwrap` until `err.Is` returns true. How is it supposed to be implemented?

--- Comment #7 by D1CED ---
Uh, I think my statement above was partially incorrect. Your implementation kind of does work when changing the comparison. But it seems like we have a very different idea here. My suggested implementation would be 

```
package errors

func (es errors) Is(find error) bool {
        for _, e := range es {
                if Is(e, find) {
                        return true
                }
        }
        return false
}       

func (es errors) As(find interface{}) bool {
        for _, e := range es {
                if As(e, find) {
                        return true
                }
        }
        return false
}

```

and I'd not implement an Unwrap method at all.

Edit: Got a little confused with the names here. The package is called errors and type is called errors. Maybe we should call it multiError as this seems to be a common name.

--- Comment #8 by D1CED ---
One small feature I found when looking at other implementations is that if there is exactly one error it is simply returned unwrapped. This should be considered here too.

--- Comment #9 by marksalpeter ---
@D1CED I'm not sure that recursively calling `errors.Is` or `errors.As` like this is necessary, wise or even correct. Keep in mind,  `errors.As` will be calling `errors.errors.As` and `errors.Is` will be calling `errors.errors.Is`. I'll have to think about this some more.

--- Comment #10 by marksalpeter ---
@D1CED You can see on [line 90 of `wrap.go`](https://cs.opensource.google/go/go/+/refs/tags/go1.17:src/errors/wrap.go;l=90) that `errors.errors.Unwrap` will be called until `errors.errors.As` succeeds. So therefore, I think a more correct implementation of `errors.errors.As` would be 

```go
// As works with errors.As
func (es errors) As(target interface{}) bool {
	if len(es) == 0 {
		return false
	}
	err := es[0]
	val := reflectlite.ValueOf(target)
	targetType := val.Type()
	if reflectlite.TypeOf(err).AssignableTo(targetType) {
		val.Elem().Set(reflectlite.ValueOf(err))
		return true
	}
	return false
}
```

I also think the version of `errors.errors.Is` I wrote would pass any tests of `errors.Is` functionality you subjected it to.

--- Comment #11 by marksalpeter ---
I've added the example implementations of As and Is to the original example in the proposal with a note at the top. Thanks again for pointing out this use case @neild üôè

--- Comment #12 by marksalpeter ---
> Uh, I think my statement above was partially incorrect. Your implementation kind of does work when changing the comparison. But it seems like we have a very different idea here. My suggested implementation would be
> 
> ```
> package errors
> 
> func (es errors) Is(find error) bool {
>         for _, e := range es {
>                 if Is(e, find) {
>                         return true
>                 }
>         }
>         return false
> }       
> 
> func (es errors) As(find interface{}) bool {
>         for _, e := range es {
>                 if As(e, find) {
>                         return true
>                 }
>         }
>         return false
> }
> ```
> 
> and I'd not implement an Unwrap method at all.
> 
> Edit: Got a little confused with the names here. The package is called errors and type is called errors. Maybe we should call it multiError as this seems to be a common name.

Ok, so I traced this and the recursive call is definitely more correct than either of my previous attempts. Sorry about that üòÖ.

I still think we can use `Uwrap` to treat the `[]errors` like any other stack of errors instead of looping over the slice in the func. I've included the changes in the example at the top. Let me know what you think @D1CED

--- Comment #13 by neild ---
> Which way would you prefer @neild, @D1CED?

I don't know. Any multiple-error type needs to come up with good answers for these questions, however.

Another question without an obviously correct universal answer is what the error string for a collection of errors should look like: Concatenate all the error strings with some separator? One line or multiple lines? Summarize in some fashion, such as deduplicating multiple instances of the same error text?

The fact that there didn't seem to be an obviously correct universal answer to these questions was a primary reason we didn't introduce a standard multierror type in Go 1.13. There are now a number of multiple-error types implemented outside the standard library; perhaps considering the experience of these implementations would point at some answers.

--- Comment #14 by marksalpeter ---
Thanks for bringing other package implementations to my attention. It looks like [hashicorp has a pretty good one](https://github.com/hashicorp/go-multierror) that handles the `Unwrap`, `As`, and `Is` cases similarly.

Do you have a reference to the go 1.13 discussion around multierrors @neild? Maybe this will help me get up to speed. 

As for formatting the errors, I‚Äôm inclined towards an approach with a global `DefaultFormatter` var and then anything else (de-duping, summarizing, fancy printing,etc) could be left to a custom `Errors` implementation. But maybe there are better ideas already in the discussion.

--- Comment #15 by neild ---
> Do you have a reference to the go 1.13 discussion around multierrors @neild?

Not any more, sorry.

The key points as I recall them were:
* It is not obvious how multiple errors unwrap. (`errors.Is`, etc.)
* It seems possible that different users have different requirements for unwrapping.
* There is no single, obvious answer to what the error text of a multierror is.
* There is no obstacle to implementing a multierror outside the standard library.

This all argued that we should avoid standardizing a multierror type at the time.

My personal experience has been that general-purpose error aggregating types push complexity to the users of an API that is better handled internally, and that it is usually best to either explicitly return an `[]error` or an opaque `error` with useful error text describing the failures encountered and no way to access the individual errors.

--- Comment #16 by earthboundkid ---
I have a multierror package: https://github.com/carlmjohnson/errutil. Mine is better than other people‚Äôs because it is compatible with both Hashicorp and Uber multierrors. :-) More seriously, I think the design space here is a little too ambiguous to fit into the standard library. There isn‚Äôt one right way to handle unwrapping. 

--- Comment #17 by marksalpeter ---
@neild, I think the use of an interface can sidestep the issues of specific formatting requirements and even incompatible unwrapping requirements, much like the `error` interface itself. 

As for there being "no obstacle to implementing multierror outside of the standard library", this is also true of many standard library packages. I think the real question is whether or not this is a common enough use case to warrant a standard solution. I agree with @D1CED that the answer is a firm "yes". While its possible to pass a `[]error` or create a custom error type on a per use case basis, it's clear that many developers prefer to use a multierror implementation instead.

@neild @carlmjohnson Just so I understand the problem set better, do either of you have an example of incompatible unwrapping requirements? 

--- Comment #18 by earthboundkid ---
Suppose you have error 1 which is a normal error and error 2 which `fmt.Errorf("my prefix: %w", Multierror{err3, err4})`. What happens if you combine error 1 and 2? Does it flatten the tree? If it doesn‚Äôt flatten the list, you get unexpected results when you try to iterate through all suberrors. But if it does flatten the list, you lose ‚Äúmy prefix‚Äù which might be important. 

--- Comment #19 by marksalpeter ---
Thanks for clarifying @carlmjohnson 

> If it doesn‚Äôt flatten the list, you get unexpected results when you try to iterate through all suberrors. 

This is a good point and it kind of unpacks what @neild said in the beginning. 
 
Imagine traversing an error stack like this:
```go
err3 := fmt.Errorf("d %w",  errors.New("e"))
err2 := fmt.Errorf("b %w",  &customError{ "c" })
err1 := fmt.Errorf("a %w", errors.NewErrors(err2, err3))

// Traverse the error stack
for err := err1; err != nil;  err = errors.Unwrap(err1) {
  fmt.Println(err1)
}
```

Ether the output looks like this:
```bash
a [b c d e]
[b c d e]
[c d e]
[d e]
[e]
```

Or it looks like this:
```bash
a [b c d e]
[b c d e]
```

Maybe the second way is more clear. Multierrors are wrapped together, so they should be unwrapped together. Therefore, its better traverse them differently, using the `Errors()` method. Although doing it this way might mean calling `errors.Is` and `errors.As` on each sub-error, as @D1CED suggested. 

The question then becomes, **"Does `errors.As(err1, &customErr)` return `true`?"**. To me, the obvious answer is **yes**.  So my questions to you, @neild, @carlmjohnson, @D1CED, are:

1. Do some people prefer `errors.As(err1, &customErr)` to return `false` in this case?
2. Are there example implementations that work like point 1?
3. Also I think what some of you are alluding to in terms of the prefix and formatting questions are support for multierror inside of `fmt.Errorf` (eg `fmt.Errorf("one: %w, two: %w, three:%w", err1, err2, err3)`). This is opens up a can of worms. I see no reason why a scaled down proposal like this one requires multi error support for `fmt.Errorf` or if that's even possible given the constraints. Is this point where proposal got 'stuck'?

--- Comment #20 by jakobmaier ---
I used [hashicorp](https://github.com/hashicorp/go-multierror) for a while, but ran into the same problems as you already discovered:

What happens when appending/merging/flattening errors that are multi-errors? How to format errors? What about As/Is?

A lot of those questions need to be decided on a case-by-case basis (even within the same project), so in the end I [wrote my own multierr implementation](https://github.com/maja42/multierr) which I now use for all of my private- and work projects. It covers all those situations gracefully. Only the As/Is/Unwrap behavior can be controversial, which is why I implement `Inspect()`.

Usually I prefer the Append() function, which does not flatten the tree. I only use Merge() (=flatten errors) when writing validation functions on smaller, nested structs.

So yes, this is a pretty common issue. But there's no universal solution, and already a few libraries. So I don't think this should be added to the standard library.

--- Comment #21 by rsc ---

This proposal has been added to the [active column](https://golang.org/s/proposal-status#active) of the proposals project
and will now be reviewed at the weekly proposal review meetings.
‚Äî rsc for the proposal review group


--- Comment #22 by rsc ---
Based on the discussion above, especially https://github.com/golang/go/issues/47811#issuecomment-905690372, it sounds like there's no good single answer for this, so we should leave it to continue to be provided by packages outside the standard library.


--- Comment #23 by rsc ---

Based on the discussion above, this proposal seems like a **[likely decline](https://golang.org/s/proposal-status#likely-decline)**.
‚Äî rsc for the proposal review group


--- Comment #24 by mvdan ---
> My personal experience has been that general-purpose error aggregating types push complexity to the users of an API that is better handled internally, and that it is usually best to either explicitly return an `[]error` or an opaque `error` with useful error text describing the failures encountered and no way to access the individual errors.

If that's going to be our position while rejecting a standard `Errors` type, I think we should make that advice more clear. For example, as a bit of godoc in the `errors` package.

I keep seeing Go developers copying the idea of a "multiple errors" type, from places like hashicorp's module or https://pkg.go.dev/go/scanner#ErrorList. I think the majority assume that using an opaque `error` or an `[]error` slice is a worse idea, and right now there isn't any text advising them otherwise.

The alternative is that we're still considering adding an `Errors` type in the future. If that's the case, then I think we should leave an umbrella issue open about it, to clarify the intent.

--- Comment #25 by rsc ---
I don't think we have any intent to add a standard Errors type in the future (or else we would have discussed this proposal more and tried to refine it). Exactly what it means to have more than one error will vary by use case.


--- Comment #26 by rsc ---

No change in consensus, so **[declined](https://golang.org/s/proposal-status#declined)**.
‚Äî rsc for the proposal review group


--- Comment #27 by D1CED ---
For people interested: there is currently a proposal to add a similar concept to python [PEP-654](https://www.python.org/dev/peps/pep-0654).

--- Comment #28 by marksalpeter ---
I would just like to say to everyone involved that I really appreciate the lively discussion and consideration of this proposal. It uncovered a number of issues, use cases and concerns regarding the unwrapping and equality of errors that I was previously unaware of. And now I have a much deeper understanding of how error wrapping is being used in practice and all of the ways gophers are interested in potentially using a multierror.

I still think there's an opportunity to bring a more integrated, stripped back, proposal of an `Errors` interface to the standard library - one that side steps many of these concerns, but is perhaps less useful on its own. I'll be sure to link that proposal to this one once it's ready.

Again, a big thank you to everyone involved. This was, if nothing else, enlightening üôè

--- Comment #29 by jba ---
I'm sorry I missed this discussion, although at the time I would have probably agreed with the decision. Now I think there are clear answers to the questions posed here. Namely:

- the Multierror type does not implement Unwrap (this is the key new idea)
- errors.Is reports true for a MultiError if it is true for any of the contained errors
- errors.As does the same; it traverses the contained errors left to right
- An Errors method returns the flattened list of errors, where the flattening only occurs if the contained error is itself a Multierror. Since a Multierror is nothing but a collection of errors, no information is lost.

This matches [Tailscale's](https://pkg.go.dev/tailscale.com/util/multierr) design.

Are any of these controversial? It seems to me that once you get rid of Unwrap, these are all more or less obvious. I was always hung up on figuring out what Unwrap would mean, on the assumption that it would be used a lot. (People used to talk about errors "causes" all the time, meaning the last error in the chain.) My understanding now is that we were successful in promoting Is and As, so that it's rare to call Unwrap. If that's correct, then dropping it here will cause little pain.

Formatting is still an open question (here is [one cute idea](https://github.com/golang/go/issues/52607#issuecomment-1119766977)).

To be clear, I'm not asking to reopen this proposal yet, nor yet asking for formatting ideas. I'm conducting a poll: are the semantics I presented wrong for anyone? Because if not, then the main reason for rejection‚Äìthere are too many ways to do this‚Äîis in question.

--- Comment #30 by earthboundkid ---
Interesting. I think one of the keys has to be that multierror(multierror) gets flattened but multierror(wrapper(multierror)) does not, so that a wrapper is never lost in the process of creating the multierror. Once you do that, one of the main objections I had to this proposal goes away. 
