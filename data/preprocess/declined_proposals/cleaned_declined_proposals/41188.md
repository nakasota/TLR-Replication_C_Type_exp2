==== [Issue Title] ====
proposal: os: make Readdir return lazy FileInfo implementations

==== [Issue Body] ====
An `os.File` provides two ways to read a directory: `Readdirnames` returns a list of the names of the directory entries, and `Readdir` returns the names along with stat information.

On Plan 9 and Windows, `Readdir` can be implemented with only a directory read - the directory read operation provides the full stat information.

But many Go users use Unix systems.

On most Unix systems, the directory read does not provide full stat information. So the implementation of Readdir reads the names from the directory and then calls Lstat for each file. This is fairly expensive. 

Much of the time, such as in the implementation of filepath.Glob and other file system walking, the only information the caller of `Readdir` really needs is the name and whether the name denotes a directory. On most Unix systems, that single bit of information—is this name a directory?—is available from the plain directory read, without an additional stat. If the caller is only using that bit, the extra Lstat calls are unnecessary and slow. (Goimports, for example, has its own directory walker to avoid this cost.)

Various people have proposed adding a third directory reading option of one form or another, to get names and IsDir bits. This would certainly address the slow directory walk issue on Unix systems, but it seems like overfitting to Unix.

Note that `os.FileInfo` is an interface. What if we make `Readdir` return a slice of lazily-filled `os.FileInfo`? That is, on Unix, `Readdir` would stop calling `Lstat`. Each returned `FileInfo` would already know the answer for its `Name` and `IsDir` methods. The first call to any of the other methods would incur an `Lstat` at that moment to find out the rest of the information. A directory walk that uses `Readdir` and then only calls `Name` and `IsDir` would have all its `Lstat` calls optimized away with no code changes in the caller.

The downside of this is that the laziness would be visible when you do the `Readdir` and wait a while before looking at the results. For example if you did `Readdir`, then touched one of the files in the list, then called the `ModTime` method on the `os.FileInfo` that `Readdir` retruned, you'd see the updated modification time. And then if you touched the file again and called `ModTime` again, you _wouldn't_ see the further-updated modification time. That could be confusing. But I expect that the vast majority of uses of `Readdir` use the results immediately or at least before making changes to files listed in the results. I suspect the vast majority of users would not notice this change.

I propose we make this change—make `Readdir` return lazy `os.FileInfo`—soon, intending it to land in Go 1.16, but ready to roll back the change if the remainder of the Go 1.16 dev cycle or beta/rc testing turns up important problems with it.

/cc @robpike @bradfitz @ianthehat @kr

==== [Comments] ====

--- Comment #1 by bradfitz ---
Last time this was proposed there was debate about what the behavior for `ModTime` and `Mode` and `Size` should be if the lazy `Lstat` fails later, as they don't return errors. Panic is bad. Logging is weird. Zero values I guess?


--- Comment #2 by bcmills ---
I think this is likely to introduce subtle changes in behavior. Perhaps more importantly, I don't think this is the sort of change that we can reliably verify during a development cycle.

In my experience, very few users who are not either Go contributors or Googlers test Beta or RC releases of the Go toolchain, and changes in the `os` package are less likely to turn up during Google testing because a significant fraction of Google programs do most of their I/O without using the `os` package directly.

--- Comment #3 by tv42 ---
os.FileInfo can't be lazy as-is, because it can't return an error. Returning a 0 size on transient errors is **not** acceptable.

--- Comment #4 by ianlancetaylor ---
See also #40352, which is about different approaches to efficiently uncover similar information.

--- Comment #5 by tv42 ---
(Ignoring the POSIX API for a moment) NFS, and likely many other network filesystems, can do completely separate operations depending on whether the stat info is going to be needed (NFSv3 readdir vs readdirplus, NFSv4 "bulk LOOKUP", FUSE_READDIRPLUS).

There's also been a lot of talk about a Linux syscall that would fetch getdents+lstat info, for example https://lwn.net/Articles/606995/ -- they all seem to revolve around the idea of the client knowing beforehand whether it will be doing the lstat calls or not, and communicating that to the kernel.

These combined make me think the right path forward would be a Readdir method that takes arguments that inform it which os.FileInfo fields will be wanted; the rest could be zero values.

(That extended Readdir could also take a flag for whether to sort the results or not, removing one common cause of forks for performance reasons.)

--- Comment #6 by networkimprov ---
EDIT: This has a detailed proposal in #41265

I believe we need a new _dirent_ abstraction.

After reviewing suggestions from the FS API discussion...

- [`ReadDir()` argument gives fields to populate](https://www.reddit.com/r/golang/comments/hv976o/qa_iofs_draft_design/g0v93ra/?utm_source=reddit&utm_medium=web2x&context=3)
- [`DirEntry` gets native _dirent_ fields and lazy-loads others; .Has() indicates is-loaded](https://www.reddit.com/r/golang/comments/hv976o/qa_iofs_draft_design/g0hwjij/?utm_source=reddit&utm_medium=web2x&context=3)

Let's consider a hybrid:
1. `ReadDir(path string, n int, opt uint64) ([]DirItem, error)` - opt is fields to load and sorting (0 is OS defaults)
   (may return more fields than requested)
1. `(d *DirEntry) Load(fields uint64) error` - (re-)loads the fields
   (returns error if inode doesn't match)
1. `(d *DirEntry) Has(fields uint64) bool` - indicates whether the fields are loaded
1. `(d *DirEntry) Id() FileId` - gives unix inode or winapi fileId; could take an argument re device info
1. `(d *DirEntry) Xyz() T` - panics for any field not loaded (a programmer mistake)

That solves the `.ModTime()` etc issue with lazy-loading, and avoids an error check after every field access.

EDIT: The interface which `DirEntry` implements and `ReadDir()` returns:
```
type DirItem interface {
   Load(fields uint64) error
   Has(fields uint64) bool
   Name() string
   IsDir() bool
}
```

Rationale:
a) If you need certain fields for every item, request them in `ReadDir()`.
b) If you need certain fields for some items, request them in `DirEntry.Load()`.
c) If you need certain fields only when they're the OS default, check for them with `DirEntry.Has()`.
d) If you need the latest data for an item, request it with `DirEntry.Load()`.

--- Comment #7 by tv42 ---
> 3. `(d *DirEntry) Id() FileId` - gives unix inode or winapi fileId

Wasn't the Windows FileId 128-bit? (Seen somewhere on go issues around the greater topic in the last few days.)

Either way, the unix inode number isn't very useful without the device major:minor. For example, you can't `filepath.Walk` and expect inode alone to identify hardlinked files, because you may have crossed a mountpoint.

Also, inode number and such belong in a `.Sys()` style, platform-specific, extension point.

--- Comment #8 by networkimprov ---
I gave the .Id() type as `FileId`, which can be whatever (e.g. opaque array), and store major:minor. The fact that a `FileId` can't be compared across platforms isn't a reason to hide it. It's needed to replicate a tree containing multiple hard links for a file -- which I do.

Today on Windows, FileInfo.Sys() can't even provide the fileId! Adding it was debated and discarded.

Is there any practical value in .Sys() besides providing .Ino on unix?

Winapi fileId is 64-bit on NTFS, 128-bit on ReFS (an alternative for Windows Server):
https://docs.microsoft.com/en-us/windows/win32/api/fileapi/ns-fileapi-by_handle_file_information
https://docs.microsoft.com/en-us/windows-server/storage/refs/refs-overview

--- Comment #9 by benhoyt ---
I really like the intent, but I agree with other commenters that the API just doesn't quite fit as is, because of potential errors returned by the lazy methods. We actually debated a very similar issue when designing the [os.scandir / os.DirEntry](https://docs.python.org/3/library/os.html#os.DirEntry) API in Python. At first we wanted to make the DirEntry methods properties, like `entry.stat` without the function call parentheses. That works in Python, but it *looks* like a plain attribute access, and people aren't expecting to have to catch exceptions (errors) when accessing an attribute, so we made it a function call. Per the docs:

> Because the os.DirEntry methods can make operating system calls, they may also raise OSError. If you need very fine-grained control over errors, you can catch OSError when calling one of the os.DirEntry methods and handle as appropriate.

I believe this decision was based on theoretical concerns, not from actual testing, but still, the logic seems sound. *Especially* in Go, where all error handling is super-explicit (we always want "find grained control over errors"). Panic-ing is not going to work, and silently returning a zero value is arguably worse.

--- Comment #10 by diamondburned ---
> The downside of this is that the laziness would be visible when you do the `Readdir` and wait a while before looking at the results. For example if you did `Readdir`, then touched one of the files in the list, then called the `ModTime` method on the `os.FileInfo` that `Readdir` retruned, you'd see the updated modification time. And then if you touched the file again and called `ModTime` again, you _wouldn't_ see the further-updated modification time. That could be confusing. But I expect that the vast majority of uses of `Readdir` use the results immediately or at least before making changes to files listed in the results. I suspect the vast majority of users would not notice this change.

I have always been under the impression that calling a method on `os.FileInfo` will fetch the information again until recently. After all, it's an interface, so there wouldn't really be a way to know that unless I read the documentation carefully.

This leads me to believe that saving those information should be up to the user, the caller, to decide when and what to store. The `os.FileInfo` interface could then just not store anything and do an `Lstat` every time it needs that piece of information.

Another solution would probably be to dirtily make a new `os.InfoResetter` interface to accommodate scenarios where an explicit renew should be done. For example:

```go
// Reset the os.FileInfo to fetch new information.
if resetter, ok := fileInfo.(os.InfoResetter); ok {
    resetter.ResetInfo()
}
```

Although this solution still has the behavior that a `ModTime` would return a new value after a touch and before calling the method, it would give callers explicit control over whether or not future `ModTime` calls should return the new value.

--- Comment #11 by tv42 ---
@benhoyt 

> I believe this decision was based on theoretical concerns, not from actual testing, but still, the logic seems sound.

There's nothing theoretical about `lstat(2)` returning errors. For example, the file may be removed between the readdir and the lstat. A network partition can occur after readdir, before lstat. A filesystem can have a bug. There's no justification for filling os.FileInfo with imaginary content, Go doesn't throw exceptions for such things, and os.FileInfo methods don't have error returns so it's too late to make syscalls then. (And having a os.FileInfo replacement with errors on every method would be 1) very annoying to use 2) not match the reality, you'd end up checking the error multiple times for one syscall.)

@diamondburned 

> The os.FileInfo interface could then just not store anything and do an Lstat every time it needs that piece of information.

Can't, it has no way to communicate errors.



Repeating earlier suggestion, more concretely:

```
os.File.ReadDir(ReadDirOptions{...})

type ReadDirOptions struct {
    Number int    // like current argument n
    // Bitmap of Fields to include in the response.
    // Zero value means all fields, pass InfoFieldName
    // to only get names. Fields not included here
    // will return zero values from FileInfo methods.
    Fields InfoField
    Unsorted bool
}

type InfoField int

const (
    InfoFieldName InfoField = 1 << iota
    InfoFieldSize
    InfoFieldMode
    InfoFieldModTime
    // IsDir is included in Mode. No, getdents d_type
    // is not enough to serve FileInfo.IsDir (or Mode),
    // because it can be DT_UNKNOWN. It can be
    // exposed separately, for callers that can handle it.
    InfoFieldSys // this might finer control, per-platform?
)
```

If this is going to be used for pluggable filesystems (https://github.com/golang/go/issues/41190), then it would probably be nicer to find a way for each filesystem to be able to control FS-specific extensions to FileInfo, instead of using a bitmap with stdlib-decided values. That would serve `InfoFieldSys` above, too. Regardless, the above would be the information needed to be expressed by stdlib, as far as I understand things.

--- Comment #12 by diamondburned ---
@tv42 This API seems too convoluted comparing to the current API. It also introduces an inconsistency between `Readdir` and `ReadDir`, which doesn't make sense.

--- Comment #13 by tv42 ---
@diamondburned fixing the spelling of Readdir is part of https://go.googlesource.com/proposal/+/master/design/draft-iofs.md

--- Comment #14 by tv42 ---
@networkimprov `DirEntry.Load` is okay for something that looks exactly like `lstat(2)`, but there are many cases where the FS would benefit from knowing up front whether those attributes would be needed or not. Chasing a `ReadDir` with `entry.Load(fields)` does not avoid the seek and round-trip penalty, except perhaps by luck in caching; all the `entry.Load` does is let the current `getdents+lstat` world avoid an lstat, sometimes.

--- Comment #15 by diamondburned ---
I'll make a second attempt.

What if we make `ReadDir` return a new mini-interface derived from a section of `FileInfo`, or more specifically, the `Name` and `IsDir` methods? Concretely, it would be this interface:

```go
// DirEnt describes a directory entity.
type DirEnt interface {
    Name() string
    IsDir() bool
    Lstat() (FileInfo, error)
}

var _ DirEnt = (*dirEnt)(nil)

func (f *File) ReadDir(n int) ([]DirEnt, error)

// Windows impl:
func (e *dirEnt) Lstat() (FileInfo, error) {
    return e.finfo, nil
}

// Unix impl:
func (e *dirEnt) Lstat() (FileInfo, error) {
    return lstat(e.name)
}

// Custom impl where getting a FileInfo wouldn't error:
func (e *dirEnt) Lstat() (FileInfo, error) {
    return e, nil
}
```

This new `DirEnt` mini-interface should accommodate both the error handling required for `Lstat` on Unix as well as being relatively cheap on Windows.

--- Comment #16 by networkimprov ---
@tv42 your fields argument is in my `ReadDir()` :-)

 I've added a _Rationale_ section to https://github.com/golang/go/issues/41188#issuecomment-686283661 describing cases for the `DirEntry` API.

I drafted that API after a careful reading of all discussion on this issue, and believe it maximizes performance and usability.

--- Comment #17 by tv42 ---
@networkimprov Your API suggestion chases readdir with reading the stats, my API suggestion gives readdir the information needed to do the right thing. I believe a FS should have the fields up front, to be able to fetch them during the directory reading, and doing that afterward will never be the same. I'm not sure I can use more words to describe that again, and you seem to have completely skipped over the difference.

--- Comment #18 by networkimprov ---
You misunderstood. https://github.com/golang/go/issues/41188#issuecomment-686283661 allows both
a) `ReadDir(path, n, a|b)` to request fields _a_ & _b_ for _n_ items (your plan), and
b) `item.Load(a|b)` to request fields for a specific item after `ReadDir(path, n, 0)` retrieves it.

Each approach performs better in certain cases, listed in _Rationale_.  (Either way, all OS-default fields are provided, even if not requested, as it's no extra overhead.)

--- Comment #19 by tv42 ---
@networkimprov Oh I missed the `opt` argument to ReadDir there. Apologies.

--- Comment #20 by networkimprov ---
I filed #41265. It offers a new ReadDir() API for io/fs.

--- Comment #21 by rsc ---
I intend to do a survey of actual uses in the Go corpus, but I haven't finished it yet.



--- Comment #22 by rsc ---
I grepped through my Go corpus for Readdir/ReadDir calls. That turned up about 55,000 calls. See readdirs.txt, attached.

I randomly sampled 200 calls from that set; 6 were false positives (comments, functions named ReadDir but not the one we are talking about, and so on), and I randomly sampled 6 more to get back to 200 real samples. I classified all 200 samples, looking at how the result of ReadDir was used.

Of the 200 uses of ReadDir, the breakdown is:

 - 35 never called any method on any returned FileInfo. They only cared about the number of results or whether an error was returned.
 - 90 called only the Name method on returned FileInfos.
 - 52 called only the Name and IsDir methods on returned FileInfos.
 - 23 called other methods as well.

Of the 200, **none** of them saved the FileInfo slice for some future use. They all looked at the results immediately, meaning they would not have a chance to observe file system modifications sequenced between the ReadDir and the method calls. 

Also, 35+90+52 = 177/200 = 88% of the calls would end up with no delayed (lazy) Stat calls at all - they never call any methods other than Name and IsDir. Those would be made much faster (and also guaranteed never to see any kind of race or inconsistency, since they never call any of the “extra work” methods).

This gives an estimate, to within maybe 0.5%, that about 88% of programs would get faster with no possibility of noticing the laziness.

And about 12% would run about the same speed, invoking the lazy extra work. These would not see lazy inconsistencies caused by any of their own actions, but they might notice zeroed modification times or sizes if files are being deleted out from under them by other processes (likely rare).

Again, best estimate, to within about 0.5%:

 - 88% get much faster and are _guaranteed_ not to see the difference.
 - 12% stay about the same and only see the difference if another process is doing racing modifications to the file system.
 - 0% of Go programs would ever see a difference they caused themselves.

If you want to see my work, see the #-prefixed notes in readdir200.txt, also attached.

Overall, it seems like a low-risk large win. I'm particularly happy about the number of programs that just start working much faster with no rewriting required.

[readdir200.txt](https://github.com/golang/go/files/5206022/readdir200.txt)
[readdirs.txt.gz](https://github.com/golang/go/files/5206024/readdirs.txt.gz)


--- Comment #23 by networkimprov ---
125/200 = 63% of the cases would get faster by switching to `os.Readdirnames()`. Could _go vet_ flag those?

Readdir Docs: "... returns a slice of ... FileInfo values, **as would be returned by Lstat**..." Doesn't the proposal break this contract?

If any path component of the directory itself is renamed after `ReadDir()`, wouldn't every `FileInfo` result produce bad metadata?

This is considered bad form: `fi, _ := os.Lstat(name)` Why is it acceptable here?

Is 0.36% a representative sample size?

--- Comment #24 by mpx ---
I have code that stores `os.FileInfo` for later comparison via `os.SameFile`. Similar purpose to "tail" - it's used to detect if the file has been replaced at a later time. I agree this is an uncommon usage.

I think most people would find the deferred stat violates their default mental model for this API - especially based on past experience. It's doubly weird since their is no way to observe failures (eg, file not found). It would be a particularly awkward compromise/wart to add to such a core part of the standard library.

I've wished there was a faster common API for processing directory entries in the past. However, deferring stat would still be my last choice after:
   1. Providing a new API with a different name and better behaviour (maybe something like: `ReadDirent(n int) ([]Dirent, error)`)
   2. Using/implementing a different package when performance is critical
   3. Accepting Readdir is slow and waiting until a better solution comes along, or maybe even a redesigned /v2 package

This seems like a case where it would be better to take time to see if there is a better solution?

--- Comment #25 by tv42 ---
I want to be very clearly on record that I think the design of silently returning 0 size on errors is a *horrible* idea. None of the existing "faster than stdlib" things has that design, *for a good reason*. No amount of statistics will change that; it's a fundamentally incorrect design, no matter whether it's only possible to observe in X% of programs or not. This idea goes against the whole ethos of Go's explicit error handling, and I'm frankly shocked that it's considered viable.

All you need to make that *safe* and *correct* is for ReadDir to take an extra bit of "do you want the extra FileInfo fields or not". Then it can skip the lstat *when it's safe*. Or split it into ReadDirent and ReadDir, where only latter provides full FileInfos.

--- Comment #26 by bcmills ---
@tv42, would it make you feel better if `Size()` returned `-1` instead of `0`? That would at least be distinguishable from a valid size.

(But there isn't really anything similar to be done for `Mode`, since we can't set each individual bit to an obviously-bogus value.)

--- Comment #27 by rasky ---
I'd strongly prefer -1 rather than 0. We could also define a special modebit for "stale FileInfo".

I'll be on record to say this is a bad idea as well. It's not clear why we are designing a new FS abstraction and inheriting what is clearly a mistake of the past. The only reason I see is that this is rushed to have embed.Files in 1.16, and this lazy FileInfo is probably the only solution not to miss the 1.16 deadline. I'm not sure it's a good idea.

--- Comment #28 by diamondburned ---
I'd still say that the better solution would be the first option that @mpx has listed, that is to [provide a new API that returns a list of Dirents](https://github.com/golang/go/issues/41188#issuecomment-686903349). Existing code will not get that free performance boost regarding `Readdir`, however, but I think this should at least allow a more efficient `filepath.Walk`. It will also allow for much more explicit error handling.

--- Comment #29 by ianlancetaylor ---
I'm not sure how I feel about this idea overall, but we could indeed add an error return to `Mode`, by defining `ModeError` as a new bit.

--- Comment #30 by bcmills ---
@ianlancetaylor, I'm not sure that a `ModeError` would help much — in order to check for it you would already need to know about it, and existing code that does not know about it is not likely to change its behavior when `ModeError` is set.
