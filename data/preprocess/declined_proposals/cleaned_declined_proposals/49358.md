==== [Issue Title] ====
proposal: go test -errfuzz flag to randomize error strings

==== [Issue Body] ====
## Problem

On GitHub, there are too many projects that strictly compare error strings outside of test code: [`.Error() == "..."](https://sourcegraph.com/search?q=context:global+timeout:1m+lang:go+-file:_test.go%24+-file:%5Evendor/+.Error%28%29+%3D%3D+%22...%22&patternType=structural)

[Go 1 and the Future of Go Programs](https://golang.org/doc/go1compat) does not explicitly promise that error strings are protected, nor do we want to encourage this amongst third-party libraries. See @neild’s https://github.com/golang/go/issues/49172#issuecomment-954071349.

## Proposed Implementation

Add an -errfuzz test flag that implements the following help:
```
	-errfuzz
	    Randomize error strings formatted by errors.New and fmt.Errorf
	    with randomly inserted zero-width non-printing characters.
```

## Concerns

- Users who run `go test -errfuzz` without realizing it may be confused if an error string looks like it matches another string, but is actually not-equal.
- Should there be an argument, like `-shuffle` has, to control the random seed?

## See also

- #49356 which is a related analysis that can catch this problem when it isn’t covered by tests.

==== [Comments] ====

--- Comment #1 by dsnet ---
I don't see how we can avoid false positives where a package is using `errors.New` and `fmt.Errorf` in such a way where it is appropriate for users to depend on the error message (e.g., the package guarantees that the message will be formatted in a certain way).

Instead, perhaps fuzz should specify some build tag [1] and packages can check for that build tag to specify a higher degree of randomization in their output.

[1] It might already do this. I'm a bit behind on the latest on what's going on with the fuzzing work.

--- Comment #2 by sfllaw ---
> Instead, perhaps fuzz should specify some build tag [1] and packages can check for that build tag to specify a higher degree of randomization in their output.

I think I might have chosen a bad name for this flag. It is not related to the [First Class Fuzzing](https://golang.org/s/draft-fuzzing-design) work.

I would be happy to use a clearer name for this flag.

--- Comment #3 by sfllaw ---
> I don't see how we can avoid false positives where a package is using `errors.New` and `fmt.Errorf` in such a way where it is appropriate for users to depend on the error message (e.g., the package guarantees that the message will be formatted in a certain way).

Are you concerned about the case where an upstream library makes the error string part of the package’s API, and also requires that downstream programs parse the actual error strings to handle errors. In this situation, the downstream test suite will fail when run with the -errfuzz flag?

Given that we want to discourage this practice, a determined upstream could use another errors package, like [x/exp/xerrors](https://pkg.go.dev/golang.org/x/exp/xerrors), that is unaffected by -errfuzz? Or would that be asking too much?

Alternatively, upstream could just convert their opaque error strings into wrapped errors, with no loss of backwards-compatibility.

I do realize that xerrors isn’t a proper drop-in replacement, but that could be addressed by writing an errors package that behaves exactly like the standard one with -errfuzz turned off.

--- Comment #4 by cristaloleg ---
As I understood it will be enough to find all (or similar) expressions to `strings.Contains(err.Error(), "some pattern")` ?

--- Comment #5 by sfllaw ---
> As I understood it will be enough to find all (or similar) expressions to `strings.Contains(err.Error(), "some pattern")` ?

@cristaloleg I think you want to check out #49356 if you’re suggesting some kind of analysis pass that searches through code. I can think of lots of common ways that programmers can parse an error string, in an attempt to handle that error condition.

--- Comment #6 by rsc ---
It is _not_ forbidden to look at error strings or compare them. We do that all the time in the standard library tests, for example. Totally fine in some cases!

This would break valid code, and therefore we should not do it.


--- Comment #7 by sfllaw ---
@rsc
> It is _not_ forbidden to look at error strings or compare them. We do that all the time in the standard library tests, for example. Totally fine in some cases!

#49172 was rejected because we don’t want to encourage error string comparisons in test cases, so the logical conclusion is that they should be rare.

So for tests where you really do want to do error string comparisons, could we not ask the author to be intentional?

``` go
const wj = "\u2060" // WORD JOINER used by -errfuzz
func unfuzzerr(err error) string {
	return strings.Replace(err.Error(), wj, "")
}

func TestErr(t *testing.T) {
	wantErr := "something failed"
	err := doSomething()
	if unfuzzerr(err) != wantErr {
		t.Errorf("err %v, want %v", err, wantErr)
	}
}
```

The standard library does one error string comparison outside of its tests, in [os/exec/exec_plan9.go:17](https://cs.opensource.google/go/go/+/refs/tags/go1.17.3:src/os/exec/exec_plan9.go;l=17), but that error shouldn’t be affected because it is not generated by errors.New.

> This would break valid code, and therefore we should not do it.

This would be opt-in, so developers who run `go test -errfuzz ./...` are ones who want to clean up their error handling. 

Are you concerned that about breaking third-party libraries that have internal error string comparisons? If I import one of those libraries, wouldn’t it be better if I discovered that this library can be broken by an innocent change to an error string?

--- Comment #8 by sfllaw ---
One alternative to consider: fmt.Errorf could be constrained so it only inserts random characters it is wrapping an error with %w, and not %v, since that implies that a string comparison is inappropriate.

The tradeoff is that this would make the -errfuzz flag more complicated to reason about.

--- Comment #9 by rsc ---

This proposal has been added to the [active column](https://golang.org/s/proposal-status#active) of the proposals project
and will now be reviewed at the weekly proposal review meetings.
— rsc for the proposal review group


--- Comment #10 by rsc ---

Based on the discussion above, this proposal seems like a **[likely decline](https://golang.org/s/proposal-status#likely-decline)**.
— rsc for the proposal review group


--- Comment #11 by sfllaw ---
@rsc This seems unlikely to work well, but it was an interesting discussion. Please decline.

--- Comment #12 by rsc ---

No change in consensus, so **[declined](https://golang.org/s/proposal-status#declined)**.
— rsc for the proposal review group

