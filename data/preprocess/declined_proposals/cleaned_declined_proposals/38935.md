==== [Issue Title] ====
proposal: encoding/json: debug printing

==== [Issue Body] ====
I apologise if any of this is incorrect.

---

I would like to be able to provide a `,debug` flag in a struct tag, which would instruct the `encoding/json` library to print out any data marshaled/unmarshaled to/from that field, like so:
```go
type Test struct {
    SomeField interface{} `json:"some_field,debug"`
}
```

This would be especially useful for writing client libraries, where some fields may be undocumented, and having logs of the values you get can help reverse-engineer things.

Using the builtin `println` function makes sense for this, in my opinion.

---

I started making a basic attempt at implementing this with custom MarshalJSON/UnmarshalJSON methods, but quickly realised that I would basically have to implement cases for every type that `encoding/json` already supports.

I then attempted to modify `encoding/json` to support this, and found myself unable to locate the code relevant to checking flags, particularly in unmarshaling.

---

Any thoughts or tips on implementing this would be appreciated, as I intend to create a PR for this once I've figured it out. :)

==== [Comments] ====

--- Comment #1 by ianlancetaylor ---
Can you give a short detailed example showing how this would be useful?  Thanks.

--- Comment #2 by superloach ---
If you're given data like...
```json
{
    "foo": 123,
    "bar": null,
    "baz": null
}
```
...then there's a pretty good chance that `"bar"` and `"baz"` *can* have values. Being able to log their values without having to write custom marshal/unmarshal methods would be convenient.

For example, you could write something like this...
```go
type Test struct {
    KnownField int `json:"foo"`
    UnknownFieldA interface{} `json:"bar,debug"`
    UnknownFieldB json.RawMessage `json:"baz,debug"`
}
```
... (showing use of either `interface{}` or `json.RawMessage`) and you would get the output...
```
json: wrote to field `UnknownFieldA`: `nil`
json: wrote to field `UnknownFieldB`: `null`
```
... or, if new data was provided...
```
json: wrote to field `UnknownFieldA`: `map[a:3.14]`
json: wrote to field `UnknownFieldB`: `{"a": 3.14}`
```

--- Comment #3 by ianlancetaylor ---
Why can't you just, you know, unmarshal into a variable of type `Test` and print the value?  You already have to edit the code to add the `,debug` tag anyhow.

--- Comment #4 by mvdan ---
I agree with Ian. If what you want to do is debug json's internals, then editing the json package itself to add debug prints is always possible. We could possibly make that easier with a global `const debug = false`, but flipping that would require editing the json package anyway.

--- Comment #5 by rsc ---
In general we don't add these kinds of debug/trace hooks to our packages. What if you wanted to debug the execution of math.Sin on a particular input? And so on. The answer is to copy and modify the code to check what you want to check.


--- Comment #6 by superloach ---
Ah yeah, sorry I forgot to close this. Trivial idea, looking back it's not really useful üòÅ
