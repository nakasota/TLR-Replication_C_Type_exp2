==== [Issue Title] ====
proposal: x/text/rangetable: lazy construction of RangeTables

==== [Issue Body] ====
### Background

There are a number of proposals centered around adding properties from Unicode Technical Reports to the unicode package. For example, https://github.com/golang/go/issues/34674 wants to add the identifier properties from [UAX #31](https://www.unicode.org/reports/tr31/). And https://github.com/golang/go/issues/45264 wants to add the emoji properties from [UTS #51](https://www.unicode.org/reports/tr51/).

However, Unicode [makes it clear](https://www.unicode.org/reports/about-reports.html) that conformance to the Unicode standard does not imply conformance to these technical reports. Additionally, we shouldn't require users to pull in properties they don't care about when importing the unicode package. For these reasons, I think it's best that these properties live outside the standard library. Potentially in `golang.org/x` or somewhere else.

Currently, the API for constructing a `RangeTable` given a pre-existing `RangeTable` only consists of `Merge`, which returns a completely new `RangeTable`. If we want the ability to construct these tables to conform to a TR, I claim that the current API is insufficient. Here's why:
1. The TRs specify some of these properties in terms of set operations. For example, the definitions of `ID_Start` and `ID_Continue` are:
```
ID_Start = [\p{L}\p{Nl}\p{Other_ID_Start}-\p{Pattern_Syntax}-\p{Pattern_White_Space}]
ID_Continue = [\p{ID_Start}\p{Mn}\p{Mc}\p{Nd}\p{Pc}\p{Other_ID_Continue}-\p{Pattern_Syntax}-\p{Pattern_White_Space}]
```
The current API does not have a way to subtract a RangeTable from a pre-existing one, so these definitions cannot be expressed.

2. The TRs specify some of these properties as a procedure for filtering a pre-existing property. For example:
```
XID_Continue(r) = ID_Continue(r) && NFKC(r) in "id_continue*"
XID_Start(r) = ID_Start(r) && NFKC(r) in "ID_Start XID_Continue*"
```
The current API doesn't offer a filter mechanism like this. In particular, NFKC normalization returns a string, so using that to create a new RangeTable is not possible in the current API.

3. `Merge` is an expensive operation. Because it returns a completely new RangeTable, we have no opportunity to tell it we want to defer constructing the RangeTable until all of the filters we want have been applied.

(As an anecdote, I ended up forgoing efficiency by using functions instead of operating directly on a RangeTable: https://github.com/smasher164/xid.)

### Proposal

Offer a lazy constructor for RangeTables. This type should allow specifying runes, set operations, filter functions, and returning the RangeTable at the very end.

```Go
// Builder offers lazy construction of RangeTables.
type Builder struct { ...unexported... }

// Add is the lazy equivalent to Merge.
func (b *Builder) Add(rt *unicode.RangeTable) *Builder

// Runes is like Add but provides precise control over runes added.
// This is useful for TRs like Emoji, in which some definitions list out
// specific codepoints that are used.
func (b *Builder) Runes(...rune) *Builder

// Sub is the set difference operator.
func (b *Builder) Sub(rt *unicode.RangeTable) *Builder

// Filter is like Sub but provides precise control over the runes removed.
// This is useful for TRs like Identifiers, in which runes are normalized
// before checking they belong to another property.
func (b *Builder) Filter(f func(rune) bool) *Builder

// RangeTable returns the completely constructed RangeTable. The implementation is
// free to group operations together, check each rune exhaustively, etc...
// (i.e. whatever it needs to be efficient).
func (b *Builder) RangeTable() *unicode.RangeTable

// Reset clears the state for a builder, allowing it to be reused again.
func (b *Builder) Reset() *Builder
```
Here's an example of how one might use this API to specify the Identifiers spec:
```Go
builder := new(rangetable.Builder)

// ID_Start = [\p{L}\p{Nl}\p{Other_ID_Start}-\p{Pattern_Syntax}-\p{Pattern_White_Space}]
ID_Start := builder.
	Add(unicode.L).
	Add(unicode.Nl).
	Add(unicode.Other_ID_Start).
	Sub(unicode.Pattern_Syntax).
	Sub(unicode.Pattern_White_Space).
	RangeTable()

// ID_Continue = [\p{ID_Start}\p{Mn}\p{Mc}\p{Nd}\p{Pc}\p{Other_ID_Continue}-\p{Pattern_Syntax}-\p{Pattern_White_Space}]
ID_Continue := builder.Reset().
	Add(ID_Start).
	Add(unicode.Mn).
	Add(unicode.Mc).
	Add(unicode.Nd).
	Add(unicode.Pc).
	Add(unicode.Other_ID_Continue).
	Sub(unicode.Pattern_Syntax).
	Sub(unicode.Pattern_White_Space).
	RangeTable()

// XID_Continue(r) = ID_Continue(r) && NFKC(r) in "id_continue*"
XID_Continue := builder.Reset().
	Add(ID_Continue).
	Filter(func(r rune) bool {
		for _, r := range norm.NFKC.String(string(r)) {
			if !unicode.Is(ID_Continue, r) {
				return false
			}
		}
		return true
	}).
	RangeTable()

// XID_Start(r) = ID_Start(r) && NFKC(r) in "ID_Start XID_Continue*"
XID_Start := builder.Reset().
	Add(ID_Start).
	Filter(func(r rune) bool {
		s := norm.NFKC.String(string(r))
		if s == "" {
			return false
		}
		for i, r := range s {
			if i == 0 {
				if !unicode.Is(ID_Start, r) {
					return false
				}
			} else {
				if !unicode.Is(XID_Continue, r) {
					return false
				}
			}
		}
		return true
	}).
	RangeTable()

```

Thoughts?
/cc @mpvl @robpike 

==== [Comments] ====

--- Comment #1 by rsc ---

This proposal has been added to the [active column](https://golang.org/s/proposal-status#active) of the proposals project
and will now be reviewed at the weekly proposal review meetings.
— rsc for the proposal review group


--- Comment #2 by mpvl ---
Note that `rangetable.Merge` is not really supposed to be efficient. It is mostly used to create the range tables in core and x/text as part of a `go generate`.

Also note that `x/text` hardly uses RangeTables. Instead it uses a trie generator instead. It looks like this may be more appropriate here as well, as it allows a set of flags ID_* flags to be associated per rune. This allows a single lookup instead of multiple (assuming that is what you need), and is generally more compact.

So making the `trie` infrastructure public may make more sense, as it is generally a better approach for most applications. This is especially true if it is likely that multiple properties need to be consulted per rune. In that case it can be significantly faster.

Finally, it is to also totally okay to add low-level packages with tables Unicode data to x/text. This has the distinct advantage that it is easier to ensure that the set of supported Unicode characters is consistent within an application.

In other words, instead of expanding the RangeTable functionality, adding the `unicode/emoji` and/or `unicode/identifier` utilizing the infrastructure present in `x/text` may be more helpful. 

Also, adding the RangeTable builder would increase the maintenance burden for x/text without a big benefit for this package, and generally pointing users in the wrong direction for solutions.

--- Comment #3 by smasher164 ---
> So making the trie infrastructure public may make more sense, as it is generally a better approach for most applications.

This proposal was centered around constructing these tables dynamically, but I agree that having an API that operates on sequences of bytes, as well as one that doesn't rely on dynamic allocation would be better. I may file a separate proposal around that if there's some consensus around how to treat emoji.

> Finally, it is to also totally okay to add low-level packages with tables Unicode data to x/text.

If that is something the x/ package maintainers are interested in, it may be the best way forward. As such, I'll withdraw this proposal given that there seem to be better options. Thanks for taking a look @mpvl!

--- Comment #4 by rsc ---

No change in consensus, so **[declined](https://golang.org/s/proposal-status#declined)**.
— rsc for the proposal review group

