==== [Issue Title] ====
proposal: spec: safe multidimensional array conversion

==== [Issue Body] ====
### Background
As of today, if one wishes to obtain backing slice for a multidimensional arrays one must use unsafe. Example ([also see go playground](https://go.dev/play/p/mP4G4ut2Lma))

```go
mat := [2][2]float64{
    {1, 2},
    {3, 4},
}
backing := (*[4]float64)(unsafe.Pointer(&mat[0][0]))
backingAlternative := (*[4]float64)(unsafe.Pointer(&mat))
```
Unsafe gets the job done but provides two disadvantages:
1. Marks widespread use of these conversions as unsafe. Today lots of code depends on the row-major ordering of elements in multidimensional arrays. It would be nice to standarize this behaviour.
2. Unsafe breaks some transpiler tools such as gopherjs


### Proposal
For better numerical programming facilities, such as those in gonum. It'd be handy to convert between matrix (multidimensional array) form and backing slice form without the use of `unsafe`. Example of how this could be implemented in the language:

```go
type backer *[4]float64
mat := [2][2]float64{ {1, 2}, {3, 4} }
backing := backer(&mat)
```
The code above eliminates the need to use unsafe. 

Other benefits:
When working with single dimension arrays that represent matrices, one could also convert to multidimensional form for better bounds checking
```go
type matForm *[2][2]float64
unidim := [4]float64{1, 2, 3, 4 }
mat := matForm(&unidim)
mat[1][0] = 0
mat[2][1] = 3 // Compiler error!
```

### Final notes
I wonder if it would be possible to convert in a single line

```go
mat := [2][2]float64{ {1, 2}, {3, 4} }
backing := (*[4]float64)(&mat) // is this too much?
```




==== [Comments] ====

--- Comment #1 by seebs ---
I am in favor of being able to make the conversion, I wouldn't mind if it were more marked than a conversion that isn't such a translation.


--- Comment #2 by deltamualpha ---
```
type backer *[3]float64
mat := [2][2]float64{ {1, 2}, {3, 4} }
backing := backer(&mat)
```

This would be a compiler error? or is the leftover int unreferenceable?

--- Comment #3 by soypat ---
@deltamualpha I'd stick to reversible conversions for this proposal, as that's what I find to be of use. Having leftover data might make for some interesting pitfalls...

--- Comment #4 by mpx ---
Good timing - I hit this again yesterday. It would have been useful to convert a 2D array to 1D for some mutations. Enabling processing all entries without needing the overhead/complexity for 2 loops.

--- Comment #5 by ianlancetaylor ---
The proposal refers to "backing slice form" but none of the types are slice types.  To be precise, I think that the proposal here is that given a type `A1` which has the form `[N1][N2]E` and a type `A2` which has the form `[N]E`, where `N == N1 * N2`, we permit an explicit conversion from `*A1` to `*A2`, and vice-versa.

Is that correct?

Do we also permit conversions between pointers to `[N1][N2][N3]E` and `[N]E` where `N == N1 * N2 * N3`, and so on for any number of array dimensions?

Do we also permit conversions between pointers to `[N1][N2]E` and `[N3][N4]E` where `N1 * N2 == N3 * N4`?

Thanks.

CC @dadkins @btracey as there are similarities to #6282.

--- Comment #6 by soypat ---
Hey Ian. yes, your clarification seems to better describe what I mean. As for your suggestions: I see them to be in line with what this proposal seeks to do. They also seem sane.

--- Comment #7 by rsc ---

This proposal has been added to the [active column](https://golang.org/s/proposal-status#active) of the proposals project
and will now be reviewed at the weekly proposal review meetings.
— rsc for the proposal review group


--- Comment #8 by rogpeppe ---
Another possible (but useful!) variant might be to allow conversion from `[][N]E`, say `a`, to `[]E`, say `b`, where `len(b)` = `len(a) * N`. This could also be supported for multidimensional arrays too.

--- Comment #9 by ianlancetaylor ---
@rogpeppe Bringing in slices seems to make this more complex and subtle.  E.g., appending to the resulting slice will not necessarily do the right thing.  My initial inclination would be to stick to array pointers, and let anybody who wants slices write their own slice expressions.  Admittedly that doesn't work for your example, but I'd like to know whether that example actually arises.

--- Comment #10 by rogpeppe ---
> appending to the resulting slice will not necessarily do the right thing.

FWIW I'd semantics I was imagining would make the returned slice have the same capacity as length, so appending would always allocate.

> I'd like to know whether that example actually arises.

The specific example that came to mind was specifying a set of pixels as `[][3]byte` (a slice of RGB pixel values) vs `[]byte` (a framebuffer).

In general, I suspect it's not uncommon to have arrays where the minor dimensions are known but the major dimension is unknown, and a desire to operate on elements of them uniformly (for example to pass them to some efficient vector calculation engine).

@kortschak might well have some thoughts here.


--- Comment #11 by kortschak ---
I'm leaning towards Ian's position. I think that the `[][n]T` case is going to be very rare and it easily handled with code written by the user. The case that's the basis for this proposal can't be without using unsafe conversions.

--- Comment #12 by kortschak ---
> Do we also permit conversions between pointers to `[N1][N2]E` and `[N3][N4]E` where `N1 * N2 == N3 * N4`?

I would like not to (for the sake or clarity of intention), though the user can always do that through an intermediary linear array.

--- Comment #13 by rogpeppe ---
> I'm leaning towards Ian's position. I think that the `[][n]T` case is going to be very rare and it easily handled with code written by the user.

I think you're probably right about this not being worth doing, but for the record, are you saying that the above conversion can easily be done without using unsafe? If so, how? It wasn't obvious to me that it was possible.

--- Comment #14 by kortschak ---
Sorry, yes, I was thinking in unsafe and didn't notice. You either need to use `unsafe.Slice` or know the major dim ahead of time.

--- Comment #15 by rsc ---
It's obviously safe to convert `*[N][M]int` to `*[N*M]int`, but how often does this come up?
The vast majority of programs won't have constant-sized arrays.
Is this only going to get used for converting between [2][2] and [4]?
Is it going to happen enough to justify having a special case in the language instead of having that code use unsafe?



--- Comment #16 by kortschak ---
This issue that prompted this is that there are some situations where unsafe is not an option (@soypat has looked into this, but from memory, gopherjs was one).

--- Comment #17 by changkun ---
> but how often does this come up?

https://github.com/search?q=np.flatten&type=code

--- Comment #18 by kortschak ---
@changkun That's sort of misleading because of the way that matrices are _usually_ represented in Go (with slices rather than arrays - which is @rsc's point). The issue is that there are some things that are just not possible without unsafe if this language change is not allowed.

--- Comment #19 by soypat ---
```go
mat := [2][2]int{{1, 2}, {3, 4}}
flat := (*[4]int)(unsafe.Pointer(&mat))
fmt.Println(flat)
```
~I've tested the above program with `gopherjs` and it seems to work. I was under the impression unsafe was not supported but it does seem to be supported now.~ There are however other projects that would benefit from this change such as [`gomacro`](https://github.com/cosmos72/gomacro#current-status), which is used in high profile Go projects such as [gophernotes](https://github.com/gopherdata/gophernotes). gomacro currently does not support any use of unsafe.

The use case I had in mind was for fixed-size matrix libraries such as [gonum/gonum/spatial/r3](https://github.com/gonum/gonum/blob/master/spatial/r3/mat.go) which I have been using for rigid body motion simulation and for 3D visualization using gopherjs (hence my aforementioned worry).

If this was not added to the spec then I would ~**not**~ suffer ~as I can run the program above in gopherjs with no problems~. I do think it is of interest for it to be in the language since there is a use case for it and removing unsafe usage would allow scientific package authors to write better fixed-size matrix packages which can then be readily adopted by users of gophernotes, which seem to be predominantly oriented towards the scientific computation scene.

**EDIT**: I was wrong, the program compiles with no error but the values of the "flattened" array are all zero. unsafe is not supported by gopherjs

--- Comment #20 by rsc ---
Given that you can already do this with unsafe, it seems like an alternate avenue would be for gopherjs to just improve its implementation of / restrictions on unsafe and make this work:

```
mat := [2][2]int{{1, 2}, {3, 4}}
flat := (*[4]int)(unsafe.Pointer(&mat))
fmt.Println(flat)
```

If for some reason that's problematic to do in gopherjs, then I don't see how it would implement a language change that did the same thing.

It's unclear that a language change is needed here.


--- Comment #21 by kortschak ---
I don't see how this argument is consistent with the addition of slice to array pointer conversion that was accepted; that operation was also readily doable using unsafe and yet was added, even with decoration to allow making new non-pointer values to save a star.

~My concern here is that in the context that prompted this issue, we have build tags to allow users to build Gonum without the use of unsafe. This is a repo-wide option and so I have added it here. However, it is not possible to retain the same semantics without the use of unsafe. So this will put us in the position of either having a discordant build experience by not providing a safe build option for this package or opening ourselves up to fielding bugs that users write due to the differing semantics between the two cases.~ Pointed as as being not-true for the case in point.

--- Comment #22 by ianlancetaylor ---
@kortschak Specific examples of usage definitely help.  Above @soypat mentioned  "github.com/gonum/gonum/spatial/r3".  That package does have safe and unsafe versions.  If I'm reading this right, once the package is able to use the new slice-to-array-pointer conversion, the remaining unsafe use is:

```Go
type Mat struct {
	data *array
}

type array [3][3]float64

func (m *Mat) slice() []float64 {
	return (*[9]float64)(unsafe.Pointer(m.data))[:]
}
```

The `slice` method is used to share the array with other data structures like `mat.Dense`.

--- Comment #23 by kortschak ---
@ianlancetaylor Thanks for getting me to look back at that. Yes, I had misremembered what I had done to work around this. With array pointer conversion [the modified semantics](https://github.com/gonum/gonum/blob/735c35c056147633be5950a4195f0c2091ce5b00/spatial/r3/mat_safe.go#L130-L138) will go away. I think I remembered being irritated at the degree of code near-duplication that was necessary to work around this and sublimated that onto a mis-recollection of not being possible without unsafe. My first paragraph stands though.

--- Comment #24 by rsc ---
It doesn't seem like the situation has changed since https://github.com/golang/go/issues/50118#issuecomment-1011343076.

@kortschak, we understand that you can't do, say, a \*[3][3]int to \*[9]int conversion today without unsafe, but you _can_ do it, by using unsafe. Using unsafe is OK. 

The big question is how often this arises. We decided the slice to array pointer conversion happened enough that it was worth adding the special case. The problem here is that the need for compile-time-constant array sizes means that it seems like this _doesn't_ happen enough. And it's still possible with unsafe when it does happen.



--- Comment #25 by kortschak ---
@rsc Sure, using unsafe is OK, and tbqh using unsafe is something that I rather enjoy.

However, users sometimes want packages with no direct use of unsafe (yes, there will be unsafe in the dependency graph via std) which means that we need to provide safe alternatives. It's entirely possible that these sentiments exist for historical reasons from when some significant runtimes did not allow the use of unsafe outside std or did not properly support it; if that's the case community education would help. But in the meantime it means that things like this where the only option is to use unsafe require significant convolution and duplication to work around.

--- Comment #26 by rsc ---
For right now it seems like we don't have the evidence that this is important enough to make a special case in the language for. Using unsafe is supported everywhere Go runs now (even App Engine, which was the originally motivation). It sounds like gopherjs has a bug, but that's independent of whether we change the way the conversion is written.



--- Comment #27 by rsc ---

Based on the discussion above, this proposal seems like a **[likely decline](https://golang.org/s/proposal-status#likely-decline)**.
— rsc for the proposal review group


--- Comment #28 by kortschak ---
@rsc On the basis of [this assertion](https://github.com/golang/go/issues/50118#issuecomment-1022486900), would it then be reasonable to then drop all `//go:build safe`/`//go:build !safe` duplications in projects broadly? These only existing to provide code for users that do not want non-stdlib use of unsafe.

--- Comment #29 by rsc ---
@kortschak We have a pure_go but I don't remember a safe. There is some question about whether pure_go is still relevant. Feel free to file an issue if you think we should drop it.


--- Comment #30 by rsc ---

No change in consensus, so **[declined](https://golang.org/s/proposal-status#declined)**.
— rsc for the proposal review group

