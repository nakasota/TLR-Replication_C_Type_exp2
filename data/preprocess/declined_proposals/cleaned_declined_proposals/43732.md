==== [Issue Title] ====
proposal: reflect: add allocation-free variant of Value.Call

==== [Issue Body] ====
At present, `Value.Call` for any function with any return arguments is slow because it needs to:
1. allocate a [stack frame for the underlying return values](https://github.com/golang/go/blob/ec9470162f26819abd7b7bb86dd36cfe87f7f5bc/src/reflect/value.go#L443)
2. allocate a [`[]Value` for the return Values themselves](https://github.com/golang/go/blob/ec9470162f26819abd7b7bb86dd36cfe87f7f5bc/src/reflect/value.go#L494)

This is unfortunate since calling a function that returns any arguments is likely the common case. The aforementioned allocations cannot be eliminated because the current API `Value.Call` pretty much requires that the implementation be responsible for allocating the return arguments.

I propose a new `CallWith` (or any other suggested name) method with the modified signature:
```go
func (v Value) CallWith(out, in []reflect.Value)
```
where:
* the `in` argument is identical to that for `Call`
* the `out` argument must be a slice where `len(out) == v.NumOut()`.
  * If `out[n]` is a [valid](https://golang.org/pkg/reflect/#Value.IsValid), [settable](https://golang.org/pkg/reflect/#Value.CanSet) value where `v.Out(n).AssignableTo(out[n].Type())`, then `CallWith` uses the existing value to store the output (with `Value.Set`). 
  * Otherwise, `CallWith` allocates new underlying storage for a new `reflect.Value` and stores that into `out[n]`.

With this API, I believe it is theoretically possible to have an allocation-free version of `Value.Call`.

The description above only proposes `CallWith` as an optimized version of `Call`. You can imagine a `CallSliceWith` as an optimized version of `CallSlice`.

\cc @mvdan @rogpeppe

==== [Comments] ====

--- Comment #1 by ianlancetaylor ---
I don't mind the idea but I'm not fond of the name.  Can we do better than `CallWith`?  That doesn't really convey anything to me.

--- Comment #2 by gopherbot ---
Change https://golang.org/cl/284222 mentions this issue: `reflect: add Value.CallWith and Value.CallSliceWith`

--- Comment #3 by dsnet ---
[Using this benchmark](https://play.golang.org/p/2v_ljoK9hH8) and [CL/284222](https://golang.org/cl/284222), we achieve a runtime reduction of 1.5x:
```
name    old time/op    new time/op    delta
Call-8     454ns ± 8%     302ns ± 1%   -33.49%    (p=0.000 n=9+9)

name    old alloc/op   new alloc/op   delta
Call-8      280B ± 0%       0B ±NaN%  -100.00%  (p=0.000 n=10+10)

name    old allocs/op  new allocs/op  delta
Call-8      2.00 ± 0%     0.00 ±NaN%  -100.00%  (p=0.000 n=10+10)
```

--- Comment #4 by rsc ---
Closing as duplicate of #49340 (yes, it was filed second, but we ended up with it in the active column first).

