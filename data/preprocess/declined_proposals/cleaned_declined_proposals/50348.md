==== [Issue Title] ====
proposal: constraints: rename package to "of"

==== [Issue Body] ====
snippet code
```
func Abs[V of.Number](v V) V{...}

func Sum[K comparable, V of.Number](m map[K]V) V {...}

```
it is simple and smooth to type the word "of" better then "constraints"

==== [Comments] ====

--- Comment #1 by davecheney ---
There seems to be a pattern; the `strings` package contains symbols that relate to strings, the `bytes` package contains symbols that relate to slices of bytes, so the `of` package contains symbols related to, uh, prepositions?

But seriously, if you think it reads better, you can rename the import thusly
```
import of ‚Äúconstraints‚Äù
```

--- Comment #2 by robpike ---
Too bad `any` is taken because `any.Integer` or `any.Comparable` reads nicely.

--- Comment #3 by fzipp ---
My suggestion was `is`, because it contains the essence of types (lat. esse = to be): `is.Integer`, `is.Comparable`, `is.Ordered`.

--- Comment #4 by robpike ---
Bikeshed entry number 4:`some`: `some.Integer`.

I do agree with the implication of the original comment that 'constraints' feels cumbersome.

--- Comment #5 by zephyrtronium ---
The name of the package [was brought up](https://github.com/golang/go/discussions/47319#discussioncomment-1034208) (as @fzipp mentioned) in discussion, and @rsc marked it as resolved. I agree "constraints" is quite long, but I don't see what's changed.

--- Comment #6 by panyox ---
> 

definitely agree, "constraints" is cumbersome, hope the go team make some change in the future

--- Comment #7 by zigo101 ---
Is it a good idea to make them all pre-declared?

--- Comment #8 by ianlancetaylor ---
> Is it a good idea to make them all pre-declared?

Not in my opinion.  It's possible to write these in the language (which is a good thing), so there is no reason to predeclare them.

--- Comment #9 by earthboundkid ---
My vote at the time of the discussion was `types`, but sadly, it seems the :ship: has sailed.

--- Comment #10 by cristaloleg ---
`anyof` ? üëÄ  `anyof.Number`, `anyof.Ordered`.

--- Comment #11 by Warmbellycat ---
```
import isA ‚Äúconstraints‚Äù

isA.Number
isA.Ordered
```

--- Comment #12 by zhuah ---
how about `std`? i like this, short, means standard but not builtin. 
like cpp and rust, they also has a std namespace or crate.


--- Comment #13 by zhuah ---
maybe someday we will adds some types like `Optional[T]` and `Result[T, E]`, these types will have their own methods,
then which package should them be added in? `constraints` or `types` or just builtin, etc..

--- Comment #14 by mvdan ---
@zhuah std is already taken; see: go list std

--- Comment #15 by bitfield ---
> if you think it reads better, you can rename the import thusly

Dave is pleased to joke, but you absolutely shouldn't do that.

--- Comment #16 by seanmrnda ---
> > 
> 
> definitely agree, "constraints" is cumbersome, hope the go team make some change in the future

just use an alias

--- Comment #17 by zhuah ---
@mvdan thank you for clarification, i almost forgot it.


--- Comment #18 by ianlancetaylor ---
I think it's worth considering that in my experience so far the most commonly used identifier in the package currently named "constraints" is `Ordered`.  `of.Ordered` doesn't read very well to me.  Of the names suggested above and at https://github.com/golang/go/discussions/47319#discussioncomment-1034208 the only plausible alternative I see to date is "is".

--- Comment #19 by mvdan ---
If we want to avoid the ambiguity of `import "is"`, we could also consider `import "constraints/is"`.

--- Comment #20 by dotaheor ---
I prefer `import . "constraints"`.

```
func Abs[V Number](v V) V{...}

func Sum[K comparable, V Number](m map[K]V) V {...}
```

--- Comment #21 by smasher164 ---
On their own, the package names `any`, `of`, and `some` don't indicate any meaning. It's only after seeing them in conjunction with `.Number` that their meaning is apparent. `constraints` may be cumbersome to type, but both for documentation/package discovery and reading someone else's code, it's a lot clearer.

--- Comment #22 by fzipp ---
> On their own, the package names `any`, `of`, and `some` don't indicate any meaning. It's only after seeing them in conjunction with `.Number` that their meaning is apparent.

From the Go blog on package names: 

_"A package name and its contents' names are coupled, since client code uses them together. When designing a package, take the client‚Äôs point of view."_

Take `sort.Interface` as an example. Here the type name `Interface` by itself doesn't mean a lot. Only the combination of both the package name and the type name creates the meaning.

> `constraints` may be cumbersome to type, but both for documentation/package discovery and reading someone else's code, it's a lot clearer.

Re readability: Reading the package name `constraints` in a piece of code like `[T constraints.Ordered]` doesn't add any information. Of course it's a constraint, because it's used in the constraint position. If anything, its dominating lengthiness distracts from the more important rest.

Re documentation/discovery: Every package has a short description that is displayed in the package overview https://pkg.go.dev/std and in the documentation of the package itself. This is discoverable via search engines and Ctrl+F.

There is no shame in short package names if they are expected to be used a lot. The popular string formatting package was named `fmt`, not `format` or `formatting`, which would be "clearer" if explicitness was the only guiding principle.

--- Comment #23 by zigo101 ---
Code cleanness is a big advantage of Go. We should not forget this. 

--- Comment #24 by smasher164 ---
@fzipp

> Take sort.Interface as an example. 

Okay, but here we have the opposite situation. `Interface` is a symbol defined in the package `sort`, while `of`/`any`/`is` are package names themselves. Apart from dot imports (which are mostly discouraged), `Interface` can't be referenced without some qualifier.

Also, `sort` actually conveys meaning. In fact, all of the examples you gave convey the purpose of the package. I agree there is some grey area for short package names that are used a lot, but I think `of`/`any`/`is` are just _far_ too vague.

--- Comment #25 by mibk ---
These are my bikeshed entries:

- `ofkind.Integer`
- `only.Integer`

> Too bad `any` is taken because `any.Integer` or `any.Comparable` reads nicely.

In addition to the name "constraints" being cumbersome I also think
it's unfortunte that the constraint `comparable` is a builtin type
while other "general" constraints are not. I would lean towards
either making all the constraints builtin (which might resolve this
issue, albeit by polluting the global space), or moving `comparable`
(despite its "magical" properties) to package constraints.


--- Comment #26 by rsc ---

This proposal has been added to the [active column](https://golang.org/s/proposal-status#active) of the proposals project
and will now be reviewed at the weekly proposal review meetings.
‚Äî rsc for the proposal review group


--- Comment #27 by gavingroovygrover ---
There's always "curbs", which is 6 runes shorter.
Is "curb" a synonym of "constraint"?
The spec would needing changing too e.g. "A curb is a constraint on ..."

--- Comment #28 by rsc ---
We added this to the proposal minutes to see if any new information came in since the previous discussion. It looks like there has not been.

The reasons for constraints at this point are:

1. We already discussed this and ended at constraints. 
2. "constraints.Integer" is clear for readers even if a little long-winded for writers, and we expect that there will be many more people reading generic signatures than writing them.
3. Words like "is" or "of" are a bit more cute than we usually aim for. People mention "fmt", but "fmt" is clearly short for "format", whereas "is" can be interpreted in many ways. There is a third-party testing package named "is", for example, supporting that there's nothing fundamentally "genericsy" about "is".
4. "constraint" is also the term used throughout the spec definition for generics. Having the package name match the feature has discoverability benefits.








--- Comment #29 by earthboundkid ---
I think the thing we want to know is ‚Äúhow annoying is it in practice that signatures with ‚Äòconstraints‚Äô will be rather long?‚Äù Fortunately, if the answer turns out to be ‚Äúvery‚Äù we can just use an import alias in the short term and introduce a new package in the long term, so it‚Äôs not an irrevocable decision. 

--- Comment #30 by andig ---
Apart from having to type it the main drawback of long names is imho readbility when you have more then one or two parameters. It distracts people and leads to hard-to-read, long signatures. 
