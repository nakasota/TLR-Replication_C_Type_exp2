==== [Issue Title] ====
proposal: sync: add method Mutex.Locked(func())

==== [Issue Body] ====
I'm raising this proposal to have the discussion once. There are alternatives that exist today, but I figure this may be worth considering. I could not find a similar proposal in the backlog of open nor closed issues (no results for scoped mutex, nor sync locked).

I propose to add `sync.Mutex.Locked(func())`:

```go
func (m *Mutex) Locked(fn func()) {
        m.Lock()
        defer m.Unlock()
        fn()
}
```

## Benefits

* This can help eliminate a common problem of locking + deferring in loops.
* This can guard against recovered panics leaving the mutex in a locked state if the user is not using `defer` to unlock.
* Users are more incentivized to write functions without locks and rely on `Locked` to handle their synchronization, rather than embedding `Lock / defer Unlock` into the top of many functions.
* It looks visually cleaner than the inline anonymous function with defers (deemed `BenchmarkUgly` in the play link below).
* Users that have multiple unlock paths can be more incentivized to return from `Locked` and handle the result outside the lock/unlock paths.

## Downsides

* This adds one function as overhead on `sync.Mutex`, whereas the current implementation is a strictly to the point mutex.
* Defer cannot be inlined at the moment (see #38471), meaning the `Locked` function cannot be inlined, and neither can the function passed to it. Theoretically this slowness can be eliminated.
* The alternatives that exist today are fine and have existed since Go 1.0.

## Code example / benchmarks

https://play.golang.org/p/Tll9rFTuPUM
```
goos: linux
goarch: amd64
pkg: j
cpu: Intel(R) Core(TM) i7-10710U CPU @ 1.10GHz
BenchmarkNative-12    	95955990	        10.82 ns/op
BenchmarkLocked-12    	72775494	        14.65 ns/op
BenchmarkUgly-12      	86551378	        13.73 ns/op
```

==== [Comments] ====

--- Comment #1 by zephyrtronium ---
I think there are advantages to making this a function that takes a Locker rather than a method on Mutex. This would allow using it with either end of an RWMutex, or another custom Locker.

--- Comment #2 by esote ---
`database/sql` has an internal function [`withLock()`](https://github.com/golang/go/blob/c2397905e027cdbab3a28d02813adcb82368422c/src/database/sql/sql.go#L3434) which also uses Locker instead of Mutex

```go
// withLock runs while holding lk.
func withLock(lk sync.Locker, fn func()) {
	lk.Lock()
	defer lk.Unlock() // in case fn panics
	fn()
}
```

--- Comment #3 by andig ---
I'm not sure I would actually want to use the new API as it would increase indentation (at least for anonymous functions) and decrease readability. Additional counter arg is that one can already write this code as package level function today.

--- Comment #4 by rsc ---
In general we try not to have two different ways to do something, and for better or worse we have the current idioms. 


--- Comment #5 by rsc ---

This proposal has been added to the [active column](https://golang.org/s/proposal-status#active) of the proposals project
and will now be reviewed at the weekly proposal review meetings.
— rsc for the proposal review group


--- Comment #6 by bcmills ---
Now that we have generics on the way, I would rather see us move in a direction that _also_ eliminates unlocked-access bugs, not just incrementally update `Mutex` for forgotten-`defer` bugs.

Perhaps a typed `Mutex` instead of a raw one (https://go.dev/play/p/djJQBj1hemU):

```go
package sync

type Synchronized[T any] struct {
	mu Mutex
	val T
}

func (s *Synchronizedf[T]) Do(fn func(*T)) {
	m.mu.Lock()
	defer m.mu.Unlock()
	fn(&m.val)
}
```

(However, an API like the above probably ought to be prototyped and tested outside of the standard library to check its ergonomics.)

--- Comment #7 by rsc ---

Based on the discussion above, this proposal seems like a **[likely decline](https://golang.org/s/proposal-status#likely-decline)**.
— rsc for the proposal review group


--- Comment #8 by rsc ---

No change in consensus, so **[declined](https://golang.org/s/proposal-status#declined)**.
— rsc for the proposal review group

