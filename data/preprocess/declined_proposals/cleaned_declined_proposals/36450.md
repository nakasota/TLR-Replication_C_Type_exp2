==== [Issue Title] ====
proposal: index/suffixarray: added functionality via longest common prefix array

==== [Issue Body] ====
### What version of Go are you using (`go version`)?

<pre>
$ go version
go version go1.13.1 linux/amd64
</pre>

I have added an LCP array to the suffix array to provide the following functionality

```
func (x *Index) DistinctSubsCount() int
func (x *Index) DistinctSubs() [][]byte
func (x *Index) LongestRepeatedSubs() [][]byte
```

The LCP array is being initialized by once.Do() inside these methods, so existing users that don't need the new functionality won't have to deal with the overhead.

If this is something of interest, i will create a PR.
Cheers.


==== [Comments] ====

--- Comment #1 by ianlancetaylor ---
CC @griesemer 

I suspect that we're going to consider the index/suffixarray package as complete.  It might be better to provide your changes as a library available for anyone who wants it.  https://golang.org/doc/faq#x_in_std

--- Comment #2 by griesemer ---
Agreeing with @ianlancetaylor : It is not that we're not interested in having more functionality, the problem is that by adding more functionality to the std library we're adding maintenance burden (to the Go team) for a library that is not super-widely used but of significant complexity.

Marking NeedsDecision for input from the proposal committee.

--- Comment #3 by odeke-em ---
@griesemer should we perhaps mark this as a proposal so that we can gain visibility from the proposal review committee? I ask because proposal have been reviewed periodically but no response on this one. Thank you.

--- Comment #4 by griesemer ---
Marked as Proposal for visibility, per @odeke-em 's suggestion.

--- Comment #5 by rsc ---
@petar-dambovaliev, I've been doing some index/suffixarray uses recently (including the recent optimizations) and it's true that lots of algorithms start with "compute the suffix array and the LCP array". If the code were not much more to maintain, it might be worth having in the package proper instead of delegating to third-party packages. I'm less certain about the API, but we can figure that out.

You said you could make a PR. How much code is it? I'm just curious what level of complexity we're talking about taking on. Thanks.


--- Comment #6 by odeke-em ---
@rsc, the associated CL that @petar-dambovaliev made is at
https://go-review.googlesource.com/c/go/+/213758

On Wed, Apr 1, 2020 at 10:54 AM Russ Cox <notifications@github.com> wrote:

> @petar-dambovaliev <https://github.com/petar-dambovaliev>, I've been
> doing some index/suffixarray uses recently (including the recent
> optimizations) and it's true that lots of algorithms start with "compute
> the suffix array and the LCP array". If the code were not much more to
> maintain, it might be worth having in the package proper instead of
> delegating to third-party packages. I'm less certain about the API, but we
> can figure that out.
>
> You said you could make a PR. How much code is it? I'm just curious what
> level of complexity we're talking about taking on. Thanks.
>
> —
> You are receiving this because you were mentioned.
> Reply to this email directly, view it on GitHub
> <https://github.com/golang/go/issues/36450#issuecomment-607399963>, or
> unsubscribe
> <https://github.com/notifications/unsubscribe-auth/ABFL3VZH2AIUTG25DVKUAETRKN5WLANCNFSM4KEHHZ2Q>
> .
>


--- Comment #7 by petar-dambovaliev ---
> @petar-dambovaliev, I've been doing some index/suffixarray uses recently (including the recent optimizations) and it's true that lots of algorithms start with "compute the suffix array and the LCP array". If the code were not much more to maintain, it might be worth having in the package proper instead of delegating to third-party packages. I'm less certain about the API, but we can figure that out.
> 
> You said you could make a PR. How much code is it? I'm just curious what level of complexity we're talking about taking on. Thanks.

I am sure that when reviewed, you will have good ideas to improve on it.
At the moment it is 264 lines, including some tests and the generated code for 32/64 int slices.
The actual implementation is less than a 100 lines.


--- Comment #8 by rsc ---
@petar-dambovaliev, thanks for sending the CL, and apologies for not getting back to this sooner. The world went haywire a bit in April. :-(

As I look at this, it seems like (1) generating the LCP efficiently is more subtle than the code in the CL, and (2) it's unclear what exactly to do with the LCP afterward.

For (1), the code in the CL is O(N²) - if you have a text of N x's, each inner loop of newLcp_NN takes on average N/2 steps, for a total of N²/2 = O(N²). There are linear-time algorithms for constructing the LCP, though. The algorithm by Kasai et al. uses an extra temporary array of N ints but only requires O(N) computation. And there are variants too, described at https://en.wikipedia.org/wiki/LCP_array#Efficient_construction_algorithms. It also appears that the SA-IS implementation used for constructing the suffix array itself can be adapted to construct the LCP during suffixarray.New, provided you know you need it ahead of time.

For (2), we don't expose the actual suffix array directly in the current package API - and that turned out to be a good choice, since it let us use int32 or int64 internally based on the data size - so it wouldn't make much sense to expose the actual LCP directly either. That higher-level API makes the LCP less useful than I had thought.

I could see one option would be to have an alternate constructor - NewLCP maybe - that returns an LCP-enabled \*Index. Using NewLCP would mean incurring an extra 4N memory overhead for the in-memory Index (or 8N for very large texts) but would let index.Lookup run in O(log(N) + len(s) + len(result)) instead of O(log(N)\*len(s) + len(result)) (note the + vs \* after log(N) in those two expressions). I'm not convinced it would be worth the added API overhead of a new constructor and all the new code to make Lookup faster this way. Possibly, but possibly not.

That raises the question of what other new high-level API an LCP-aware suffixarray could provide, beyond the faster Lookup. I don't see much honestly. I see that in the CL there are three new functions:

 - LongestRepeatedSubs returns the longest repeated substrings from data.
 - DistinctSubs returns all the distinct substrings from data.
 - DistinctSubsCount returns the number of distinct substrings in data.

At first glance these don't seem widely needed, nor do they seem to fit into the "index" theme (this is index/suffixarray), and they also seem impossible in the general case to implement particularly efficiently.

In the worst case, LongestRepeatedSubs could return O(N) results (well, O(N/log N) but the constant factor makes it more like O(N)), meaning that you end up with potentially 24*N bytes of slice headers for an N-byte text.

Similarly, in the worst case, nearly all of the N²/2 substrings in a text are distinct, meaning DistinctSubsCount has to return the value N²/2. That value might not fit in an int or even an int64 for a large enough text. We'd need some kind of int128 representation on a 64-bit system. We could maybe do that for DistinctSubsCount, but then DistinctSubs has to return a [][]byte with length equal to that count, which is both quite large (24*N²/2 bytes of slice headers) and potentially impossible - there are no int128-len slices.

**Why did you choose these three operations? In what contexts do they arise?**

Thanks very much.

--- Comment #9 by gopherbot ---
Change https://golang.org/cl/213758 mentions this issue: `index/suffixarray: add LongestCommonPrefix method to Index`

--- Comment #10 by rsc ---
Based on the discussion above, this seems like a **likely decline**.


--- Comment #11 by rsc ---
No change in consensus, so declined.

