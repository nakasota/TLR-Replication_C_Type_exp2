==== [Issue Title] ====
proposal: strings: add Lines

==== [Issue Body] ====
If I already have a string in memory, there's no simple and efficient way of splitting it into lines.

The naïve approach won't handle `\r\n`.

``` go
strings.Split(s, "\n")
```

Using a `bufio.Scanner` works but it creates copies instead of slicing the existing string.

``` go
var lines []string
sc := bufio.NewScanner(strings.NewReader(s))
for sc.Scan() {
    lines = append(lines, sc.Text())
}
```

I'd like a new `strings.Lines` function similar to `strings.Fields` for this use-case.



==== [Comments] ====

--- Comment #1 by icholy ---
Here are some other approaches I've seen while searching:

``` go
strings.Split(strings.ReplaceAll(s, "\r\n", "\n"), "\n")
```

``` go
regexp.MustCompile("\r?\n").Split(s, -1)
```

--- Comment #2 by ALTree ---
Assuming a "line" is anything delimited by one of `\n`, `\r`, and `\r\n`, calling `strings.FieldsFunc` with `func(c rune) bool { return c == '\n' || c == '\r' }` seems to work.


--- Comment #3 by icholy ---
@ALTree thanks, I'll be using that. However, it doesn't give the correct output for strings with blank lines like `"\n\n\n"`

--- Comment #4 by ALTree ---
Oh, right. It's actually just Fields. You want something that returns 4 strings for "text\n\n\ntext`, two of which are empty, which is different from what Fields does.

--- Comment #5 by ALTree ---
What about adding `strings.SplitFunc` instead? That would mirror `strings.FieldsFunc` and let you split on a custom function.

--- Comment #6 by icholy ---
What would the signature of the callback look like? Something like `func(rune) bool` wouldn't be able to handle the `\r\n` case.

--- Comment #7 by ALTree ---
EDIT: right, that's probably why it doesn't exist. The API is less obvious. You'd need to check substrings instead of the single runes.

--- Comment #8 by icholy ---
If something like `SplitMulti` was added, then you'd also need all the different variations. That gets messy.

``` go
func SplitMulti(s, seps []string) []string
func SplitMultiAfter(s, seps []string) []string
func SplitMultiAfterN(s, seps []string, n int) []string
func SplitMultiN(s, seps []string, n int) []string
```

--- Comment #9 by rsc ---
Cut works great.

```
for text != "" {
   line, rest, ok := strings.Cut(text, "\n")
   text = rest
   line = strings.TrimSuffix(line, "\r") // if you care
   ... use line ...
}
```


--- Comment #10 by rsc ---
For that matter, strings.SplitAfter(text, "\n") also works.
There's an extra empty string at the end of the slice if the text ends in a final \n (as most do).


--- Comment #11 by rsc ---

This proposal has been added to the [active column](https://golang.org/s/proposal-status#active) of the proposals project
and will now be reviewed at the weekly proposal review meetings.
— rsc for the proposal review group


--- Comment #12 by icholy ---
One potential problem with `strings.Lines` is that it might encourage people to write inefficient code.

``` go
data, _ := os.ReadFile("lines.txt)
for _, line := range strings.Lines(string(data)) {
  // use line
}
```

--- Comment #13 by jimmyfrasche ---
Having a reader and writers that transform line endings would be great. (Or, if https://pkg.go.dev/golang.org/x/text/transform were in std, they could just be transformers.)

--- Comment #14 by icholy ---
@jimmyfrasche can be done with https://pkg.go.dev/github.com/icholy/replace

```
t := replace.String("\r\n", "\n")
```

--- Comment #15 by jimmyfrasche ---
Since you have that, how are you ending up with a string in memory that may have windows line endings?

--- Comment #16 by icholy ---
@jimmyfrasche Say you're working with an AST which exposes comments as multiline strings.

--- Comment #17 by rsc ---
It sounds like (1) the API is somewhat inefficient since it has to allocate the slice, (2) there are other ways to write the code that are more efficient and just as clean using existing standard library APIs, and (3) this could be in an external library easily instead if the exact operation of 'return a slice of all the lines' is required.

In that case, it seems like this is heading toward likely decline. Do I have that right?

--- Comment #18 by icholy ---
> (1) the API is somewhat inefficient since it has to allocate the slice,

Given the target use-cases, this would be negligible.

> (2) there are other ways to write the code that are more efficient and just as clean using existing standard library APIs

I'm not sure about "just as clean". The proposed `strings.Lines` api is more ergonomic than other solutions.

> (3) this could be in an external library easily instead if the exact operation of 'return a slice of all the lines' is required.

ofc

> In that case, it seems like this is heading toward likely decline. Do I have that right?

Ya, I think so. The potential for abuse makes it not worth it IMO.


--- Comment #19 by rsc ---
> Given the target use-cases, this would be negligible.

The problem with putting things in the standard library is that it will get used for many uses cases beyond the target. Things in the standard library have to be particularly robust against unexpected uses.


--- Comment #20 by rsc ---

Based on the discussion above, this proposal seems like a **[likely decline](https://golang.org/s/proposal-status#likely-decline)**.
— rsc for the proposal review group


--- Comment #21 by rsc ---

No change in consensus, so **[declined](https://golang.org/s/proposal-status#declined)**.
— rsc for the proposal review group

