==== [Issue Title] ====
proposal: syscall: define Windows O_ALLOW_DELETE for use in os.OpenFile

==== [Issue Body] ====
The discussion on #32088 has so far been unable to reach consensus on setting FILE\_SHARE\_DELETE unconditionally in os.OpenFile. Right now it looks likely to be declined, possibly revisited in a few years.

In the interim, it is more difficult on Windows than on Unix to pass an extra flag to open a file with package syscall. syscall.Open takes fake O\_\* flags, not actual Windows permission bits. It wraps syscall.CreateFile, but it does a lot of argument preparation before making that call:

	// package syscall

	func Open(path string, mode int, perm uint32) (fd Handle, err error) {
		if len(path) == 0 {
			return InvalidHandle, ERROR_FILE_NOT_FOUND
		}
		pathp, err := UTF16PtrFromString(path)
		if err != nil {
			return InvalidHandle, err
		}
		var access uint32
		switch mode & (O_RDONLY | O_WRONLY | O_RDWR) {
		case O_RDONLY:
			access = GENERIC_READ
		case O_WRONLY:
			access = GENERIC_WRITE
		case O_RDWR:
			access = GENERIC_READ | GENERIC_WRITE
		}
		if mode&O_CREAT != 0 {
			access |= GENERIC_WRITE
		}
		if mode&O_APPEND != 0 {
			access &^= GENERIC_WRITE
			access |= FILE_APPEND_DATA
		}
		sharemode := uint32(FILE_SHARE_READ | FILE_SHARE_WRITE)
		var sa *SecurityAttributes
		if mode&O_CLOEXEC == 0 {
			sa = makeInheritSa()
		}
		var createmode uint32
		switch {
		case mode&(O_CREAT|O_EXCL) == (O_CREAT | O_EXCL):
			createmode = CREATE_NEW
		case mode&(O_CREAT|O_TRUNC) == (O_CREAT | O_TRUNC):
			createmode = CREATE_ALWAYS
		case mode&O_CREAT == O_CREAT:
			createmode = OPEN_ALWAYS
		case mode&O_TRUNC == O_TRUNC:
			createmode = TRUNCATE_EXISTING
		default:
			createmode = OPEN_EXISTING
		}
		h, e := CreateFile(pathp, access, sharemode, sa, createmode, FILE_ATTRIBUTE_NORMAL, 0)
		return h, e
	}

A direct call to syscall.CreateFile would have to duplicate all that code.

A direct call to syscall.Open would still lose out on the adjustments made inside os.Open, most importantly the call to fixLongPath:

	// package os

	func openFile(name string, flag int, perm FileMode) (file *File, err error) {
		r, e := syscall.Open(fixLongPath(name), flag|syscall.O_CLOEXEC, syscallMode(perm))
		if e != nil {
			return nil, e
		}
		return newFile(r, name, "file"), nil
	}

If package syscall on Windows defined a bit O\_ALLOW\_DELETE (maybe 0x100000), then syscall.Open could convert that bit into FILE\_SHARE\_DELETE. Then it would be easy for calls to either syscall.Open or os.OpenFile to cause the underlying call to use FILE\_SHARE\_DELETE if they really needed it.

This proposal assumes #32088 is declined. It should be considered withdrawn if #32088 is accepted.

==== [Comments] ====

--- Comment #1 by networkimprov ---
I would call this O_ALLOW_RENAME since that's the most common use of the flag. I'd also define it in package "os" so users don't need to write an open wrapper (with multiple implementations) and remember to always invoke that instead of os.OpenFile().

One may also wish to _switch off_ FILE_SHARE_READ & _WRITE to prevent another caller from inadvertently blocking rename/delete by opening the file.

--- Comment #2 by ianlancetaylor ---
Whatever the name, it's worth asking whether the new name should be defined on non-Windows systems, presumably with the value `0`.  The advantage of doing that would be that people who want to run on all systems could use the flag without relying on build tags.  The disadvantage would be a flag that is odd and ineffective on non-Windows systems; on the other hand, that is already true of `O_SYNC`, or `O_APPEND|O_WRONLY`, on Windows systems.

--- Comment #3 by thaJeztah ---
Agreed with @ianlancetaylor, that would make maintenance easier without having to breaking up code to platform-specific implementations

--- Comment #4 by mattn ---
I agree with iant. We should consider to portability of the code but the meenless flag should not be added to UNIX. If we don't add the new flag on UNIX, the code for Windows must be compiled with build constraints. i.e. it is same thing that providing windows.Open() from golang.org/x/sys/windows.

--- Comment #5 by thaJeztah ---
@mattn slightly confused, you say you _agree_ with @ianlancetaylor, but then continue that you _don't_ want to add the new flag on UNIX(/non-Windows)?

--- Comment #6 by networkimprov ---
@alexbrainman thoughts?

--- Comment #7 by mattn ---
@thaJeztah I am simply considering for a reasonable and nondestructive way to make changes to the standard library. This proposal has a positive effect on Windows users, but it shows meaningless flag(s) to UNIX users.

--- Comment #8 by alexbrainman ---
I think putting this functionality in a separate package works just fine (see https://github.com/golang/go/issues/32088#issuecomment-538703906 for details). Why does it have to be in main Go repo?

If some insist, we could move that package somewhere under golang.ord/x/sys or x/exp.

Alex

--- Comment #9 by DmitriyMV ---
@alexbrainman 
Because code duplicates the one which is in standard library. I don't think that another hack floating around (with forks and duplicates) is a really good idea. If that code is changed in the future - all forks would have to update, which is never going to happen.

The simple answer is - code maintenance. This is relatively cheap change, which doesn't require a lot of support in the future. I think we should be decreasing surface for bugs - we were bitten by it (not changing things) in the past (leap second and `time` package).

@mattn 
> This proposal has a positive effect on Windows users, but it shows meaningless flag(s) to UNIX users.

Don't we already have some of those (meaningless flags) for Windows users, which are meaningful on UNIX? I don't think people would mind adding new flag to the `os` package. But if they do, I'm open for adding this to `syscall`.

--- Comment #10 by networkimprov ---
@alexbrainman could you restate here, since the other issue is so long, why it is that you don't support this proposal?

--- Comment #11 by alexbrainman ---
> Because code duplicates the one which is in standard library.

Sure it does. Whole github.com/alexbrainman/goissue34681 package is 375 lines long including docs and tests. It took me around 1 hour to write - I copied os.Open and os.OpenFile, and then copied whatever was missing. It took me longer to write test. It just Go code, there is very little magic there.

> I don't think that another hack floating around (with forks and duplicates) is a really good idea. 

I am not proposing forks or duplicates. I propose you use github.com/alexbrainman/goissue34681 package. I am happy to move the package, if people have better suggestions.

> If that code is changed in the future - all forks would have to update, which is never going to happen.

If correspondent os package code change in the future, and that change affects github.com/alexbrainman/goissue34681 , then sure someone will have to report bug and fix the code. We should have some tests in github.com/alexbrainman/goissue34681 and run them regularly. Just like another package. But, going by my experience, I don't think there will be many changes like that.

> 
> The simple answer is - code maintenance. 

What is proposed in here is not maintenance free either.

This change is at the heart of os package. How would new flag interact with all other code? How will new flag work with directories? With symlinks? What about file symlinks vs directory symlinks? What about directory junctions? What about network shares? And this flag needs to be explained to every single Go user. Including novices and non-Windows users. Should we recommend that they use the flag or not? When? How would their decision would affect their users? Are they in a position to make that decision?

So far I have seen this flag used to open files so they can be moved or deleted. Therefore I created github.com/alexbrainman/goissue34681 package with just Open and OpenFile functions. These are simple replacement of os.Open and os.OpenFile. All your remaining code should not change. And the package should also work for non-Windows use - it just call os.Open and os.OpenFile for them. I think github.com/alexbrainman/goissue34681 package is easier to use then new os pack age flag.

I think users who need that functionality should try github.com/alexbrainman/goissue34681 package before we even discuss adding new flag to os package.

> could you restate here, since the other issue is so long, why it is that you don't support this proposal?

See above paragraph.

Alex

--- Comment #12 by DmitriyMV ---
> then sure someone will have to report bug and fix the code. 

Thats implying that someone is going to support this package forever. If one doesn't support it, then we face the situation with forks\duplicates.

> This change is at the heart of os package. How would new flag interact with all other code? How will new flag work with directories? With symlinks? What about file symlinks vs directory symlinks? What about directory junctions? What about network shares? And this flag needs to be explained to every single Go user. Including novices and non-Windows users. Should we recommend that they use the flag or not? When? How would their decision would affect their users? Are they in a position to make that decision?

All of this is seems solvable by moving this flag to the syscall package.

> I think github.com/alexbrainman/goissue34681 package is easier to use then new os pack age flag.
What about transitive dependencies which return `*os.File`?

If you are so against the idea of having as in standard, maybe we can move it into `golang.org/x/sys/windows`. That way we can at least ensure that people will maintain it in the future. 

--- Comment #13 by alexbrainman ---
> Thats implying that someone is going to support this package forever. If one doesn't support it, then we face the situation with forks\duplicates.

Yes. Someone who uses this package has to support it, if it breaks. It could be you, if it is important to you. But like I said before, it is very little code, and it should not break often. If there are enough users of that package it shouldn't be a problem. Should it?

> All of this is seems solvable by moving this flag to the syscall package.

I don't see how this flag can live in syscall package. Can you provide more details?

> If you are so against the idea of having as in standard, maybe we can move it into `golang.org/x/sys/windows`. That way we can at least ensure that people will maintain it in the future.

I am fine moving this package into somewhere under golang.org/x. I am not sure about adding 2 new functions (Open and OpenFile) to golang.org/x/sys/windows. golang.org/x/sys/windows has a lot of code, they will get lost there. And golang.org/x/sys/windows package is only available on Windows. github.com/alexbrainman/goissue34681 is suppose to be straight replacement of os.Open and os.OpenFile - it should work on any OS.

Alex

--- Comment #14 by zx2c4 ---
This is a slippery slope. On Windows, `CreateFile` and `NtCreateFile` have a lot of very interesting options and overrides. Probably the existing set of parameters are sensible for the majority of normal files people open. For weird files in special conditions, users will probably want the full control of `CreateFile` or `NtCreateFile`, not just the stray `O_ALLOW_DELETE` exception because a user happened to report _that particular need_ to our bug tracker. In other words, I agree here with @alexbrainman - if we want to provide this functionality, let's do it outside of `os.OpenFile` and instead stick it in x/sys/windows or an external package or somewhere sensible like that. I'd then deviate from Alex's idea of copying OpenFile precisely and instead I'd suggest a Windows-specific library where we can expose all the various insane switches and nobs that Windows offers.

tl;dr: :-1: on proposal.

--- Comment #15 by thaJeztah ---
I think the problem was that currently, [`syscall.Open()`](https://github.com/golang/go/blob/go1.13.1/src/syscall/syscall_windows.go#L267) handles flags it knows about (setting `access`, `sa`, and `createmode` based on those) then sets a hard-coded `sharemode`, and discards any other flag that was passed;  https://github.com/golang/go/blob/0e54d28ff7ff63450356811b675a02e0afe610d6/src/syscall/syscall_windows.go#L291

(thinking out loud) I wonder if it would be an option to have `sharemode` default to the current options, and append any flag that was not consumed by `access`, `sa`, or `createmode`. This would be similar to how the linux variant passes on whatever flags are passed; https://github.com/golang/go/blob/0e54d28ff7ff63450356811b675a02e0afe610d6/src/syscall/syscall_linux.go#L137-L139

(again, just thinking out loud)


--- Comment #16 by zx2c4 ---
> I think the problem was that currently, syscall.Open() handles flags

`syscall.Open` returns a Handle, just like `syscall.CreateFile`.

If we're discussing `syscall.`, what about just introducing `x/sys/windows.OpenFile` or `syscall.OpenFile` that wraps the relevant arguments of `CreateFile`, or perhaps better, `NtCreateFile`, and returns `(*File, error)`. So something like:

`func OpenFile(name string, access uint32, mode uint32, create uint32, attrs uint32, templateFile Handle, securityAttributes *SecurityAttributes) (*os.File, error)`

Then people who want to do wild&crazy things with the Windows file opening routines can just use this and proceed as usual.

--- Comment #17 by jstarks ---
The motivation of this as well as the original proposal was to make it easier for Go software authors to write code that works cross-platform. We need to pass FILE_SHARE_DELETE to make Windows behave more like POSIX with respect to file deletion. There is general agreement that we cannot make this the default without regressing existing behavior, but the desire to have a clean, simple solution persists.

Any solution that requires extra dependencies, _windows.go files, build tags, etc. deviates from the goal of writing common code everywhere. I know from experience that it will be much easier to convince a random developer to add O_ALLOW_DELETE to their calls to os.OpenFile than to convince them to pull in an additional dependency with a custom fork of os.OpenFile, or to add Windows-specific .go files, just to get Windows to behave like everyone else.

I like the idea of putting a Windows-specific open routine in x/sys/windows to easily expose the wealth of CreateFile functionality! It would be great if we didn't have to replicate the complexity of calling syscall.CreateFile everywhere that needs Windows-specific functionality.

But I also think FILE_SHARE_DELETE is a special case worthy of inclusion in os.OpenFile, since it changes Windows behavior to be closer to all the other operating systems Go supports. I can't immediately think of any other CreateFile flags that do that.

--- Comment #18 by rsc ---
Since #32088 has been declined, it seems like we should examine this carefully.

@alexbrainman seems to be saying it's not worth adding to package syscall when it can be done externally. But Alex, it's just a couple lines in syscall (that will be easy to maintain: O\_ALLOW\_DELETE literally means set FILE\_SHARE\_DELETE in the system call) versus having to maintain a 300+-line package elsewhere and also expect users to find it. Do you object strongly to adding just these few lines to package syscall? 

@zx2c4, I understand your point about the many options, and maybe we should make it easier to get at CreateFile directly, but it does seem that this particular bit ("make Windows more like Unix file systems") is going to be wanted more often than most of the other settings.

Does anyone else object to adding these few lines?


--- Comment #19 by alexbrainman ---
> but the desire to have a clean, simple solution persists.
> 
> Any solution that requires extra dependencies, _windows.go files, build tags, etc. deviates from the goal of writing common code everywhere. I know from experience that it will be much easier to convince a random developer to add O_ALLOW_DELETE to their calls to os.OpenFile than to convince them to pull in an additional dependency with a custom fork of os.OpenFile, or to add Windows-specific .go files, just to get Windows to behave like everyone else.

I think github.com/alexbrainman/goissue34681 package fits your requirements perfectly. It is oddly named, but we can give it better name. And we can move it into more "supported" place.

> But I also think FILE_SHARE_DELETE is a special case worthy of inclusion in os.OpenFile, since it changes Windows behavior to be closer to all the other operating systems Go supports.

But the flag is completely meaningless for majority of Go users.

os.OpenFile already has 8 flags. And some flags can be used in combinations. I think it is too many as is. I struggle to remember which flags do what when I review or write code.

So adding 9-th flag of O_ALLOW_DELETE makes things even more confusing for everyone. If I am Linux developer, should I use O_ALLOW_DELETE in my code and when?

Go is supposed to be simple to use.

> But Alex, it's just a couple lines in syscall (that will be easy to maintain: O_ALLOW_DELETE literally means set FILE_SHARE_DELETE in the system call) versus having to maintain a 300+-line package elsewhere

The duplicate code is in main_windows.go, and it is 214 lines long.

And since when the line count is more important than clean API and maintainability?

We already have plenty of duplicate code - just compare os and path/filepath packages. We write tests, and make sure we don't break them.

Adding new os.O_ALLOW_DELETE flag won't be easier to maintain then new package. New flag needs to be documented, educated, made sure it works in unusual scenarios (see https://github.com/golang/go/issues/34681#issuecomment-539413777 ). We would need to spend time fixing bugs and debugging flag usage. I am surprised I have to explain all these points to you.

> and also expect users to find it.

I think this flag is only useful to narrow group of users. So, discover-ability is not a problem. I am certain, few people who needed this functionality, they already wrote their own code, just like I did myself.

Alex

--- Comment #20 by DmitriyMV ---
> Adding new os.O_ALLOW_DELETE flag won't be easier to maintain than new package. New flag needs to be documented, educated, made sure it works in unusual scenarios (see #34681 (comment) ). We would need to spend time fixing bugs and debugging flag usage. I am surprised I have to explain all these points to you.

I'm sorry, but those points are not "sound" at all. All of this points can be used against implementing any sort of new functionality - additions to errors/context/net packages, generics, etc. I also don't see a problem with maintenance - we are not going to get more "windows" developers and contributors, if we are going to treat them as second class citizens, and force them to reimplement `os` functionality in side packages.

I also suspect there is a problem in communications, because ATM we are arguing about 3 different things:
1. Having new flag is os/syscall package.
2. Having new functionality in /x/sys side package.
3. Not having it at all in Go repos.

I think it would be wise to start talking about those.

--- Comment #21 by networkimprov ---
I think @alexbrainman is right that a new flag is not a great solution.

I patch my syscall_windows.go as follows, and set `syscall.Open_FileShareDelete = true` once in apps that need it. This __would not land upstream__, but if enough folks apply it, that would demonstrate over time that there's no downside to making file_share_delete the default for os.Open/etc().

```
diff --git a/src/syscall/syscall_windows.go b/src/syscall/syscall_windows.go
index de05840..e1455d5 100644
--- a/src/syscall/syscall_windows.go
+++ b/src/syscall/syscall_windows.go
@@ -245,6 +245,8 @@ func makeInheritSa() *SecurityAttributes {
 	return &sa
 }
 
+var Open_FileShareDelete = false
+
 func Open(path string, mode int, perm uint32) (fd Handle, err error) {
 	if len(path) == 0 {
 		return InvalidHandle, ERROR_FILE_NOT_FOUND
@@ -270,6 +272,9 @@ func Open(path string, mode int, perm uint32) (fd Handle, err error) {
 		access |= FILE_APPEND_DATA
 	}
 	sharemode := uint32(FILE_SHARE_READ | FILE_SHARE_WRITE)
+	if Open_FileShareDelete {
+		sharemode |= FILE_SHARE_DELETE
+	}
 	var sa *SecurityAttributes
 	if mode&O_CLOEXEC == 0 {
 		sa = makeInheritSa()
```

--- Comment #22 by zx2c4 ---
FWIW, the .NET default appears to be only giving `FILE_SHARE_READ`, but not write. That generally fits my impression of how most Windows apps appear to work too.

--- Comment #23 by zx2c4 ---
Here's another curious insight from reading .NET code: they now support other operating systems, but of course all their constructors and whatnot take a `FileShare share` parameter because it was originally for Windows. So now they're trying to figure out what to do with that flag. Here's what they do:

```csharp
        /// <summary>Initializes a stream for reading or writing a Unix file.</summary>
        /// <param name="mode">How the file should be opened.</param>
        /// <param name="share">What other access to the file should be allowed.  This is currently ignored.</param>
        private void Init(FileMode mode, FileShare share, string originalPath)
        {
            _fileHandle.IsAsync = _useAsyncIO;

            // Lock the file if requested via FileShare.  This is only advisory locking. FileShare.None implies an exclusive
            // lock on the file and all other modes use a shared lock.  While this is not as granular as Windows, not mandatory,
            // and not atomic with file opening, it's better than nothing.
            Interop.Sys.LockOperations lockOperation = (share == FileShare.None) ? Interop.Sys.LockOperations.LOCK_EX : Interop.Sys.LockOperations.LOCK_SH;
            if (Interop.Sys.FLock(_fileHandle, lockOperation | Interop.Sys.LockOperations.LOCK_NB) < 0)
            {
                // The only error we care about is EWOULDBLOCK, which indicates that the file is currently locked by someone
                // else and we would block trying to access it.  Other errors, such as ENOTSUP (locking isn't supported) or
                // EACCES (the file system doesn't allow us to lock), will only hamper FileStream's usage without providing value,
                // given again that this is only advisory / best-effort.
```

It looks like they try to make the Windows stuff sort of work by taking a shared lock when no locking is requested and an exclusive one when any locking is requested. Wild!

--- Comment #24 by cpuguy83 ---
@alexbrainman You are asking every project that wants to use this option to copy several hundred lines of code that honestly I have no idea why the code is the way it is. All the special path handling and all... this even requires copying `syscall.Open`.

It's not a matter of "can" we do it. Yes we can. I did this exact thing to resolve our issue in moby/moby which you also copied in your repo.
"Should" we require all projects to make copies of this code?

The thing is, there's all the path handling is the `os` package, but then there's also actually modifying what's in syscall.

I'm all for copying the thing I need vs importing a package full of things I don't need but this is, in my opinion, too complicated to copy.

--- Comment #25 by mattn ---
We should consider any cases carefully since people using syscall/os package are not only you. No easy to rollback code. No easy change the behavior. So we froze syscall package and we are working with golang.org/x repository. Adding Open_FileShareDelete is easy but it is hard to know what will break something before add.

Neither I nor you can confirm that all Go users want the FILE_SHARE_DELETE. If some package set Open_FileShareDelete = true, another package might be broken.

We want to know whether most of use-case can be done with x package.

--- Comment #26 by thaJeztah ---
> Neither I nor you can confirm that all Go users want the FILE_SHARE_DELETE

I can confirm that not all users want it, and not all users don't want it. It an option that's added to the toolset, that users _can_ use in their code (but don't have to, just like other options)

> If some package set Open_FileShareDelete = true, another package might be broken.

I fail to see how this is a concern here; if a package creates a file, it's up to that package how that file is created. If that file is expected to be used/accessed by other packages, then it's up to the package maintainer to document it as a possible breaking change (and update the package version accordingly). I don't see that as anything different than, say, the package changing permissions on a file from `0440` to `0400`

--- Comment #27 by cpuguy83 ---
We aren't talking about a global here.

--- Comment #28 by networkimprov ---
@mattn, you misunderstood. From https://github.com/golang/go/issues/34681#issuecomment-540729522:

>I patch my syscall_windows.go as follows, and set `syscall.Open_FileShareDelete = true` once in apps that need it. This ___would not land upstream___, but if enough folks apply it, that would demonstrate over time that ...

So no published package could use syscall.Open_FileShareDelete.

--- Comment #29 by mattn ---
The demonstrate could be done with x package I think.

--- Comment #30 by zx2c4 ---
There's still some question as to whether this belongs in alexbrainman/, x/, or in std/. But aside from that question, here are some comments on the flag proposal.

If this is to be exposed via extra windows-specific flags, I think we ought to be specific about what they are in the names, and be exhaustive about it. So specifically:

- O_WINDOWS_SHARE_NONE
- O_WINDOWS_SHARE_READ
- O_WINDOWS_SHARE_WRITE
- O_WINDOWS_SHARE_DELETE

If any of these 4 are specified, then it _overrides our current default_ of read|write.

It's important that these begin with O_WINDOWS_ so that people are clear that this is Windows-only. We could then mention in the documentation that this has no effect on other platforms but isn't an error either -- a no-op. I'm sure there's some very succinct phrasing that can let this behavior be known, and readers of the code will know what's up when they see O_WINDOWS_. They'll think, "Oh that's some Windows-specific flag that's only effective on Windows."

Separately, we could map existing flags to Windows flags we don't yet support, where a sensible analog exists. For example:

- O_DIRECT could wind up setting the `FILE_FLAG_NO_BUFFERING` flag to `CreateFile`.

On the other hand, some Windows features don't have an analog elsewhere. For example, it would make sense to add in a direct manner the delete-on-close feature the Chromium people wanted, rather than trying to pretend it's the same as O_TMPFILE, which it's not. That would look like:

- O_WINDOWS_DELETE_ON_CLOSE
