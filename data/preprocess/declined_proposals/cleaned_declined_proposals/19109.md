==== [Issue Title] ====
proposal: cmd/go: make fuzzing a first class citizen, like tests or benchmarks

==== [Issue Body] ====
Filing a proposal on behalf of @kcc and @dvyukov:

They request that cmd/go support fuzzing natively, just like it does tests and benchmarks and race detection today.

https://github.com/dvyukov/go-fuzz exists but it's not as easy as writing tests and benchmarks and running "go test -race" today.

Should we make this easier?

[Motivation](http://tiny.cc/why-go-fuzz)
[Proposal](https://docs.google.com/document/u/1/d/1zXR-TFL3BfnceEAWytV8bnzB2Tfp6EPFinWVJ5V4QC8/pub)


==== [Comments] ====

--- Comment #1 by ianlancetaylor ---
I think it would be easier to evaluate the idea if it were slightly less abstract.

For example:

- _test.go are permitted to contain functions of the form `FuzzXxx(f *testing.F, data []byte)`
- these functions are expected to run some test based on the random bytes in `data`
- errors are reported using the `testing.F` argument in the usual way
- `f.Useful()` may be called to indicate useful data, i.e., data that parses correctly
- `f.Discard()` may be called to indicate that the data should be discarded
- `go test -fuzz=.` runs the fuzz functions using a regexp like `-test` and `-bench`
- naturally `go test -fuzz` must also rebuild the package in fuzz mode
- the data is cached somewhere under `$GOROOT/pkg`, but where?

--- Comment #2 by bradfitz ---
@ianlancetaylor, yes, `FuzzXxx(f *testing.F, ...)` is what this is about. The exact API is probably TBD.

I think the first step before it's designed completely is to determine whether there's interest.

--- Comment #3 by ianlancetaylor ---
As a general concept, I'm in favor.

--- Comment #4 by dsnet ---
I would expect that there would be an additional required flag (when fuzzing) where you specify the corpus directory.

--- Comment #5 by ianlancetaylor ---
Can we just cache the corpus somewhere under `$GOROOT/pkg`?  Are there cases where a typical user would be expected to modify the corpus themselves?

--- Comment #6 by dsnet ---
I think it's wrong to think of the corpus as strictly a cache. The corpus is the save state of the fuzzer and the documentation for go-fuzz even recommends committing them into a version control system. The `pkg` directory is treated strictly as cache and it is not uncommon for people to recommend clearing out the directory, which will unfortunately delete the fuzzer state.

A specified corpus is not so much for the user modify the corpus themselves, but for them to specify how to persist the corpus data.

--- Comment #7 by jimmyfrasche ---
Could there be some default convention say a _fuzz/xxx directory (where xxx corresponds with FuzzXxx) and a method on the *testing.F object to load a different corpus from the _fuzz/ directory if necessary? It seems like it should just know where the corpus is.


--- Comment #8 by minux ---
I'm in favor. Efficient fuzzing usually requires some help from compiler so
it's better to built this into std.
(compiler instrumentation will be more efficient than go-fuzz's source code
instrumentation. I also want to have cmd/cover built on compiler
instrumentation to support branch coverage, but that's off-topic to this
issue.)

How about add some methods to testing.T (or perhaps invent a new
testing.Fuzz to replace testing.T, but see below) in fuzz tests?
One of the method could be setting the corpus location (we can recommend it
to be saved under testdata).
but we probably should also a command line flag to override the test's
setting (one compromise is to make both optional:
Introduce -test.fuzzdir to hold the corpus path for all fuzz tests. If not
provided, default to testdata/fuzz
(*testing.T).FuzzDir("parser") // optional call to set corpus directory
prefix location for this test, if relative, then relative to the
-test.fuzzdir value.

To make the feature more useful, I suggest we still use testing.T so that
it's quite easy to migrate fuzz found test cases into a (table driven)
regular test.
Making fuzz tests taking a testing.T will facilitate this.


--- Comment #9 by cznic ---
[Quoting](https://github.com/dvyukov/go-fuzz/issues/154#issue-208081801) @dvyukov 

> I would appreciate if you drop a line there if you found fuzzing useful and a brief of your success story.

It was very useful for me - found bugs in several lexers.

--- Comment #10 by mvdan ---
I use it regularly on a lexer/parser/formatter for Bash (https://github.com/mvdan/sh).

Having it be a first-class citizen would simplify things for me and for contributors.

--- Comment #11 by dsnet ---
Found a bug in the C decoder for [google/brotli](https://github.com/google/brotli/issues/502) by fuzzing a [Go implementation of a Brotli decoder](https://github.com/dsnet/compress/blob/development/internal/tool/fuzz/brotli/brotli.go).

Also found some divergences in Go bzip2 decoders from the canonical C decoder ([this](https://github.com/dsnet/compress/commit/f98e3a5d89123bcef6be2ecd073ebec31cf2dbd2) and #18516). All by [fuzzing](https://github.com/dsnet/compress/blob/development/internal/tool/fuzz/bzip2/bzip2.go).


--- Comment #12 by fatih ---
My coworker at DigitalOcean was working on a side project to make fuzzing easier. Check his repo out here: https://github.com/tam7t/cautious-pancake Adding it here as I think it would be a valuable piece of information for this discussion. 

--- Comment #13 by dgryski ---
The README for go-fuzz lists a number of "Trophies", ( https://github.com/dvyukov/go-fuzz#trophies ) the majority of which are from the standard library, but about 20% of which are external to the Go standard libraries.

A GitHub search for Go source files with the `gofuzz` build tag gives ~2500 results: https://github.com/search?l=Go&q=gofuzz&type=Code&utf8=%E2%9C%93

My tutorial on fuzzing ( https://medium.com/@dgryski/go-fuzz-github-com-arolek-ase-3c74d5a3150c ) gets  50-60 "reads" per month (according to medium's stats).

--- Comment #14 by Kubuxu ---
Feature that would be also important (at least for me) would be ease of turning some selected Fuzz test cases into permanent tests. Simplest way to do it would be exporting the case data in go byte array and calling `FuzzXXX` function from `TestXXX` function but if `FuzzXXX` accepts `*testing.F` struct type it won't be possible.

--- Comment #15 by DavidVorick ---
Yes, we've found fuzzing useful in our projects multiple times. Especially sensitive code, the fuzzer will frequently find edge cases that we missed. Encoding, networking, and generally things that depend on user input.

I will say that most of the benefit is usually seen in the first tiny bit of fuzzing. There's a pretty strong diminishing returns as you continue to fuzz, at least that's what we've found.

--- Comment #16 by dvyukov ---
As you can understand, I am very supportive for this. Traditional testing is just not enough for modern development speeds. I am ready to dedicate some time to work on parts of this.

Throwing some ideas onto the table:

1. To flesh out the interface, we don't need to implement coverage nor any actual smartness. The interface should work if we just feed in completely random data, it will be just less useful. But I think it's the right first step. We can transparently add smartness later.

2. It would be nice to have some default location for corpus, because it will make onboarding easier. The location probably needs to be overridable with go test flag or GOFUZZ env var.

3. I think it's "must have" that fuzz funciton runs during normal testing. If corpus is present, each input from corpus is executed once. Plus we can run N random inputs.

4. Thinking how we can integrate continuous fuzzing into Go std lib testing (including corpus management) would be useful to ensure that it will also work for end users in their setups.

5. go command (or whatever runs fuzz function) might need some additional modes. For example, execute 1 given input, useful for crash debugging. Or, run all programs from corpus and dump code coverage report.

6. I am ready to give up on `f.Useful()` and `f.Discard()` for simplicity (as far as I understand that come from go-fuzz return values). They were never proven to be useful enough. For `Discard` Fuzz function can just return. And fuzzer can try to figure out `Useful` automatically.

7. In some cases Fuzz function needs more than just []byte. For example, regexp test needs the regular expression and a string to match. Other tests may need some additional int's and bool's. It's possible to manually split []byte into several strings and also take some bits as int's and bool's. But it's quite inconvenient and can negatively affect fuzzing efficiency (fuzzer can do better if it understands more about input structure). So we could consider allowing Fuzz function to accept a set of inputs with some restrictions on types, e.g. `FuzzFoo(f *testing.F, s1, s2 string, x int, b bool)`. But this can be added later as backwards compatible extension. Just something to keep in mind.

8. An alternative interface could be along the following lines:
```go
func FuzzFoo(f *testing.F) {
  var data []byte
  f.GetRandomData(&data)
  // use data
}
```
`GetRandomData` must be called once and always with the same type.
Since the function now does not accept the additional argument, we can make it a _normal_ test:
```go
func TestFoo(t *testing.T) {
  var data []byte
  testing.GetRandomData(&data)
  // use data
}
```
This recalls `testing/quick` interface considerably, so maybe we could just use `testing/quick` for this.
go tool will need to figure out that this is a fuzzing function based on the call to `testing.GetRandomData`.


--- Comment #17 by dvyukov ---
> I will say that most of the benefit is usually seen in the first tiny bit of fuzzing. There's a pretty strong diminishing returns as you continue to fuzz, at least that's what we've found.

That's true to some degree, but not completely. It depends on (1) complexity of your code, (2) rate of change of your code, (3) smartness of the fuzzer engine. If your code is simple and doesn't change, then fuzzer will find everything it can in minutes. However, if your code change often, you want to run fuzzing continuously as regression testing. If your code is large and complex and fuzzer is smart enough, then it can manage to uncover complex bugs only after significant time.
One example is this bug in OpenSSL bignum asm implementation that we've found after several CPU years of fuzzing: https://github.com/google/fuzzer-test-suite/tree/master/openssl-1.1.0c
Another example is our Linux kernel fuzzing which uncovers bugs at roughly constant rate over more than  a year (due to complexity of the code and frequent changes): https://github.com/google/syzkaller/wiki/Found-Bugs


--- Comment #18 by webRat ---
I'm fine with fuzzing, but the problem is that if you vendor in a library that fuzzes, then... you inherit all their corpus. So, I'm not a fan of corpus being checked into the project.

Case in point:
![screen shot 2017-02-16 at 9 35 58 am](https://cloud.githubusercontent.com/assets/59866/23025327/91c0564a-f42b-11e6-86ff-e60051d8115c.png)

Overall, I think fuzzing is a must have. Glad to see a proposal to make it easier.

--- Comment #19 by btracey ---
To confirm @dvyukov in https://github.com/golang/go/issues/19109#issuecomment-280315445 , it would be really nice to have supported types other than []byte.  We found bugs in both the gonum/blas implementation and the OpenBLAS library using fuzzing. It's possible to use go-fuzz, but it's kind of a pain to parse the []byte directly, (https://github.com/btracey/blasfuzz/blob/master/onevec/idamax.go). 

--- Comment #20 by kardianos ---
Suggest it goes under the subfolder testdata. Then any tools that ignore tests will also ignore this dir.

--- Comment #21 by dsnet ---
@dvyukov 
> I think it's "must have" that fuzz funciton runs during normal testing. If corpus is present, each input from corpus is executed once. Plus we can run N random inputs.

I have concerns about how much time this is going to add to testing. My experience with fuzzing is that compiling with the fuzz instrumentation takes a significant amount of time. I'm not sure this is something we want to inflict upon every use of `go test`.

--- Comment #22 by Kubuxu ---
@dsnet to execute corpus and check if it doesn't fail instrumentation isn't needed. Instrumentation is needed when you want to expend/improve the corpus.

--- Comment #23 by CAFxX ---
Should there be a story to make it easy to use external fuzzing engines?

--- Comment #24 by dsnet ---
@Kubuxu, I'm comfortable with running the Fuzz functions as a form of test without special instrumentation, but Dmitry comment suggested running with N random inputs, which implies having the instrumentation involved.

--- Comment #25 by kcc ---
My 2c (I am utterly ignorant about Go, but have [some](http://libfuzzer.info) [ideas](https://github.com/google/oss-fuzz) about fuzzing)

There are several major parts in coverage-guided fuzzing as I can see it: 
* instrumentation
* interface
* fuzzing engines' logic (how to mutate, choose elements to add to the corpus, etc)
* integration with the rest of Go testing infra (I won't comment on this one -- no opinion)

**Instrumentation** is better to be done in the compiler, this way it's the most efficient and easy to use. 
In LLVM we have these two kinds of instrumentation used for guided fuzzing: 
https://clang.llvm.org/docs/SanitizerCoverage.html#tracing-pcs-with-guards (control flow feedback)
https://clang.llvm.org/docs/SanitizerCoverage.html#tracing-data-flow (data flow feedback)

**The interface** must be as simple as possible. For C/C++ our interface (which we use with libFuzzer, AFL, hoggfuzz, and a few others) is:
```
extern "C" int LLVMFuzzerTestOneInput(const uint8_t *Data, size_t Size) {
  DoSomethingInterestingWithMyAPI(Data, Size);
  return 0;  // Non-zero return values are reserved for future use.
}
```
and the only thing I regret is that the return type is not void. 
IMHO, for the first version of the interface for Go fuzzing, the [go-fuzz](https://github.com/dvyukov/go-fuzz) approach is perfect:
```
func Fuzz(data []byte) int
```
(again, not confident about `int` return value)

**Fuzzing engines** and the interface should be independent. 
It should be possible to plug any fuzzing engine (not necessary written in Go) to fuzz a Go fuzz target.
Such fuzzing engine may need to understand the feedback provided by the instrumentation though. 
E.g. I'd love to try libFuzzer/AFL on the Go targets. 
And by *fuzzing engine* we should understand a wider class of tools, including e.g. [concolic execution](https://en.wikipedia.org/wiki/Concolic_testing) tools. 

And, it would be nice to have the new fuzzing engine(s) to behave similar to AFL, libFuzzer, and go-fuzz
so that they are easier to integrate with continuous fuzzing service(s) (e.g. [oss-fuzz](https://github.com/google/oss-fuzz))

> Should there be a story to make it easy to use external fuzzing engines?

Absolutely, see above. 

> it would be really nice to have supported types other than []byte. 

Maybe. 
For the really complex data structures our current answer is to use protobufs as the input: 
https://github.com/google/libprotobuf-mutator
There is also a middle ground where you need to fuzz e.g. a pair of strings. 
But I would rather have a standard adapter from from []byte into a pair of strings than to complicate the interface. 

> Are there cases where a typical user would be expected to modify the corpus themselves?

Corpus is not a constant. It evolves as long as the code under test changes, fuzzing techniques evolve, and simply more CPU hours are spent fuzzing. 
We typically store a seed corpus in RCS, maintain a larger corpus on the fuzzing service, 
and periodically merge it back to RCS. 

Note: a corpus stored in RCS allows to perform regression testing (w/o fuzzing)

>  I also want to have cmd/cover built on compiler instrumentation to support branch coverage, but that's off-topic to this issue.

Not too much off-topic. 
This [approach](https://clang.llvm.org/docs/SanitizerCoverage.html#tracing-pcs-with-guards) in LLVM allows us to get various kinds of coverage data with the same compiler instrumentation, by just re-implementing the callbacks. 

> I'm fine with fuzzing, but the problem is that if you vendor in a library that fuzzes, then... you inherit all their corpus. So, I'm not a fan of corpus being checked into the project.


This is a price worth paying since the corpus often turns out to be a great *regression* test.

> I have concerns about how much time this is going to add to testing. My experience with fuzzing is that compiling with the fuzz instrumentation takes a significant amount of time. I'm not sure this is something we want to inflict upon every use of go test.

If you don't enable fuzzing instrumentation (which won't be on by default, I think) you won't pay for it. 



--- Comment #26 by kcc ---
A separate topic worth thinking about is fuzzing for equivalence between two implementations of the same protocol. 

Imagine your code has 
`func ReferenceFoo(data []byte) SomeType` and 
`func ExperimentalOptimizedFoo(data []byte) SomeType`. 

Then you can fuzz the following target to verify that the two implementations match:
```
func Fuzz(data []byte) int {
    if ReferenceFoo(data) != ExperimentalOptimizedFoo(data) {
       panic("ouch!")
    }
    return 0
}
```

This works pretty well when both things are implemented in Go. 
But imagine you are porting to Go something previously written in C.
Here is a write up that describes one possible solution: 
https://moderncrypto.org/mail-archive/hacs/2017/000001.html
(in short: have two processes running in parallel and exchanging data via shared memory or some such)

--- Comment #27 by FiloSottile ---
I love this.

And I think a good solution to the corpus location, like

* defaulting to `testdata/FuzzXxx/`
* run (only) the corpus cases w/o flags

would 

* remove the need to duplicate code to "freeze" certain testcases
* avoid sacrificing the API to fit it in a `testing.T`
* be a more elegant solution that doesn't require putting binary data in source files

Projects that don't commit the corpus could use `-fuzzcorpus` (or similar) when fuzzing, and then copy the test cases they want to run every time in the `testdata` folder and check them in.

Actual fuzzing could be controlled by `-fuzztime` (like `-benchtime`).

--- Comment #28 by minux ---
Fuzzing is basically coverage based randomized testing, and we already have
a randomized testing package: testing/quick.

I think we shouldn't limit ourselves to just fuzzing a []byte, the fuzz
function should take arbitrary type supported by testing/quick.
i.e. if I'm fuzzing an integer sort routine, I should be able to write:

func FuzzIntSort(f *testing.F, input []int) {
   // ...
}

Also, if the function takes a struct, this also opens door to use field
tags (or even methods) to hint/provide non-trivial data validity
requirements to the fuzz engine in order to avoid having the engine
discover the restriction itself.

Limiting the input to []byte is more suited to protocol/parser fuzzing, but
with proper Go tool support, we can do significantly better.
Perhaps we can even merge this "coverage-based" part into testing/quick
itself.

Just some random (no pun intended) idea to think about.


--- Comment #29 by dvyukov ---
@dsnet No, I meant just plain random, not instrumentation involved.
Consider that you just wrote a Fuzz function (or checked out some code without corpus), now you can do 'go test' and already get some results from the Fuzz function.

--- Comment #30 by dvyukov ---
@kcc re fuzzing for equivalence
Testing Go vs C is simple with cgo, there is an example of testing regexp vs re2 in go-fuzz.
Testing several Go packages against each other is also trivial as there are no name clashes, just import both package.
So I don't think we need to do something special for this in the first version.
