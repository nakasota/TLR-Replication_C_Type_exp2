==== [Issue Title] ====
proposal: cmd/go: support embedding static assets (files) in binaries

==== [Issue Body] ====
There are many tools to embed static asset files into binaries:

* https://godoc.org/perkeep.org/pkg/fileembed / perkeep.org/pkg/fileembed/genfileembed
* https://godoc.org/github.com/gobuffalo/packr
* https://godoc.org/github.com/knadh/stuffbin
* https://github.com/rakyll/statik
* Bazel [go_embed_data](https://github.com/bazelbuild/rules_go/blob/master/go/extras.rst#go-embed-data)

Actually, https://tech.townsourced.com/post/embedding-static-files-in-go/ lists more:

* vfsgen - https://github.com/shurcooL/vfsgen
* go.rice - https://github.com/GeertJohan/go.rice
* statik - https://github.com/rakyll/statik
* esc - https://github.com/mjibson/esc
* go-embed - https://github.com/pyros2097/go-embed
* go-resources - https://github.com/omeid/go-resources
* statics - https://github.com/go-playground/statics
* templify - https://github.com/wlbr/templify
* gnoso/go-bindata - https://github.com/gnoso/go-bindata
* shuLhan/go-bindata - https://github.com/shuLhan/go-bindata
* fileb0x - https://github.com/UnnoTed/fileb0x
* gobundle - https://github.com/alecthomas/gobundle
* parcello - https://github.com/phogolabs/parcello

## Proposal

I think it's time to do this well once & reduce duplication, adding official support for embedding file resources into the cmd/go tool.

## Problems with the current situation:

* There are too many tools
* Using a go:generate-based solution bloats the git history with a second (and slightly larger) copy of each file.
* Not using go:generate means not being `go install`-able or making people write their own Makefiles, etc.

## Goals:

* don't check in generated files
* don't generate *.go files at all (at least not in user's workspace)
* make `go install` / `go build` do the embedding automatically
* let user choose per file/glob which type of access is needed (e.g. []byte, `func() io.Reader`, `io.ReaderAt`, etc)
* Maybe store assets compressed in the binary where appropriate (e.g. if user only needs an `io.Reader`)? (**edit**: but probably not; see comments below)
* **No code execution at compilation time**; that is a long-standing Go policy. `go build` or `go install` can not run arbitrary code, just like `go:generate` doesn't run automatically at install time.

The two main implementation approaches are `//go:embed Logo logo.jpg` or a well-known package (`var Logo = embed.File("logo.jpg")`).

## go:embed approach

For a `go:embed` approach, one might say that any `go/build`-selected `*.go` file can contain something like:

```
//go:embed Logo logo.jpg
```

Which, say, compiles to:

```go
func Logo() *io.SectionReader
```

(adding a dependency to the `io` package)

Or:

```
//go:embedglob Assets assets/*.css assets/*.js
```
compiling to, say:
```
var Assets interface{
     Files() []string
     Open func(name string) *io.SectionReader
} = runtime.EmbedAsset(123)
```

Obviously this isn't fully fleshed out. There'd need to be something for compressed files too that yield only an `io.Reader`.

## embed package approach

The other high-level approach is to not have a magic `//go:embed` syntax and instead just let users write Go code in some new `"embed"` or `"golang.org/x/foo/embed"` package:

```
var Static = embed.Dir("static")
var Logo = embed.File("images/logo.jpg")
var Words = embed.CompressedReader("dict/words")
```

Then have cmd/go recognize the calls to embed.Foo("foo/*.js") etc and glob do the work in cmd/go, rather than at runtime. Or maybe certain build tags or flags could make it fall back to doing things at runtime instead. Perkeep (linked above) has such a mode, which is nice to speed up incremental development where you don't care about linking one big binary.

## Concerns

* Pick a style (//go:embed* vs a magic package).
* Block certain files?
    * Probably block embedding `../../../../../../../../../../etc/shadow`
    * Maybe block reaching into `.git` too


==== [Comments] ====

--- Comment #1 by ianlancetaylor ---
It's worth considering whether `embedglob` should support a complete file tree, perhaps using the `**` syntax supported by some Unix shells.

--- Comment #2 by ghost ---
Some people would need the ability to serve the embedded assets with HTTP using the `http.FileServer`.

I personally use either mjibson/esc (which does that) or in some cases my own file embedding implementation which renames files to create unique paths and adds a map from the original paths to the new ones, e.g. `"/js/bootstrap.min.js": "/js/bootstrap.min.827ccb0eea8a706c4c34a16891f84e7b.js"`. Then you can use this map in the templates like this: `href="{{ static_path "/css/bootstrap.min.css" }}"`.

--- Comment #3 by cespare ---
I think a consequence of this would be that it would be nontrivial to figure out what files are necessary to build a program.

The `//go:embed` approach introduces another level of complexity too. You'd have to parse the magic comments in order to even typecheck the code. The "embed package" approach seems friendlier to static analysis.

(Just musing out loud here.)

--- Comment #4 by bradfitz ---
@opennota, 

> would need the ability to serve the embedded assets with HTTP using the `http.FileServer`.

Yes, the first link above is a package I wrote ([in 2011, before Go 1](https://github.com/perkeep/perkeep/commit/81547a9eb6105d3a4551acde9b4ffc27725a689c)) and still use, and it supports using http.FileServer: https://godoc.org/perkeep.org/pkg/fileembed#Files.Open

--- Comment #5 by bradfitz ---
@cespare, 

> The //go:embed approach introduces another level of complexity too. You'd have to parse the magic comments in order to even typecheck the code. The "embed package" approach seems friendlier to static analysis.

Yes, good point. That's a very strong argument for using a package. It also makes it more readable & documentable, since we can document it all with regular godoc, rather than deep in cmd/go's docs.

--- Comment #6 by agnivade ---
@bradfitz - Do you want to close this https://github.com/golang/go/issues/3035 ?

--- Comment #7 by bradfitz ---
@agnivade, thanks for finding that! I thought I remembered that but couldn't find it. Let's leave it open for now and see what others think.


--- Comment #8 by balasanjay ---
If we go with the magic package, we could use the unexported type trick to ensure that callers pass compile-time constants as arguments: https://play.golang.org/p/RtHlKjhXcda.

(This is the strategy referenced here: https://groups.google.com/forum/#!topic/golang-nuts/RDA9Hag8RZw/discussion)

--- Comment #9 by AlexRouSg ---
One concern I have is how would it hanle invividual or all assets being too big to fit into memory and whether there would be maybe a build tag or per file access option to choose between pritorizing access time vs memory footprint or some middle ground implementation.


--- Comment #10 by urandom ---
the way i've solved that problem (because of course i also have my own implementation :) ) is to provide an http.FileSystem implementation that serves all embedded assets. That way, you don't to rely on magic comments in order to appease the typechecker, the assets can easily be served by http, a fallback implementation can be provided for development purposes (http.Dir) without changing the code, and the final implementation is quite versatile, as http.FileSystem covers quite a bit, not only in reading files, but listing directories as well.

One can still use magic comments or whatever to specify what needs to be embedded, though its probably easier to specify all the globs via a plain text file.

--- Comment #11 by ianlancetaylor ---
@AlexRouSg This proposal would only be for files which are appropriate to include directly in the final executable.  It would not be appropriate to use this for files that are too big to fit in memory.  There's no reason to complicate this tool to handle that case; for that case, just don't use this tool.

--- Comment #12 by bradfitz ---
@ianlancetaylor, I think the distinction @AlexRouSg was making was between having the files provided as global `[]byte`s (unpageable, potentially writable memory) vs providing a read-only, on-demand view of an ELF section that can normally live on disk (in the executable), like via an `Open` call that returns an `*io.SectionReader`. (I don't want to bake in `http.File` or `http.FileSystem` into cmd/go or runtime... net/http can provide an adapter.)


--- Comment #13 by urandom ---
@bradfitz both http.File itself is an interface with no technical dependencies to the `http` package. It might be a good idea for any `Open` method to provide an implementation that conforms to that interface, because both the `Stat` and `Readdir` methods are quite useful for such assets

--- Comment #14 by bradfitz ---
@urandom, it couldn't implement http.FileSystem, though, without referring to the "http.File" name (https://play.golang.org/p/-r3KjG1Gp-8).

--- Comment #15 by rsc ---
@robpike and I talked through a proposal for doing this years ago (before there was a proposal process) and never got back to doing anything. It's been bugging me for years that we never finished doing that. The idea as I remember it was to just have a special directory name like "static" containing the static data and automatically make them available through an API, with no annotations needed.

I'm not convinced about the complexity of a "compressed vs not" knob. If we do that, then people will want us to add control over which compression, compression level, and so on. All we should need to add is the ability to embed a file of plain bytes. If users want to store compressed data in that file, great, the details are up to them and there's no API needed on Go's side at all.

--- Comment #16 by jayconrod ---
A couple thoughts:

* It should not be possible to embed any file outside the module doing the embedding. We need to make sure files are part of module zip files when we create them, so that also means no symbolic links, case conflicts, etc. We can't change the algorithm that produces zip files without breaking sums.
* I think it's simpler to restrict embedding to be in the same directory (if `//go:embed` comments are used) or a specific subdirectory (if `static` is used). This makes it a lot easier to understand the relationship between packages and embedded files.

Either way, this blocks embedding `/etc/shadow` or `.git`. Neither can be included in a module zip.

In general, I'm worried about expanding the scope of the go command too much. However, the fact that there are so many solutions to this problem means there probably ought to be one official solution.

I'm familiar with `go_embed_data` and `go-bindata` (of which there are several forks), and this seems to cover those use cases. Are there any important problems the others solve that this doesn't cover?

--- Comment #17 by DeedleFake ---
Blocking certain files shouldn't be too hard, especially if you use a `static` or `embed` directory. Symlinks might complicate that a bit, but you can just prevent it from embedding anything outside of the current module or, if you're on GOPATH, outside of the package containing the directory.

I'm not particularly a fan of a comment that compiles to code, but I also find the pseudo-package that affects compilation to be a bit strange as well. If the directory approach isn't used, maybe it might make a bit more sense to have some kind `embed` top-level declaration actually built into the language. It would work similarly to `import`, but would only support local paths and would require a name for it to be assigned to. For example,

```go
embed ui "./ui/build"

func main() {
  file, err := ui.Open("version.txt")
  if err != nil {
    panic(err)
  }
  version, err = ioutil.ReadAll(file)
  if err != nil {
    panic(err)
  }
  file.Close()

  log.Printf("UI Version: %s\n", bytes.TrimSpace(version))
  http.ListenAndServe(":8080", http.EmbeddedDir(ui))
}
```

Edit: You beat me to it, @jayconrod.

--- Comment #18 by josharian ---
To expand on https://github.com/golang/go/issues/35950#issuecomment-561703346, there is a puzzle about the exposed API. The obvious ways to expose the data are `[]byte`, `string`, and `Read`-ish interfaces.

The typical case is that you want the embedded data to be immutable. However, all interfaces exposing `[]byte` (which includes `io.Reader`, `io.SectionReader`, etc.) must either (1) make a copy, (2) allow mutability, or (3) be immutable despite being a `[]byte`. Exposing the data as `string`s solves that, but at the cost of an API that will often end up requiring copying anyway, since lots of code that consumes embedded files eventually requires byte slices one way or another.

I'd suggest route (3): be immutable despite being a `[]byte`. You can enforce this cheaply by using a readonly symbol for the backing array. This also lets you safely expose the same data as a `[]byte` and a `string`; attempts to mutate the data will fail. The compiler can't take advantage of the immutability, but that's not too great of a loss. This is something that toolchain support can bring to the table that (as far as I know) none of the existing codegen packages do.

(A third party codegen package could do this by generating a generic assembly file containing `DATA` symbols that are marked as readonly, and then short arch-specific assembly files exposing those symbols in the form of `string`s and `[]byte`s. I wrote [CL 163747](https://go-review.googlesource.com/c/go/+/163747) specifically with this use case in mind, but never got around to integrating it into any codegen packages.)

--- Comment #19 by DeedleFake ---
I'm unsure what you're talking about in terms of immutability. `io.Reader` already enforces immutability. That's the entire point. When you call `Read(buf)`, it copies data into the buffer that _you_ provided. Changing `buf` after that has zero effect on the internals of the `io.Reader`.

--- Comment #20 by bradfitz ---
I agree with @DeedleFake. I don't want to play games with magic `[]byte` array backings. It's okay to copy from the binary into user-provided buffers.


--- Comment #21 by gdamore ---
Just another wrinkle here -- I have a different project which uses DTrace source code (embedded).  This is sensitive to differences between \n and \r\n.  (We can argue whether this is a dumb thing in DTrace or not -- that's beside the point and it is the situation today.)

It's super useful that backticked strings treat both as \n regardless of how they appear in source, and I rely on this with a go-generate to embed the DTrace.

So if there is an embed file added to the go command, I would gently suggest that options to change the handling of CR/CRLF might come in very handy, particularly for folks who might be developing on different systems where the default line endings can be a gotcha.

--- Comment #22 by rsc ---
Like with compression, I'd really like to stop at "copy the file bytes into the binary". CR/CRLF normalization, Unicode normalization, gofmt'ing, all that belongs elsewhere. Check in the files containing the exact bytes you want. (If your version control can't leave them alone, maybe check in gzipped content and gunzip them at runtime.) There are _many_ file munging knobs we could imagine adding. Let's stop at 0.

--- Comment #23 by rsc ---
It may be too late to introduce a new reserved directory name, as much as I'd like to.
(It wasn't too late back in 2014, but it's probably too late now.)
So some kind of opt-in comment may be necessary.

Suppose we define a type runtime.Files. Then you could imagine writing:

    //go:embed *.html (or static/* etc)
    var files runtime.Files

And then at runtime you just call files.Open to get back an `interface { io.ReadSeeker; io.ReaderAt }` with the data. Note that the var is unexported, so one package can't go around grubbing in another package's embedded files.

Names TBD but as far as the mechanism it seems like that should be enough, and I don't see how to make it simpler. (Simplifications welcome of course!)

--- Comment #24 by rsc ---
Whatever we do, it needs to be possible to support with Bazel and Gazelle too. That would mean having Gazelle recognize the comment and write out a Bazel rule saying the globs, and then we'd need to expose a tool (go tool embedgen or whatever) to generate the extra file to include in the build (the go command would do this automatically and never actually show the extra file). That seems straightforward enough.

--- Comment #25 by gdamore ---
If various munging won't do the trick, then that's an argument against using this new facility.  It's not a stopper for me -- I can use go generate like I've been doing, but it means I cannot benefit from the new feature.

With respect to munging in general -- I can imagine a solution where someone provides an implementation of an interface (something like a Reader() on one side, and something to receive the file on the other -- maybe instantianted with an io.Reader from the file itself) -- which the go cmd would build and run to prefilter the file before embedding.  Then folks can provide whatever filter they want.  I imagine some folks would provide quasi-standard filters like a dos2unix implementation, compression, etc.  (Maybe they should be chainable even.)

I guess there'd have to be an assumption that whatever the embedded processor is, it must be compilable on ~every build system, as go would be building a temporary native tool for this purpose.

--- Comment #26 by magical ---
> It may be too late to introduce a new reserved directory name, as much as I'd like to. [...] some kind of opt-in comment may be necessary.

If the files are only accessible through a special package, say `runtime/embed`, then importing that package could be the opt-in signal.

--- Comment #27 by bcmills ---
The `io.Read` approach seems like it could add significant overhead (in terms of both copying and memory footprint) for conceptually-simple linear operations like `strings.Contains` (such as in [`cmd/go/internal/cfg`](https://github.com/golang/go/blob/42db1da8e9def3490ed904594ad80e1090bff654/src/cmd/go/internal/cfg/cfg.go#L229)) or, critically, `template.Parse`.

For those use-cases, it seems ideal to allow the caller to choose whether to treat the whole blob as a (presumably memory-mapped) `string` or an `io.ReaderAt`.

That seems compatible with the general `runtime.Files` approach, though: the thing returned from `runtime.Files.Open` could have a `ReadString() string` method that returns the memory-mapped representation.

--- Comment #28 by bcmills ---
> some kind of opt-in comment may be necessary.

We could do that with the `go` version in the `go.mod` file. Before `1.15` (or whatever) the `static` subdirectory would contain a package, and at `1.15` or higher it would contain embedded assets.

(That doesn't really help in `GOPATH` mode, though.)

--- Comment #29 by magical ---
> I'm not convinced about the complexity of a "compressed vs not" knob. If we do that, then people will want us to add control over which compression, compression level, and so on. All we should need to add is the ability to embed a file of plain bytes. 

While i appreciate the drive for simplicity, we should also make sure we're meeting users' needs.

12 out of 14 of the tools listed at https://tech.townsourced.com/post/embedding-static-files-in-go/#comparison support compression, which suggests that it is a pretty common requirement.

It's true that one could do the compression as a pre-build step outside go, but that would still require 1) a tool to do the compression 2) checking some kind of `assets.zip` blob into vcs 3) probably a utility library around the embed api to undo the compression. At which point it is unclear what the benefit is at all.

Three of the goals listed in the initial proposal were:

* don't check in generated files
* make go install / go build do the embedding automatically
* store assets compressed in the binary where appropriate

If we read the second of these as "don't require a separate tool for embedding" then not supporting compressed files directly or indirectly fails to meet all three of these goals.

--- Comment #30 by jimmyfrasche ---
Does this need to be package level? Module level seems a better granularity since most likely one module = one project.

Since this directory wouldn't contain Go code† could it be something like `_static`?

† or, if it is, it would be treated as arbitrary bytes whose name happens to end in ".go" instead of as Go code to be compiled

If it's one special directory, the logic could just be slurp up anything and everything in that directory tree. The magic embed package could let you do something like `embed.Open("img/logo.svg")` to open a file in a subdirectory of the asset tree.

Strings seem good enough. They can easily be copied into `[]byte` or converted into a `Reader`. Code generation or libraries could be used to provide fancier APIs and handle things during `init`. That could include decompression or creating an `http.FileSystem`.

Doesn't Windows have a special format for embedding assets. Should that be used when building a Windows executable? If so, does that have any implications for the kinds of operations that can be provided?
