==== [Issue Title] ====
proposal: all: add bare metal ARM support

==== [Issue Body] ====
Hello,

I'd like to request reconsideration of our [previous proposal](https://github.com/golang/go/issues/37503) (declined) as there have been new simplifications in our patch that should solve some, if not all, concerns previously raised.

Small recap: our [TamaGo project](https://github.com/f-secure-foundry/tamago) adds support for vanilla Go runtime and packages execution on ARMv7 bare metal. Please see the [original issue](https://github.com/golang/go/issues/37503) which remains valid in its initial description.

The main changes of our most [recent integration](https://github.com/golang/go/issues/37503#issuecomment-817561764) are as follows:

  * we completely removed any ARM exception handling or low-level assembly, with the exception of rt0 entry point support ([here](https://github.com/f-secure-foundry/tamago-go/blob/tamago1.16.5/src/runtime/rt0_tamago_arm.s) and [here](https://github.com/f-secure-foundry/tamago-go/blob/tamago1.16.5/src/runtime/sys_tamago_arm.s), which is required and included in Go for all supported architectures and a `CallOnG0` function to facilitate external integration of exception handlers (which is very similar to [existing approaches](https://github.com/f-secure-foundry/tamago-go/blob/tamago1.16.5/src/runtime/sys_windows_arm.s#L383)).

 * all remaining code is simple "glue" code adapter from other supported architectures and to extend support of a new `GOOS` keyword

 * runtime support in [os_tamago_arm.go](https://github.com/f-secure-foundry/tamago-go/blob/tamago1.16.5/src/runtime/os_tamago_arm.go) is much reduced compared to the [first proposed version](https://github.com/f-secure-foundry/tamago-go/blob/tamago1.13.8/src/runtime/os_tamago_arm.go) and now consists only of stubs and simple "glue" code.

Overall our [latest patch](https://github.com/golang/go/compare/go1.16.5...f-secure-foundry:tamago1.16.5.diff) has ~4200 insertions over 133 files, however the overwhelming majority of changes are one-liners two add GOOS=tamago support, almost verbatim clones of existing code (lock_js.go > lock_tamago.go,, mem_plan9.go > mem_tamago.go) and os_tamago_arm.go remains the largest newly added file.

We think these changes should address the [main concerns](https://github.com/golang/go/issues/37503#issuecomment-597777282) that resulted the rejection of our [previous proposal](https://github.com/golang/go/issues/37503).

Our new patch should not raise any longer concerns on chip erratas as it is as agnostic as possible in the low level management of SoC specific, or even ARM, architecture. It allows [external packages](https://pkg.go.dev/github.com/f-secure-foundry/tamago/arm) to provide ARM support.

We demonstrated useful implementation of all Go packages, including os and net, for instance we successfully enable networking with gVisor in our [Ethernet over USB driver](https://github.com/f-secure-foundry/imx-usbnet).

Since our last issue we implemented a full Trusted Execution Environment ([GoTEE](https://github.com/f-secure-foundry/GoTEE)) with this framework as well as a full OpenPGP/FIDO U2F smartcard ([GoKey](https://github.com/f-secure-foundry/GoKey)).

Others have [expressed interest](https://groups.google.com/g/golang-dev/c/SnN7P1Yq5H8) for running Go on the bare metal and we also received contributions which extend support to other platforms such as [Raspberry PIs](https://pkg.go.dev/github.com/f-secure-foundry/tamago@v0.0.0-20210615175023-a3a2165874e8/board/raspberrypi) using the same original Go distribution patch.

Given the recent refactoring that takes chip errata concerns out of the way, provides a more minimal patch, and the recent demonstrations of what can be developed with this, I kindy ask re-consideration of our proposal.

Thanks!


==== [Comments] ====

--- Comment #1 by thanm ---
Hello,

In the discussion of the previous proposal, there was some minimal talk about builders for GOOS=none, e.g. https://github.com/golang/go/issues/37503#issuecomment-592514724 (which basically boils down to "Will there be a builder? Yes, there will be a builder.").

I think it would be useful to have a bit more concrete/detailed conversation about builder support.

To wit: suppose the proposal is accepted, and a GOOS=none builder is set up. Will this builder be capable of running "all.bash"?  Will the builder provide full support for "gomote" operations?  Suppose that someone from the Go team checks in a change to the compiler or linker, and a test fails on the GOOS=none builder.  Who will look at that failure and how?

Thanks.


--- Comment #2 by abarisani ---
all.bash currently runs on all tamago-go releases, I think overall builder and linker tests can happen identically to other architectures.

The challenge would only be for runtime tests that are written in a manner that depends on an OS being present, I am not sure how this is currently handled for platforms like plan9 or js. What I can say is that this can run under qemu.

--- Comment #3 by bcmills ---
For JS, iOS, and Android, tests are run by having a separate host for builds and invoking the binaries using `go_*_exec` scripts:
```
~/go$ find . -name go_*_exec*
./misc/wasm/go_js_wasm_exec
./misc/ios/go_ios_exec.go
./misc/android/go_android_exec.go
```

Presumably the TamaGo builder would need a similar script.

--- Comment #4 by bcmills ---
> The challenge would only be for runtime tests that are written in a manner that depends on an OS being present, I am not sure how this is currently handled for platforms like plan9 or js.

Plan 9 can run the actual Go toolchain, albeit slowly.

For JS, Android, and iOS, `cmd/dist` distinguishes between tests that build and invoke Go subprocesses and tests that should run directly on the builder. (Search for `registerHostTest` in `src/cmd/dist`.)

Test binaries that contain a mix of the two can use [`internal/testenv.MustHaveExec`](https://tip.golang.org/pkg/internal/testenv/#MustHaveExec) to mark that they need an OS capable of starting subprocesses. If there are other bits of OS functionality that could be missing, they may need additional `testenv` functions.

--- Comment #5 by abarisani ---
Understood, I see no problem in having a similar approach for TamaGo. We could provide an USB armory as separate host to receive the tests or maybe (easier) just have a script that spawns the test within qemu ?

--- Comment #6 by firelizzard18 ---
This may be of interest to @tinygo-org

/cc @deadprogram @aykevl @justinclift

--- Comment #7 by rsc ---
Why is it difficult to maintain this tree as a GitHub fork of golang/go?


--- Comment #8 by abarisani ---
It is currently not that difficult, but its inclusion upstream would help ensuring that a GOOS=none support is minded in relation to potentially breaking changes, that its quality is consistent with the rest of the Go distribution code and that it would remain available over time.

Secondarily it would also help promoting, and further develop, this use case among Go user base.

Allowing easier hooks to generic "GOOS=none" within Go can certainly spawn up more interesting uses beyond the specific TamaGo goals and implementation, so I think in general it would help the Go ecosystem.

--- Comment #9 by rsc ---
What you are saying is that it would move the maintenance burden for this code off of your team and onto the Go contributors more generally. Saying "its inclusion upstream would help ensuring that a GOOS=none support is minded in relation to potentially breaking changes" is another way of saying "it would be yet another special case, little-used port that slows down maintenance and development of the primary ports", or perhaps of saying (without realizing it) "we don't intend to keep up with your changes and want you to do it".

Contribution of new ports are "free like a puppy", to use the old Sun line: they are a gift that will require significant time and effort to keep alive. We already have a bunch of those, and inevitably the contributors move on, leaving us responsible for either continued upkeep (which takes away time we could be working on changes that benefit far more users) or removing the port (which makes us the bad guys). 

**I would much rather figure out what is making it difficult to keep this port out of tree and fix those underlying issues.** That would let you maintain the port as you see fit and decouple our development and yours. It would make clear who is responsible for ongoing maintenance and fixing issues. It would scale far better - we can't put every port into the main tree. And it would provide a model for the next niche port. 

--- Comment #10 by mvdan ---
I don't have a strong opinion either way, but: how does GOOS=none compare to, say, [GOARCH=loong64](https://github.com/golang/go/issues/46229)? If the point is to have someone responsible for its maintenance in-tree, perhaps Andrea would be up for that.

--- Comment #11 by abarisani ---
My team (more than once) expressed the firm intention to maintain this. Please stop saying that we want upstream inclusion to offload maintenance because this is simply not true.

This proposal specifically would ease integration of TamaGo like ports in Go, so the way I see it it specifically addresses the current challenges in doing so by acting as a generic ARM template and possibly in the future for other architectures.

This effort is to promote a generic framework and hooks to be accepted upstream with our contribution to maintain it.

--- Comment #12 by abarisani ---
Let me be more clear and re-state my thinking. I think our patch specifically helps addressing the challenges in creating new ports of this kind and this is why we think it should be upstreamed (with our firm intention to maintain it at least for ARM).

It is not the intention of our proposal to just "offload" this for our own convenience. We are excited about using Go on the bare metal, promote its use and help make it easy for all while preserving this possibility in the process.

--- Comment #13 by rsc ---
> I don't have a strong opinion either way, but: how does GOOS=none compare to, say, GOARCH=loong64? If the point is to have someone responsible for its maintenance in-tree, perhaps Andrea would be up for that.

This is a good question. Empirically, GOARCHes require far less work to maintain than GOOSes. From Go's point of view, architectures vary far less than operating systems do: GOARCH variations essentially never get in the way of new work, while GOOS variations often do. (The variation of "no operating system" would be particularly different. In fact, the current patch assumes a single-CPU system - there is no threading or interrupts or note implementation. This is going to limit its applicability. And of course scaling up to a proper multiprocessor implementation would be significantly more work and more code to maintain.)

> My team (more than once) expressed the firm intention to maintain this. Please stop saying that we want upstream inclusion to offload maintenance because this is simply not true.

I appreciate the present intention to maintain the code. I don't doubt at all what you are saying about your current intentions. But suppose five years from now your priorities shift. In that case, we would be left with another port that we must either maintain ourselves or remove from the tree (as I laid out before). This is why we must be willing to take on maintenance of the port in order for it to land in the tree. The current variety of ports (again, especially GOOSes) already creates a real drag on being able to make important changes to, for example, the garbage collector and the scheduler.

For ports that we cannot commit to long-term maintenance of, keeping them out-of-tree would make the responsibility much clearer. For as long as you maintain them, they would work and keep up with Go. And if at some point priorities shift and that project was no longer maintained, it would be clear what was no longer maintained. Either way, again, the responsibilities are much clearer if the port is out-of-tree.

I realize that we don't have great support for out-of-tree ports right now. But again I think it is worth figuring out what we could do to make that better rather than default to continuing to add every possible new port to the main tree. Good support for out-of-tree ports would also provide a better path for ports that do eventually need to be removed from the main tree.

--- Comment #14 by mvdan ---
> Good support for out-of-tree ports would also provide a better path for ports that do eventually need to be removed from the main tree.

I would like to see that future happen. The closest thing we have right now are [first-class ports](https://github.com/golang/go/issues/38874), but it's not quite the same as it still encourages all possible ports to live in a single place. 

--- Comment #15 by abarisani ---
On contributors leaving or losing interest...well that can be used as an argument against pretty much any contribution can't it? If any maintainers lose interest on the code they maintain the problem would be identical. If there are others that can pick the work up fine, otherwise the feature would be dropped I guess. Certainly I can see upstream inclusion of a GOOS giving it better chance of getting more manpower than keeping it external. Not sure how anyone is supposed to counteract this argument to be honest...

On multiprocessor support, as the idea is for this GOOS to be a general template I am happy to adapt for easier integration of SMP CPUs, in fact this could be a great exercise on making it closer to what you ask in the first place (easy addition if external architectures in GOOS=none).

On GOOS being harder than a new GOARCH, I am not sure I agree 100%. Some architectures are fairly broad in their scope while this is very a very specific and unique GOOS which actually has no dependency on a specific OS.

So I think this effort, if generalized correctly, should not need too much maintenance in the long term or anyway its maintenance would be quite similar to what plan9/nacl/js are doing...in fact most of the complex bits are 100% cloned from these GOOSes.

If there is interest I am happy to ponder an abstraction that allows SMP to take place as that is a valid concern.

--- Comment #16 by ianlancetaylor ---
> On contributors leaving or losing interest...well that can be used as an argument against pretty much any contribution can't it?

Not really.  It can only be used as an argument against a change that the core Go team is not able to maintain.  Relatively few changes fall into that category.

> On GOOS being harder than a new GOARCH, I am not sure I agree 100%.

This isn't hypothetical, it's based on tracking the areas that take the most time for Go's compiler and runtime work over the last couple of years.

I personally don't feel very strongly about this particular proposal.  But I hope we can all agree that it would be better if it were easier to maintain Go ports out of the main repository.  That state is clearly better than where we are today in every respect, and it also addresses this proposal.  So let's try to understand how much work that would be, and whether it is a feasible goal.  Thanks.

--- Comment #17 by abarisani ---
I think we are confusing layers a little bit (including myself).

Our proposal is a generic GOOS=none which would create a generic layer to extend the same GOOS to any bare metal SoC/architecture with external packages (like we are doing with [tamago](https://github.com/f-secure-foundry/tamago)).

Bare metal (a.k.a. supervisor/system mode) is different than a generic GOOS in user mode (e.g. linux, macOS) which typically relies on system calls.

While I do think that our work could be somewhat be adapted to be so generic that it would also allow arbitrary user mode GOOS architectures, I probably think it would not be the best or more efficient approach due to this fundamental differences in execution mode.

What I care about is promoting (and preserving) the fact that Go can be a prime language on OS-less embedded systems, and while I'd be pleased if our work could also help Go in achieving cleaner abstraction for arbitrary GOOSes, fundamentally I am not sure this patch would be the right beginning for it, as GOOS=none is likely very different than GOOS=<some_other_os_running_go_in_user_mode>.



--- Comment #18 by ALTree ---
So essentially your proposal is to just add a GOOS=none, which is actually a *plugin mechanism* that would let people implement support for a specific architecture (like ARM) using an external package? And then if you set GOOS=none *and* provide an external package like the one you linked above for ARM, you would be able to enable support for none/arm as a GOOS/GOARCH couple?

Because this is not very clear by reading this proposal. A few questions:

- What does GOOS=none do if you don't provide the external architecture implementation? (I suppose nothing). So a builder would actually target a specific couple like none/arm, pull the third party ARM implementation from github, and run all.bash on that?
- os_tamago_arm.go mentioned above (which actually you'd call os_none_arm.go I guess) makes me think that GOOS=none does not provide a *completely independent* pluggable interface for GOARCHs, you would still need to commit ARM-support stubs in the main Go repo, but they're basically empty, and then the real implementation is in the third party package. Then if we wanted none/riscv64 you'd need a small patch in the Go toolchain (with files like os_none_riscv64.go), and then a third party package would provide the actual riscv64 support. Is that right?
- How do people working on the Go toolchain make sure they're not breaking none/whatever? Or they shouldn't care, because it's essentially an out-of-tree third-party port? Of course you could argue that out-of-tree ports face the same issue.



--- Comment #19 by firelizzard18 ---
TinyGo is both an LLVM-based compiler for Go, and a partial set of replacement stdlibs. So not really a full port as I understand it. If I understand correctly, if a given stdlib, such as `runtime`, is present in TinyGo's root, the compiler uses that in preference to the upstream version. Otherwise, the compiler uses the upstream version. `GOOS=none` could simplify TinyGo if it reduced upstream stdlib's dependence on running in user space.

> How do people working on the Go toolchain make sure they're not breaking none/whatever?

It would be nice if there was a well defined API boundary, but something is better than nothing. Out-of-tree ports currently have no guarantee about stdlib internals, so Go toolchain developers not working about breaking out-of-tree `GOOS=none` ports won't be a change from the current status.

> What does GOOS=none do if you don't provide the external architecture implementation?

Could be a stub implementation with just enough filled in to run tests?

--- Comment #20 by rminnich ---
Time will tell, but I think it may be unfair to characterize this as a niche. 
I do recall ARM being characterized as a niche by some in the glibc community, including in this famous quote:
"Ulrich Drepper 2007-10-02 04:01:19 UTC
It's working fine everywhere but this carp architectures.  I'm not going to make
the code perform worse just because of Arm.  Providing your own copy of that
file if you care."

and now ARM deployments outnumber x86 deployments by at least 10x. But in the interim this attitude led to a full fork and eglibc. 

Is tamago a niche use? Go on a new platform is a niche use by definition. But should tamago become useful in, e.g., silicon root of trust (SROT) applications such as the usbarmory, then tamago might well end up as widely deployed as all other Go platforms *combined*, since SROT is becoming ubiquitous (SROT is used in all new chromebooks, and will be used in all new servers). Future platforms will include at least one SROT, and some have more. Further, I'm starting to like tamago as a potential stack for Baseboard Management Controllers (BMC), as opposed to the gigantic, and vulnerable, Linux-based stack that is used today. This goes beyond SROT.

I understand your argument for forking golang. The Go team can only do so much. But you may be playing with fire here, because one way this can go is not "fork per unaccepted port", but "one community fork for all unaccepted ports", i.e., a new organization supporting the second-class ports.  If enough momentum forms behind a "community Go fork" that's more friendly to new platforms, a new Go team outside Google might form. It would be friendlier to new ports as, e.g, Rust is, and the momentum and interest could move to community go. This is not a new story. Recall that the most commonly used BSD variant is not the original one.

I understand this is a tough situation, but you're in the enviable situation of having succeeded well enough that people want to use Go. While telling people to "just fork" is an option, forks have a way of diverging -- ref eglibc. Parallel organizations are created that can eventually outshine the original one. 

I think you also need to define the rules by which a sufficiently successful/widely used platform can be brought into the upstream tree from community go. It can't look hopeless.

That said, in anticipation that tamago will still not be accepted, I've created this:

https://github.com/community-go/go

The intent is this be a common place to support unaccepted/deprecated ports, or ports not quite ready for upstream but that might make the jump, with the current example being tamago. 

From this, we can try to learn how to make fork maintenance easy. Having maintained an out-of-tree port for several years for Harvey-OS, I can tell you it's anything but easy today; with luck we can improve the situation.

--- Comment #21 by mvdan ---
@rminnich if I might make a suggestion - best to not name the org "community-go", as that can confuse those stumbling upon it. Go as a projecy already has a community contributing to the golang org, after all. Perhaps something more specific like go-extra-ports?

--- Comment #22 by abarisani ---
> So essentially your proposal is to just add a GOOS=none, which is actually a _plugin mechanism_ that would let people implement support for a specific architecture (like ARM) using an external package? And then if you set GOOS=none _and_ provide an external package like the one you linked above for ARM, you would be able to enable support for none/arm as a GOOS/GOARCH couple?
> 

(taking the liberty to s/tamago/none/ while linking at tamago examples to show how this would look like)

Correct, the external package could then contribute:

* the ARM architecture specific parts which are not covered by the standard Go distribution (for example the [MMU configuration](https://pkg.go.dev/github.com/f-secure-foundry/tamago@v0.0.0-20210615175023-a3a2165874e8/arm#CPU.InitMMU), these are generic ARM functions that however different projects might decide to implement in a different manner, or simply to add more features such as our support for [ARM TrustZone](https://pkg.go.dev/github.com/f-secure-foundry/tamago@v0.0.0-20210615175023-a3a2165874e8/arm#CPU.NonSecure)) and which are also prone to errata (a problem highlighted in our previous proposal).

* the SoC specific support (e.g. NXP i.MX6 vs Raspberry Pi), including SoC specific [drivers](https://pkg.go.dev/github.com/f-secure-foundry/tamago@v0.0.0-20210615175023-a3a2165874e8/soc/imx6/usb).

* the various [board support packages](https://pkg.go.dev/github.com/f-secure-foundry/tamago/board).

* whatever utility might be handy or required, such as [DMA access](https://pkg.go.dev/github.com/f-secure-foundry/tamago@v0.0.0-20210615175023-a3a2165874e8/dma).

> Because this is not very clear by reading this proposal. A few questions:
> 
> * What does GOOS=none do if you don't provide the external architecture implementation? (I suppose nothing). So a builder would actually target a specific couple like none/arm, pull the third party ARM implementation from github, and run all.bash on that?

Without the external packages there are no drivers, so it's impossible to do any meaningful I/O or use anything other then the CPU.

> * os_tamago_arm.go mentioned above (which actually you'd call os_none_arm.go I guess) makes me think that GOOS=none does not provide a _completely independent_ pluggable interface for GOARCHs, you would still need to commit ARM-support stubs in the main Go repo, but they're basically empty, and then the real implementation is in the third party package. Then if we wanted none/riscv64 you'd need a small patch in the Go toolchain (with files like os_none_riscv64.go), and then a third party package would provide the actual riscv64 support. Is that right?

It's not completely independent, the following files would be GOARCH=arm dependent:

* the very initial assembly which acts as entry point: [rt0_none_arm.s](https://github.com/f-secure-foundry/tamago-go/blob/tamago1.16.5/src/runtime/rt0_tamago_arm.s), [sys_none_arm.s](https://github.com/f-secure-foundry/tamago-go/blob/tamago1.16.5/src/runtime/sys_tamago_arm.s). I believe these can be provided externally with a linker script, it would be less clean and convenient imho, but it can be done if desired.

* [asm_none_arm.s](https://github.com/f-secure-foundry/tamago-go/blob/tamago1.16.5/src/syscall/asm_tamago_arm.s), a quite short syscall wrapper.

* zsyscall_none_arm.go and zsysnum_none_arm.go are ARM specific, but would automatically generated from [syscall_none.go](https://github.com/f-secure-foundry/tamago-go/blob/tamago1.16.5/src/syscall/syscall_tamago.go), here we just copied what GO does for other architectures however I do think I could potentially refactor this to remove any ARM specific bits (as in the end I don't think there should be any).

* this [stub](https://github.com/f-secure-foundry/tamago-go/blob/tamago1.16.5/src/syscall/time_tamago_arm.s) probably doesn't need to be in asm and ARM specific.

* [os_none_arm.go](https://github.com/f-secure-foundry/tamago-go/blob/tamago1.16.5/src/runtime/os_tamago_arm.go) could be made non ARM specific (it isn't in fact) and be the main hook for external packages to add to the runtime (through `go:linkname` as we [do now](https://github.com/f-secure-foundry/tamago/blob/master/soc/imx6/imx6.go#L64)).

So I think I could make this completely independent from ARM if we really want to, otherwise even if we keep this scheme the patches for *_none_something else would be relatively simple and small to create and maintain.

> * How do people working on the Go toolchain make sure they're not breaking none/whatever? Or they shouldn't care, because it's essentially an out-of-tree third-party port? Of course you could argue that out-of-tree ports face the same issue.

I think the two most important pieces would be [lock_none.go](https://github.com/f-secure-foundry/tamago-go/blob/tamago1.16.5/src/runtime/lock_tamago.go) and [mem_none.go](https://github.com/f-secure-foundry/tamago-go/blob/tamago1.16.5/src/runtime/mem_tamago.go) (copied almost verbatim from js/wasm and plan9 respectively), however these are fairly self contained, with a clear goal and in my understanding they would entail a substantial change in the way Go works to be broken.

The residual risk  would be for the runtime, or some other vital standard package, to start relying on OS specific (e.g. system calls) aspects to perform basic operations. What allows Go to be so suited to the bare metal is its almost non-existent reliance on system calls for most of its core operations, which is what allows us to bring in [almost every package](https://github.com/f-secure-foundry/tamago/wiki/Import-report) without worries. Unless a testsuite for GOOS=none, with a sample external architecture such as tamago+arm, is included in Go standard build process this is a risk that will always remain. I am not suggesting this should also be addressed, I am just noting it for the sake of discussion.

--- Comment #23 by ianlancetaylor ---
@rminnich I agree with @mvdan that naming a new project community-go is unhelpful.  It's also premature.

Anyhow, I see two issues here.  The first is whether we can provide a reasonably stable runtime API to support arbitrary ports.  The second is whether we can provide a reasonably stable runtime API to support `GOOS=none`.  The second seems likely to be easier than the first, given the number of plan9 and windows specific files across the standard library.

--- Comment #24 by rminnich ---
I removed community-go. If we do decide to go with a fork, it will likely then be go-extra-ports or something similar. 

Also, apologies if the use of the ulrich drepper quote was offensive to anyone, I mainly used it to try and illustrate just how badly things can go wrong. I've been on any number of open source projects which forked when people could not come to agreement, and it's always sad to see. All things considered, I'd rather not see that happen.


--- Comment #25 by rsc ---
> The residual risk would be for the runtime, or some other vital standard package, to start relying on OS specific (e.g. system calls) aspects to perform basic operations. What allows Go to be so suited to the bare metal is its almost non-existent reliance on system calls for most of its core operations,

What about multithreading, or preemption? I see nothing in what you described as the [latest patch](https://github.com/golang/go/compare/go1.16.5...f-secure-foundry:tamago1.16.5.diff) that addresses either one. Those are core OS functionalities that Go _does_ depend on. To the extent that the tamago port does not provide those, it is providing a sub-standard Go experience. In particular, not having the ability to run on multiple CPUs seems like a complete show-stopper to me. That's not going to age well at all. (Also, maybe I missed it but I don't even see how the code puts the CPU into idle mode to save power when there are no goroutines running.)

I understand that you can get something kind of working easily. That was the case when I did GOOS=tiny a long time ago too. But I also understand, from other projects, how much work it is to create and maintain a real operating system capable of actually using bare hardware well. That's a huge amount of added complexity for the Go team to accept ultimate responsibility for maintaining. And it is ultimately why, although it was a fun demo, we also _removed_ GOOS=tiny a long time ago too.

As an administrative note, we are starting two [Go team quiet weeks](https://github.com/golang/go/issues/46934), which means I won't be replying on this issue again until July 12, to avoid having a discussion that others might want to take part in.


--- Comment #26 by abarisani ---
There are existing architectures in upstream Go without preemption or multithreading, in fact those architectures provided the very same code that we use right now (NaCl, js/wasm) in parts of our patch.

Regardless of this I already expressed intention in this issue to be explore how to make multithreading hooks possible.

Concerning preemption this is possible for external implementation as external packages can create timed interrupts and supervisors, we plan to demonstrate this in our GoTEE project.

This is not just a fun experiment, we have thousand of units in productions running secure elements using TamaGo.

Lowering frequency is handled externally by the application through functions we expose in our SoC driver, however I am not sure why this would be a concern for this discussion as SoC support and drivers would be an outside concern.

We have created full support for NXP i.MX6UL series and received external contributions for Raspberry Pi, to me this proves the effort in making this usable is not inconceivable.

The topics you are raising fall in what the external packages would require to implement and are not meant to be addressed or cared by the GOOS=none support (intentionally and for the reasons yourself raised initially).

So I guess now you are moving the discussion towards whether the whole Go in bare metal philosophy has merit or not rather then specific GOOS=none patch details?

The very initial concerns to this entire effort was that it would "clutter" upstream Go too much with hardware specific patterns that would be difficult to maintain and now that we moved everything out the concern is (despite one proved example of solid driver/SoC/CPU implementation) that those are external packages would be difficult or a bad experience?

I welcome all questions and clarifications on our proposal as I think this is due process, but I think we are going a little bit all over the place here and the feeling is that the mind is set on rejecting our proposal no matter what.

If the projects we are creating and supporting (listed earlier: GoKey, our bootloader, GoTEE, Armory Drive) created with TamaGo are not sufficient to prove that Go helps tremendously on the bare metal I am honestly not sure what would be.

--- Comment #27 by abarisani ---
On "how much work it is to create and maintain a real operating system capable of actually using bare hardware well.".

I think our patch shows how this would not be a concern of the Go team given that all actual hardware use is taken care of externally from the patch.

In fact that's the whole point of it.

--- Comment #28 by typeless ---
I am also interested in such applications. But wouldn't it be better if the *entire* runtime package as a whole can be replaceable?
That would allow more freedom for the external ports and meanwhile not be at odds with the canonical one. 
For many applications (like CLI tools), we don't need a heavyweight runtime supporting the scalability of 100K QPS but rather one with small footprint and fast startup time.

>I would much rather figure out what is making it difficult to keep this port out of tree and fix those underlying issues. 

A stable (or at least versioned), documented API between the compiler and the runtime and a command-line option of the toolchain to alter the runtime package?

--- Comment #29 by rminnich ---
OK, I think everyone is back, and I'd like to get this to some conclusion.

I don't detect acceptance for bare metal go, upstream. Instead, we've been encouraged to fork Go.

There are other ports that have hit a wall over the years, such as Harvey-OS. Rather than a fork-per-unaccepted-port, we're thinking it would be nice to have a common place to collect unaccepted ports. An unaccepted port is one which has never been accepted, or is no longer accepted, upstream, i.e. it has been demoted. The name go-ports has been suggested by several folks. 

The rules would look something like this:

- go-ports is a downstream fork, and superset of, the latest release
- a go-ports port can be promoted to upstream, if it makes sense
- an upstream port can be demoted from upstream but remain in go-ports, assuming a maintainer
- anything on the main go-ports branch has to build
-  but there is no requirement that all ports pass all tests, though this is encouraged
- ports that don't "just build" will be placed on a branch
- ports that lose maintainers will be placed on a branch

The remaining question is where go-ports would live: is it an organization, e.g. github.com/go-ports/... or is it under golang, github.com/golang/go-ports? 

--- Comment #30 by n2vi ---
For what it's worth, those rules sound good to me. My present area of interest is a not-quite-bare-metal port of Go above seL4. Seeing worked out projects like TamaGo helps me dodge problems that others have seen and coped with.

github.com/go-ports/ would be preferable to avoid any misunderstanding about who provides support.

If the repository also helps the Go team monitor unexpected ways that Go is being used, that's a nice extra.
