==== [Issue Title] ====
proposal: embed: remove import restriction

==== [Issue Body] ====
@mdempsky points out in https://github.com/golang/go/issues/41191#issuecomment-742478978 that the [late addition of string and \[\]byte to the embedding proposal](https://github.com/golang/go/issues/41191#issue-691159537) has some unfortunate side effects that we might want to make sure we are happy with.

There are three details of string and []byte embedding that are at least surprising. This issue is about two of them. See #43216 for the third. The two for this issue are as follows.

First, to make sure source files containing embedding directives are clearly identified (by an import), we require an `import _ "embed"` to write

	//go:embed hello.txt
	var msg string

even though there is no use of the embed package. This requires a special case in goimports. (This is noted in the proposal as accepted.)

Second, the late addition says “a plain string or []byte variable”, and I really did mean those words. Only those specific types are allowed, not []uint8 and not other user-defined aliases for those types.

I see two options here. One is to do nothing and leave things as they are. That's possible and is the "this issue gets declined" outcome. The other option I can see is to introduce new type aliases embed.String and embed.Bytes and require those to be used as the types, which is what this proposal issue is meant to discuss and decide whether to accept.

Specifically:

	package embed

	// A String is a string that can be initialized using a //go:embed directive.
	// It is an alias so that embed.String can be used as a string without
	// any explicit conversion. The only expected use of this type is in
	// var declarations accompanied by //go:embed directives. Elsewhere,
	// code should simply use string.
	type String = string

	// A Bytes is a []byte that can be initialized using a //go:embed directive.
	// It is an alias so that embed.Bytes can be used as a []byte without
	// any explicit conversion. The only expected use of this type is in
	// var declarations accompanied by //go:embed directives. Elsewhere,
	// code should simply use []byte.
	type Bytes = []byte

Then instead of writing:

	//go:embed hello.txt
	var msg string

You have to write:

	//go:embed hello.txt
	var msg embed.String

That solves both of the issues: the import is now required without any special case in goimports, and there is no question about whether []uint8 or other user-defined alias is OK. Only embed.String and embed.Bytes are OK.

What do people think? (Thumbs up / thumbs down is fine.)

\[One option that's not on the table is removing string and []byte embedding entirely. Many people asked for that during the pre-proposal discussions, and I think it is important to respect that process. We can fix problems, but I think it would be improper to drop the functionality completely.]

Thank you!


==== [Comments] ====

--- Comment #1 by SamWhited ---
Using a magic import `import _ "embed"` just feels confusing and makes me wonder what magic the Go compiler is hiding behind the scenes. I believe this sort of import was a mistake in the original design of the language and that its use in `database/sql` and the image libraries and the like was a mistake that we shouldn't add more of. I have run into any number of unexpected panics and other confusion due to import side effects. This specific magic import may not have any side effects that could cause problems, but I can't know that from looking at it. Please don't hide behavior behind magic imports. I'd almost rather the compiler implicitly magically import embed without that line being present just so that I don't have to see it since this would just be part of the `go:embed` directive behavior which is already magic that I sort of hate anyways but, per your email saying this wasn't going to change, we have to live with already.

I'm more okay with `embed.{Bytes,String}` because it at least gives me some reason to be importing `embed` without magic. Without knowing anything about the internals of the package (which will be the case for most Go users) I still immediately think "this is weird, it's just an alias, so why can't I just use a string?". This isn't the end of the world, Go has plenty of other more glaring quirks, but it's where my mind goes.

--- Comment #2 by hherman1 ---
Personally I like that its just a plain string and a []byte. The type wrappers aren't the end of the world, but I don't find the "_" import offensive enough to justify the expanded api personally, esp. considering there aren't actually any side effects of this import. 

--- Comment #3 by earthboundkid ---
FWIW, I started writing a blog post about `//go:embed` and had a little section about remembering to use `import _ "embed"` and example showing how it wouldn't work if you left it out. This simplifies the blog post because now I don't have to explain about a possible pitfall. I think being able to simplifying teaching materials is a good sign.

--- Comment #4 by hherman1 ---
I’m sure there’s already a great explanation of why this is a bad idea that I missed, but what if you just had no import at all, and //go:embed worked on its own? I take it that’s off the table? 

--- Comment #5 by mdempsky ---
> I’m sure there’s already a great explanation of why this is a bad idea that I missed, but what if you just had no import at all, and //go:embed worked on its own? I take it that’s off the table?

That would slow down go/build (e.g., cmd/go). Currently to compute package dependencies, it only parses Go source files up through the `import` declarations.

With `//go:embed` directives, it's necessary for go/build to parse these too, to figure out which files are embedded. By requiring that package embed is imported to use them, go/build can continue parsing only the import declarations for most files; and only continue to parse the rest of the file when it saw an import for package embed.

--- Comment #6 by marwan-at-work ---
One potential expansion on this proposal: 

The declaration of a `var <name> embed.{FS,String,Bytes}` can be a hint to the Go compiler to _validate_ the comment directive that are defined on top of the declaration.

For example,

```golang
//go;embed: file.txt 
var file embed.String
```

would cause a compiler error which will alleviate programmer confusion that they misspelled `go:embed` . 

Similarly, the lack of a go directive comment could also be a compiler error, because why would a programmer declare an `embed.{Type}` without actually needing to embed a file? 

This would address both @mdempsky and @rsc 's comments [here](https://github.com/golang/go/issues/41191#issuecomment-746412111) by keeping the embedding syntax as is while providing better developer experience. 

Hopefully my skimming of the comments didn't miss a similar suggestion. 

--- Comment #7 by mdempsky ---
> Similarly, the lack of a go directive comment could also be a compiler error, because why would a programmer declare an embed.{Type} without actually needing to embed a file?

The [draft proposal](https://go.googlesource.com/proposal/+/master/design/draft-embed.md) specifically states: "It is *not* an error to declare an `embed.Files` without a `//go:embed` directive. That variable simply contains no embedded files."

Note also that a single variable declaration can have multiple `//go:embed` directives. (Unlike [normal Go function call syntax](https://github.com/golang/go/issues/41191#issuecomment-747095807), which allow spreading across multiple lines, `//go:` directives are line oriented.) Reporting an error about no `//go:embed` directives wouldn't catch the case where the user typed some `//go:embed` directives correctly, but not all.

(That said, because all of the `//go:embed` lines would be clustered together, it would probably be rather visually obvious if there were any mistakes on some lines but not all.)

--- Comment #8 by hherman1 ---
I've been playing with go:embed on the beta a bit, and I noticed something I'd like to add to the mix. If I start working on a file with an embedded variable, and then I decide I want to move this embedded variable to a different file or module, its very easy to forget to remove the _ "embed" import, and because the import is explicitly `_` my IDE/go itself don't complain about its presence or auto-remove it.

For that reason, I think it would be valuable at the very least for go to complain about unused `_ "embed"` imports, but I also think this is a point for the `embed.Bytes` proposal.

I really like the idea of embedding simple `[]byte`/`string`. I don't like needing to learn about new types or the obscurity that comes with it, although slight. That being said, I think the case for these special types is stronger than I initially gave it credit. 

--- Comment #9 by hherman1 ---
While I'm here, I'll add on that I found it surprising that `../../resources/file.zip` was an invalid pattern. This is clearly not the right place for this comment, but I'm not aware of another place to put embed feedback. 

--- Comment #10 by marwan-at-work ---
> I really like the idea of embedding simple []byte/string. I don't like needing to learn about new types or the obscurity that comes with it, although slight. 

I also think it's really nice that you can use the plain string/[]byte. And while the drawback is that an `_ "embed"` import might get orphaned, tools like `gopls` or `go vet` can catch that pretty easily. 

As a proof of concept, I wrote a quick commit on top of `gopls` that automatically adds or removes an `_ "embed"` import based on your file's state: https://github.com/marwan-at-work/tools/commit/214d261c1d36fb9f5aa62a27ce02e954fcd9c178

--- Comment #11 by rsc ---
People seem overwhelmingly happy with this change, from what I'm seeing here.

To reply to @marwan-at-work, you can't exactly use the plain string/[]byte. You have to adorn them with `import _ "embed"`. 
It's only a little different for the adornment to be to write `embed.String` and `embed.Bytes` instead. While you _can_ write a special case for gopls (and all the other tools that care), it seems much nicer to use a design that avoids the special case entirely: we can fit nicely into the surrounding system, instead of causing more work for it.

--- Comment #12 by zigo101 ---
I have a question, why `embed.FS` instead of `io/fs.MemoryFS`?

[eidt] And is it ok to move `embed.Bytes` as `bytes.Embed`?

--- Comment #13 by rsc ---
@go101, the explicit goal of this proposal is to define types _in_ package embed, so that the import will be required.


--- Comment #14 by rsc ---
Based on the discussion above, this seems like a **likely accept**.


--- Comment #15 by earthboundkid ---
Quick question, does the import need to be named “embed” or can it be aliased (import xembed "embed")? I assume renaming the import is okay, but I don’t recall seeing it tested in the CLs yet. 

--- Comment #16 by robpike ---
I find the "import _ embed" more logical than an alias. You are, truly, importing embed for its side effects. Document that if you are using embed just for strings or bytes, you must use the underscore.

If you use the _ import, the problem is solved, only two keystrokes (space, underscore) are required, and all is smooth now.

If you use the alias, you need to type more and you need to understand that it is an alias and deal with the fact that your variable although declared as embed.String is really just a plain string, _despite its declaration_. That troubles me, as its effects could ripple through the file.

If an underscore import is good enough for image/jpeg, it's good enough for embed.

--- Comment #17 by robpike ---
To reiterate: A big thumbs down for me. There is zero need for a new mechanism.

--- Comment #18 by earthboundkid ---
If `import _ “embed”` worked like `import _ “image/jpeg”`, it would be enough to just do the import in package main. As far as I know, this is not the case.

I think if `embed.String`/`embed.Bytes` aren’t the chosen form, then other type aliases for string and []byte should be allowed (e.g. []uint8), which was the original bug report that lead to this proposal.

--- Comment #19 by randall77 ---
The big benefit I see with the aliases is that goimports will insert (and remove) the import for you. That makes all the changes you actually need to type in one location (2 lines, the `//go:embed` line and the `var x embed.String` line).


--- Comment #20 by robpike ---
I understand the apparent convenience of the proposal, and how tools can use it to manage things for you, but no such argument - or tooling - is necessary if the documentation and practice say to use use an underscored import. I cannot stress enough that two keystrokes are all that are required. TWO! A third of what appear in the word "string".

All the mechanism necessary already exists and is widely used. There's no need to provide anything else. No documentation and explanation of the special aliases required. (No ugly aliases required, either, but the sentiment underlying that may hold a bias.) 

Should embed acquire other types and other mechanisms, which is certainly possible, the underscore import will continue to solve the problem without further changes, but to go with the proposal would require expanding the space of magic names.

To put it another way, if the embed type is bringing in a string, let me declare it as a regular string.

We already have all we need to solve this. Please don't add more complexity.


--- Comment #21 by hherman1 ---
I’ll add on: I think go will grow complex not with a single over complicated change, but by the addition of language features and stl apis/types over time, so I have a similar strong preference for using the existing api, although I think my prior point about orphan imports is worth thinking about 

--- Comment #22 by Merovius ---
I have to admit, I don't really understand this. ISTM that we need to add more, to make `_` work - it needs separate support in tools like `goimports` and the like, which the aliases don't need. And aliases are also features we already have. So, if the concern is to re-use mechanisms the language already provides, the aliases seem a win to me. Both are existing features, but one of them needs special casing in tools, while the other just works with what we have.

I also don't understand what the two keystrokes are. I guess it's changing `import "embed"` into `import _ "embed"`, but I really can't see a scenario where one would do that. ISTM you would either let `goimports` add the entire line, or you would type it out and also type out the `//go:embed` and `var` line and at that point, I don't really think two keystrokes are a concern. Either way, I don't think anyone is complaining that they have to type two extra characters or not.

I agree that the extra alias indirection over `embed.Bytes` adds a layer of complexity over a plain `[]byte`, but I also feel that it's kind of offset by the removed complexity of not having to special case this in tooling.

I must say, I'm surprised by the strength of this reaction. But ultimately, I don't feel super strongly one way or another, so what do I know :)

--- Comment #23 by hherman1 ---
Isn’t the complexity in the tooling go team facing complexity rather than dev facing complexity? So outweighed by the proportion of go devs : go team devs 

--- Comment #24 by Merovius ---
The people who write Go tools are not always on the Go team (I would even say, they overwhelmingly are not). And if tools aren't working correctly, because they don't uniformly support use-cases, that affects everyone as well. Personally, I also feel that "I have to look up that `embed.String` is an alias for `string`" creates less friction than a tool not working.

I have to admit that I genuinely don't know how this special case would break which tools. So at the end of the day, there might not be much of a problem. But it's not as simple as "implementation difficulties in go tooling only affects the go team".

--- Comment #25 by robpike ---
It seems your objection to my argument is that a human must type the underscore. The tools (at least as they exist now) will not do it for you. They well might in time (and it's not hard to implement), but they don't today.

I don't find that compelling, but I do understand it.

Your program won't handle jpeg files if you don't blank-import the jpeg package. I have never heard anyone object that the cost of typing an import statement to effect that result is a burden.

So the question comes down to this, it seems: Is this a problem important enough to require the language and/or its libraries and tools implement special handling so that a user writing an embed "statement" doesn't have to type that import?  Or is it enough to write in the documentation that part of using the embed mechanism is to write an import statement? Written like that, I still believe the answer is that existing mechanisms are sufficient for the problem.

--- Comment #26 by Merovius ---
> Your program won't handle jpeg files if you don't blank-import the jpeg package. I have never heard anyone object that the cost of typing an import statement to effect that result is a burden.

I actually have seen it as a burden in the past (not so much `image/jpeg`, but definitely `github.com/mattn/go-sqlite3`, which I have to google every time I want to use sqlite). I haven't really thought about it in these terms, but I realized yesterday, that this conversation actually swayed me against the registry and `_`-import pattern in general.

> So the question comes down to this, it seems: Is this a problem important enough to require the language and/or its libraries and tools implement special handling so that a user writing an embed "statement" doesn't have to type that import? Or is it enough to write in the documentation that part of using the embed mechanism is to write an import statement? Written like that, I still believe the answer is that existing mechanisms are sufficient for the problem.

I understand your position better, thank you. I do disagree - as I said, I feel the friction goimports removes in practice outweighs the friction a type-alias introduces. But as I said, I don't feel strongly, so I'll leave it at that :)

--- Comment #27 by zigo101 ---
I'm wondering whether or not the `embed` package is necessary at all.

The code
```
import "embed"

//go:embed hello.txt
var msg embed.String
```

contains two explicitnesses. One is the `go:embed` directive, and the other is the `embed.` qualifier prefix. Do we really need both of the two? Isn't one enough? Hasn't the `go:embed` directive provided enough info for compilers to make decisions? If it has, and if `embed.FS` is declared as `io/fs.MemoryFS`, we don't need to add the `embed` package at all.

Think that, would it be some weird to declare variables of `embed.String` and `embed.Bytes` without `go:embed` directive?







--- Comment #28 by mdempsky ---
The `"embed"` import is needed so that `go/build` (and thus `cmd/go`) can detect whether it needs to scan the full file for `//go:embed` comments, or if it can short-circuit after scanning just the import directives. It's not needed for any run-time side effects (like how importing `"image/jpeg"` enables additional functionality in package `"image"`) or for because the `//go:embed` directive is insufficiently explicit on its own.

As for objections to needing to type "embed" more than once, I'll point out my original suggestion (including [working prototype](https://golang.org/cl/276835) and [rationale](https://github.com/golang/go/issues/41191#issuecomment-742478978)) was to add new compiler-builtin functions, which would only require the user to write "embed" exactly once (discounting the goimports-managed import declaration): https://github.com/golang/go/issues/41191#issuecomment-747095807

--- Comment #29 by zigo101 ---
> The "embed" import is needed so that go/build (and thus cmd/go) can detect whether it needs to scan the full file for //go:embed comments, or if it can short-circuit after scanning just the import directives.

It sounds like the "embed" import is to adapt the embedding feature into the current build pipeline without modifying much code. But the `//go:embed` comments will be always scanned eventually in a phase of the build pipeline. Is it so important to get acknowledged that there are `//go:embed` comments  in a Go file in an early phase of the build pipeline?

--- Comment #30 by Merovius ---
@go101 Even if it was feasible, to re-architect the entire build process, it seems like a pretty big price to pay simply to get rid of a package. I also don't even know *why* you would want to get rid of it - it contains code that implements `embed.FS`. It has a clear purpose. Lastly, I don't think `embed.FS` belongs in the `io/fs` package - which is, as far as I'm concerned, for declaring the standardized interfaces and for primitives to compose them. `embed.FS` does not qualify as either. I wouldn't put it into `io/fs` anymore than I would put `*os.File` into `io`, just because it implements `Reader`.
