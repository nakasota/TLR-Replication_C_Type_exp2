=== Fetching Proposal: MDU6SXNzdWU0Mzk2NTExMzc= ===
Issue URL: https://github.com/golang/go/issues/31804

==== [Issue Title] ====
crypto/ed25519: Implement Ed25519ph

==== [Issue Body] ====
**Update**, Apr 6 2022: The proposed API is in https://github.com/golang/go/issues/31804#issuecomment-537230419.

---



The Ed25519ph variant specified in [RFC 8032](https://tools.ietf.org/html/rfc8032) allows signing/verifying a message that has already been hashed with SHA-512 without risking the collision-resistant properties of "PureEdDSA" when using the same keys for messages signed using both schemes.

This is useful in at least two scenarios:

1. When the private key is isolated to another piece of hardware and passing the entire message to be signed is not possible, for example when using a HSM and signing messages larger than a few KB.
2. When working with large messages that are too large to be reasonably buffered for the current one-shot API.

This variant can be implemented minimally using the existing `crypto.Signer` API plus an additional verification function, without encouraging unsafe use by providing easy access to an API that takes an `io.Reader` or `io.Writer`.

Due to the additional internal hash initialization, there is no way to implement this without forking the package or upstreaming an implementation patch.

I will send a CL with a proposed implementation.

Relevant: #31727

/cc @zx2c4 @FiloSottile 

==== [Comments] ====

--- Comment #1 by gopherbot ---
Change https://golang.org/cl/174941 mentions this issue: `ed25519: Implement Ed25519ph`

--- Comment #2 by x30n ---
+1

--- Comment #3 by Hades32 ---
Thanks @titanous , this is just what we needed. Confirmed to behave as the reference implementation (libsodium). ðŸ‘ 

Not sure if this is still in time for 1.13... @FiloSottile 

--- Comment #4 by FiloSottile ---
Too late for Go 1.13, targeting Go 1.14. (`crypto/ed25519` is now in the standard library.)

--- Comment #5 by Yawning ---
While I understand that the `crypto.Signer` interface is fixed in stone and can't be changed, if this is going to happen, it would be nice if it supported the full `Ed25519ph` algorithm as described in the RFC.

As it stands right now, the proposed implementation does not support a domain separation context.

Since there already is a `Sign` method in the package, and the PR adds `VerifyHashed`, this could be done by adding `SignHashed(privateKey PrivateKey, context, message []byte) []byte` and changing the proposed `VerifyHashed` to take another byte slice.

--- Comment #6 by FiloSottile ---
RFC 8032 defined context independently of pre-hashing, so to support the whole spec we'd also have to support pure Ed25519 with custom context.

I am really not a fan of extending the API surface of a standard library package that should be what we point users to for basic public key signatures. How about this alternative API, which is more extensible and still makes it very opt-in to select the variants?

```
// Options can be used with PrivateKey.Sign or VerifyWithOptions
// to select Ed25519 variants.
type Options struct {
    // Hash can be zero for regular Ed25519, or crypto.SHA512 for Ed25519ph.
    Hash    crypto.Hash
    Context string
}

func (*Options) HashFunc() crypto.Hash

func VerifyWithOptions(publicKey PublicKey, message, sig []byte, opts *Options) bool
```

--- Comment #7 by Yawning ---
If this proposed API is accepted, then `VerifyHashed` as proposed in the PR will go away right?  I would be in favor of this, since it seems like a cleaner way to support the functionality.

Nitpicking: Is there any particular reason why `Context` is a `string` over `[]byte`?  I understand they are fairly interchangeable (and `string` may be more `const` friendly).  I personally would make it a `[]byte` to make it clear that it is an arbitrary "octet string of at most 255 octets" (and include the size limit in a doc string comment).

--- Comment #8 by FiloSottile ---
> If this proposed API is accepted, then `VerifyHashed` as proposed in the PR will go away right? I would be in favor of this, since it seems like a cleaner way to support the functionality.

Yep.

> Nitpicking: Is there any particular reason why `Context` is a `string` over `[]byte`? I understand they are fairly interchangeable (and `string` may be more `const` friendly). I personally would make it a `[]byte` to make it clear that it is an arbitrary "octet string of at most 255 octets" (and include the size limit in a doc string comment).

Mostly consistency, we've used string for contexts elsewhere, in some cases to make it a different type from the message itself (which is not relevant here). I personally think it fits better the nature of the value, because it's usually fixed or at least immutable, often human-readable, and as you say can be a const.

We should definitely document the max length, thank you.

--- Comment #9 by Yawning ---
I went and implemented this in a package I maintain for dayjob (because dayjob needs ph-with-context support), and have more feedback.

What should happen when `Hash` is `crypto.Hash(0)` and `Context` is `""`?
 1) Ed25519ctx with a 0 octet context ("The context input SHOULD NOT be empty.").
 2) Ed25519pure

I went with option 2 as option 1 is somewhat nonsensical and recommended against, though I will happlily change the package to match what the runtime library does.  If `Context` were a byte, this could be disambiguated by `nil` vs `[]byte{}`, but it's not clear to me if that justifies the loss of consistency and `const` friendliness, just for the sake of completeness.

Minor: I used `opts crypto.SignerOpts` for `VerifyWithOptions` so that it is possible to pass `crypto.SHA512` when the context is not required (following `PublicKey.Sign`).  The type naming is somewhat unfortunate, but the ease of use for what I suspect is a common case probably wins out.

--- Comment #10 by FiloSottile ---
> What should happen when `Hash` is `crypto.Hash(0)` and `Context` is `""`?
> 
> 1. Ed25519ctx with a 0 octet context ("The context input SHOULD NOT be empty.").
> 2. Ed25519pure
> 
> I went with option 2 as option 1 is somewhat nonsensical and recommended against, though I will happlily change the package to match what the runtime library does. If `Context` were a byte, this could be disambiguated by `nil` vs `[]byte{}`, but it's not clear to me if that justifies the loss of consistency and `const` friendliness, just for the sake of completeness.

Yeah, definitely pure if Context is `""`, the alternative is confusing and not something people should do anyway, but we should document it. I am also not a fan of semantic differences between `nil` and `[]byte{}` in general.

> Minor: I used `opts crypto.SignerOpts` for `VerifyWithOptions` so that it is possible to pass `crypto.SHA512` when the context is not required (following `PublicKey.Sign`). The type naming is somewhat unfortunate, but the ease of use for what I suspect is a common case probably wins out.

I thought about that, but I think I'd rather use the concrete type for a few reasons:

* you can't actually semantically use any other `crypto.SignerOpts` here, the reason Sign has it is to match an interface which needs the abstraction, VerifyWithOptions has no semantic justification
* Ed25519ph is not something we need to encourage and make easy, so having to explicitly use Options seems fine
* interface boxing still causes heap escapes, I think

--- Comment #11 by odeke-em ---
Thank you for mailing [CL 174941](https://go-review.googlesource.com/c/crypto/+/174941/) @titanous, unfortunately that didn't make it into the cut before the Go1.14 freeze, but please rebase from master and we'll hopefully get this in for Go1.15. Apologies for lack of eyes on it during Go1.14. 

--- Comment #12 by armfazh ---
I think this is wrong, 

```
If opts.HashFunc() is crypto.SHA512, the pre-hashed variant Ed25519ph
is used and message is expected to be a SHA-512 hash,
```

the prehashed mode must do the job internally, i.e. explicitly hashing the (likely to be large) message with SHA-512.
Otherwise, there is no guarantee that the hashed message was generated by SHA-512, it could be generated with another hash function that also outputs the same number of bytes.


--- Comment #13 by titanous ---
> the prehashed mode must do the job internally, i.e. explicitly hashing the (likely to be large) message with SHA-512.
> Otherwise, there is no guarantee that the hashed message was generated by SHA-512, it could be generated with another hash function that also outputs the same number of bytes.

That is not how the `crypto.Signer` API works. You are expected to hash the message before calling `Sign` if a hash function option is specified. For example, look at how the [ecdsa package does it](https://golang.org/pkg/crypto/ecdsa/#PrivateKey.Sign).



--- Comment #14 by armfazh ---
> That is not how the `crypto.Signer` API works. 
> You are expected to hash the message before calling `Sign` if a hash function option is specified. For example, look at how the [ecdsa package does it](https://golang.org/pkg/crypto/ecdsa/#PrivateKey.Sign).

Of couse doesn't work like that because `crypto.Signer` doesn't take into account the use of prehashed signature schemes. Ed25519Ph is one of them, as it prehashes the message _internally_ using always SHA-512.

I acknowledge the lack of a Signer Go interface that handles the new signature schemes for example those in RFC-8032, which enable prehashing and receive domain separation strings as input. 


--- Comment #15 by claucece ---
So, dear @Yawning @FiloSottile and other interested parties, we did an implementation of ed25519 with all of its variants (pure, ctx and ph), here: https://github.com/cloudflare/circl/blob/master/sign/ed25519/ed25519.go, following the advice given on this issue. If wanted we can summit a PR following that API.

--- Comment #16 by FiloSottile ---
> > That is not how the `crypto.Signer` API works.
> > You are expected to hash the message before calling `Sign` if a hash function option is specified. For example, look at how the [ecdsa package does it](https://golang.org/pkg/crypto/ecdsa/#PrivateKey.Sign).
> 
> Of couse doesn't work like that because `crypto.Signer` doesn't take into account the use of prehashed signature schemes. Ed25519Ph is one of them, as it prehashes the message _internally_ using always SHA-512.

The point of Ed25519ph is to avoid having to pass the whole message into the signer, so it's expected for Sign to take the digest and not perform the SHA-512 hash itself. If that was an option, you'd just use Ed25519. It's also not different from every other crypto.Signer, which takes the caller's word about what hash generated the digest.

--- Comment #17 by gopherbot ---
Change https://golang.org/cl/373076 mentions this issue: `crypto/ed25519: implement Ed25519ph in Sign and VerifyWithOptions`

--- Comment #18 by ItalyPaleAle ---
Thanks @FiloSottile for the CL, I am happy to see this implemented!

I see that only SHA-512 is supported for hashing in the CL, which I understand as it's the only one defined in RFC 8032. However, do you think it would be possible to make the method support more generic hashes? I can for example see a use for supporting SHA-256 hashes (when an application doesn't need 512-bit long ones) or better future-proofing as one day we may need to switch to other hashing functions (SHA-3, BLAKE2, etc).

--- Comment #19 by Yawning ---
> Thanks @FiloSottile for the CL, I am happy to see this implemented!
> 
> I see that only SHA-512 is supported for hashing in the CL, which I understand as it's the only one defined in RFC 8032. However, do you think it would be possible to make the method support more generic hashes? I can for example see a use for supporting SHA-256 hashes (when an application doesn't need 512-bit long ones) or better future-proofing as one day we may need to switch to other hashing functions (SHA-3, BLAKE2, etc).

The way this is implemented, if you want to use a different hash that provides a 512-bit digest for the pre-hashed message, it will "just work" if you pass in SHA-512 as the hash (though still use SHA-512 internally), because the pre-hashed message is treated as an opaque blob.

If you want to also use an alternative hash algorithm internally (Eg: for deriving the r scalar), that would require more substantial alterations to the code (and would be a rather massive deviation from the algorithm as defined in the RFC/FIPS draft).  As far as I am concerned, at the point where you are wanting to switch out the underlying hash algorithm to that degree, you might as well use a nicer signature scheme entirely (eg: Sr25519 uses Keccak based merlin transcripts + r255, and supports 256/512-bit digests, along with a XOF as pre-hashed messages).

--- Comment #20 by ItalyPaleAle ---
> if you want to use a different hash that provides a 512-bit digest for the pre-hashed message, it will "just work" if you pass in SHA-512 as the hash (though still use SHA-512 internally), because the pre-hashed message is treated as an opaque blob.

That makes sense for 512-bit hashes. But right now the code would fail for anything that isn't 64-bytes long (I see a check that makes sure the input has the length of a SHA-512 hash).

> If you want to also use an alternative hash algorithm internally (Eg: for deriving the r scalar), that would require more substantial alterations to the code

I can't speak for others, but from what I'm concerned with, this is not a problem. The reason why I'd like to use Ed25519ph is to sign large files and calculate the hash as a stream on the input, which is not possible with Ed25519. So I'm not concerned with the hashing algorithm used internally.

--- Comment #21 by Yawning ---
> That makes sense for 512-bit hashes. But right now the code would fail for anything that isn't 64-bytes long (I see a check that makes sure the input has the length of a SHA-512 hash).

Then append 256-bits worth of 0s to your digest.  You're already doing something non-standard.

--- Comment #22 by FiloSottile ---
No, Ed25519ph is defined and specified with only a single hash, and that's a good thing. Flexibility in cryptography is a liability, not an asset per se. If SHA-512 turns out to be broken, which considering the progress of cryptanalysis is not a pressing concern, we'll simply specify and implement a new Ed25519 variant that uses a different hash everywhere. If you need to sign a non-SHA-512 hash, you can use pure Ed25519 and understand that domain separation is your responsibility, but I would suggest considering just switching to SHA-512 which on 64-bit platforms is sometimes faster than SHA-256.

--- Comment #23 by zx2c4 ---
> However, do you think it would be possible to make the method support more generic hashes?

Something to keep in mind that may not be immediately obvious from looking at the diff in that CL alone is that, regardless of the "prehash" mode, Ed25519 _already_ uses SHA-512 internally (twice on sign, once on verify). That's not something anybody is talking about changing or modularizing here; it works fine. So, given that there's _already_ a necessary SHA-512 code path, why complicate things by adding something different for prehash mode? You can keep your code size small and just re-use the same hash function, SHA-512.

And, as Filippo said, if you do want to go off and do something weird, figuring out how to do that safely should be on you.

---

If you're curious about how this is specified, here's a line copy and pasted out of the verification phase for Ed25519[ph]:

> 2.  Compute `SHA512(dom2(F, C) || R || A || PH(M))`

So interpret that as `SHA-512(somestuff concatenated with PH(the message))`. Notice how SHA-512 is hard coded there. But what is this `PH()` function?

Take a look at [this section](https://datatracker.ietf.org/doc/html/rfc8032#section-5.1). For Ed25519, the vanilla version, it says:

>    `|   PH(x)   | x (i.e., the identity function)                       |`

So that simplifies to `SHA-512(somestuff concatenated with the message)`.

But for Ed25519ph, the prehashed version, it says:

> `For Ed25519ph, [...] PH is SHA512 instead. `

So that simplifies to `SHA-512(somestuff concatenated with SHA-512(the message))`.

At which point you can be somewhat glad things aren't made _more_ complicated by having two different hash functions in there. Were I to write that expression with two different hash functions, you would probably tell me, "that's weird, why not just use the same one?"

--- Comment #24 by FiloSottile ---
I implemented the API in https://github.com/golang/go/issues/31804#issuecomment-537230419 in https://go.dev/cl/373076.

@golang/proposal-review, can we get it on the slate for Go 1.19?

--- Comment #25 by rsc ---
The proposed API is in https://github.com/golang/go/issues/31804#issuecomment-537230419.


--- Comment #26 by cristaloleg ---
@FiloSottile kindly ping, looks like 1 small comment in left on your CL.

--- Comment #27 by FiloSottile ---
@cristaloleg this is waiting for the @golang/proposal-review committee, the CL is effectively ready.

--- Comment #28 by rsc ---

This proposal has been added to the [active column](https://golang.org/s/proposal-status#active) of the proposals project
and will now be reviewed at the weekly proposal review meetings.
â€” rsc for the proposal review group


--- Comment #29 by FiloSottile ---
https://go.dev/cl/373076 is ready âœ¨ 

--- Comment #30 by gopherbot ---
Change https://go.dev/cl/404274 mentions this issue: `crypto/ed25519: implement Ed25519ctx and Ed25519ph with context`
