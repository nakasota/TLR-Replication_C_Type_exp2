==== [Issue Title] ====
go/types: add Object.Origin [freeze exception]

==== [Issue Body] ====
I propose to add the following methods to `types.Var` and `types.Func`:

```
// Origin returns the canonical object for its receiver, i.e. the object
// recorded in Info.Defs.
//
// For instantiated variables Origin returns the type-parameterized object from
// which the receiver was created. For all other variables Origin returns the
// receiver.
func (obj *Var) Origin() *Var 

// Origin returns the canonical object for its receiver, i.e. the object
// recorded in Info.Defs.
//
// For instantiated functions Origin returns the type-parameterized object from
// which the receiver was created. For all other functions, Origin returns
// receiver.
func (obj *Func) Origin() *Func
```

While instantiating types, we necessarily have to create instantiated copies of their methods/fields/parameters/etc. However, as we work on updating tools for generics, an emerging theme is that is useful to be able to answer the following two questions:

1. Is this object canonical?
2. What _is_ the canonical object corresponding to this object?

Right now, these are not easy questions to answer.  For methods, these can be answered by a [lookup](https://pkg.go.dev/golang.org/x/exp/typeparams#OriginMethod) on the receiver base origin type. For fields / parameters / etc., it is more difficult and may require finding the relevant `*ast.Ident` and looking in `Info.Defs`.

Adding an `Origin` method to these types answers both of these questions trivially, at the cost of a pointer per object. If the added memory is a concern, there are several internal fields on `types.object` used during type-checking that may be externalized to free memory.

CC @griesemer @dominikh @timothy-king @mdempsky 



==== [Comments] ====

--- Comment #1 by griesemer ---
Does it make sense to have `Origin` on each `Object`? Isn't it sufficient to have it for `TypeNames` and `Funcs`?

--- Comment #2 by findleyr ---
> Isn't it sufficient to have it for TypeNames and Funcs?

We'd need it for `Var`s as well (and technically we _don't_ need it for TypeNames: we don't expose any non-canonical TypeNames).  When we instantiate structs / signatures, we instantiate vars.

--- Comment #3 by timothy-king ---
Do we want more experience with the existing alternatives available before making a decision?

--- Comment #4 by findleyr ---
> Do we want more experience with the existing alternatives available before making a decision?

It's fine to wait if we think we'll get more signal, but I do think we should add something for 1.19. This feels like a philosophical oversight: the canonical nature of Objects was broken without an API to easily 'canonicalize'.

--- Comment #5 by rsc ---

This proposal has been added to the [active column](https://golang.org/s/proposal-status#active) of the proposals project
and will now be reviewed at the weekly proposal review meetings.
â€” rsc for the proposal review group


--- Comment #6 by findleyr ---
> We'd need it for Vars as well (and technically we don't need it for TypeNames: we don't expose any non-canonical TypeNames). When we instantiate structs / signatures, we instantiate vars.

I think it would be fine to simply add Origin to the objects that could possibly be instantiated: `Var` and `Func`, I think. That is more conservative, and we can always add it to the Object interface later.

--- Comment #7 by rsc ---

Based on the discussion above, this proposal seems like a **[likely accept](https://golang.org/s/proposal-status#likely-accept)**.
â€” rsc for the proposal review group


--- Comment #8 by griesemer ---
@findleyr The more conservative approach seems fine. Can you please send out a CL soon so we can see the implications in detail? 

--- Comment #9 by gopherbot ---
Change https://go.dev/cl/395535 mentions this issue: `go/types: set an origin object for vars and funcs`

--- Comment #10 by findleyr ---
https://go.dev/cl/395535 contains a prototype of the new API, which is added only to `*Func` and `*Var`.

A notably questionable decision: I opted to have the new methods return `Object`, even though they could return `*Func` and `*Var`, respectively, to leave open the possibility that this API is added to the `Object` interface in the future. By comparison, `(*Named).Origin` returns `*Named`, so maybe we should opt for the more specific results. ...as I write this I am thinking that returning concrete types is probably this is the better option, but I would pose the question to the audience in any case.

--- Comment #11 by dominikh ---
I'm leaning towards returning `Object`. Even without the API being added to `Object`, users can define their own interface and get the origin object with a single type assertion/call. `(*Named).Origin` returning `*Named` doesn't seem problematic, since `Named` isn't an `Object` and thus isn't technically part of the same API.

--- Comment #12 by rsc ---
Moving back to active to resolve the discussion about the result type.


--- Comment #13 by findleyr ---
Discussed this with @griesemer, and it seems like the arguments for concrete result types are compelling:
- Fewer type assertions at the call site.
- Less likely to introduce a typed nil.

On the other hand, we wouldn't be able to pass around `interface{ Origin() Object }` as @dominikh suggests, but it would of course be easy to write a helper `func originObject(Object) Object`.

By way of analogy, we document that `Type()` of a `*Func` is _always_ `*Signature`, yet I have seen many places in `x/tools` where we use a commaok type assertion and handle the case that the `Type()` of a `*Func` is _not_ a `*Signature`. I would guess that returning `Object` will lead to similar misuse.

--- Comment #14 by rsc ---
@findleyr, thanks for updating the top comment with the proposed API. Does anyone object to this change?


--- Comment #15 by rsc ---

Based on the discussion above, this proposal seems like a **[likely accept](https://golang.org/s/proposal-status#likely-accept)**.
â€” rsc for the proposal review group


--- Comment #16 by findleyr ---
CC @adonovan :)

--- Comment #17 by rsc ---

No change in consensus, so **[accepted](https://golang.org/s/proposal-status#accepted)**. ðŸŽ‰
