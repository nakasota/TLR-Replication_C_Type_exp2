==== [Issue Title] ====
net: add tcp WriteTo func to enable splice socket data to file

==== [Issue Body] ====
When transfer data from tcp socket to file directly, splice will help us with low time cost in linux. Currently, `os.File` just uses `write` to transfer data from tcp socket.

To do this in linux, there are some changes:
1. add `LimitWriter` to detect writing limit in internal package, discussed in [this issues](https://github.com/golang/go/issues/46465).
2. add `spliceW` function to splice data from tcp socket to file.
3. add `WriteTo` function for `net.TCPConn`.

We get 10% at least cpu time reduce, zero memory copy from kernel to user space.

![image](https://user-images.githubusercontent.com/1567113/120190828-b29e8100-c24b-11eb-80d6-f26756b36409.png)

Implement PR: #46149, [go review](https://go-review.googlesource.com/c/go/+/319593)




==== [Comments] ====

--- Comment #1 by rsc ---
What are the specific API changes you are proposing? 

--- Comment #2 by rsc ---

This proposal has been added to the [active column](https://golang.org/s/proposal-status#active) of the proposals project
and will now be reviewed at the weekly proposal review meetings.
â€” rsc for the proposal review group


--- Comment #3 by rsc ---
It looks like there are no direct API changes other than TCPConn implementing io.WriterTo by adding a WriteTo method.
This means that any io.Copy(dst, src) where src is a TCPConn
and dst has a ReadFrom will now use src.WriteTo instead of dst.ReadFrom.
Are there are any cases where that matters?
If dst and src are both networks, presumably we end up at splice either way.
But are there other kinds of dsts that matter?

If splice isn't applicable to this specific TCPConn, 
we fall back to io.Copy(dst, noWriteTo{src}),
so we will still get to the dst.ReadFrom.

So the only possible change is when splice is an option but not the best option. Does that case exist?


--- Comment #4 by rsc ---
If we do find such a case, TCPConn.WriteTo can always not use splice then.


--- Comment #5 by rsc ---

Based on the discussion above, this proposal seems like a **[likely accept](https://golang.org/s/proposal-status#likely-accept)**.
â€” rsc for the proposal review group


--- Comment #6 by jim3ma ---
> It looks like there are no direct API changes other than TCPConn implementing io.WriterTo by adding a WriteTo method. This means that any io.Copy(dst, src) where src is a TCPConn and dst has a ReadFrom will now use src.WriteTo instead of dst.ReadFrom. Are there are any cases where that matters? If dst and src are both networks, presumably we end up at splice either way. But are there other kinds of dsts that matter?
> 
> If splice isn't applicable to this specific TCPConn, we fall back to io.Copy(dst, noWriteTo{src}), so we will still get to the dst.ReadFrom.
>
> So the only possible change is when splice is an option but not the best option. Does that case exist?

Currently, I just find two cases:
* From `net.TCPConn` to `os.File`
* From `net.TCPConn` to `net.TCPConn`

Two cases has been handled in https://go-review.googlesource.com/c/go/+/319593

--- Comment #7 by rsc ---

No change in consensus, so **[accepted](https://golang.org/s/proposal-status#accepted)**. ðŸŽ‰
