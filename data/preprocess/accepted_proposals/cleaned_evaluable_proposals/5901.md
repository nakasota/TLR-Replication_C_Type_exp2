==== [Issue Title] ====
encoding/json: allow per-Encoder/per-Decoder registration of marshal/unmarshal functions

==== [Issue Body] ====
<pre>For example, if a user wants to marshal net.IP with custom code, we should provide a way
to do that, probably a method on *Encoder. Similarly for *Decoder.

Same for encoding/xml.</pre>


==== [Comments] ====

--- Comment #1 by robpike ---
<a id="c1"></a>Comment 1:

_Labels changed: removed **go1.3**._


--- Comment #2 by rsc ---
<a id="c2"></a>Comment 2:

_Labels changed: added **go1.3maybe**._


--- Comment #3 by rsc ---
<a id="c3"></a>Comment 3:

_Labels changed: added **release-none**, removed **go1.3maybe**._


--- Comment #4 by rsc ---
<a id="c4"></a>Comment 4:

_Labels changed: added **repo-main**._


--- Comment #5 by odeke-em ---
I did some work on this sometime back in October, with CL https://go-review.googlesource.com/c/31091 to get the conversation started.
Perhaps we can work on it for Go1.9.

In there I introduced Encoder.RegisterEncoder
```go
func (enc *Encoder) RegisterEncoder(t reflect.Type, fn func(interface{}) ([]byte, error))
```

and Decoder.RegisterDecoder
```go
func (dec *Decoder) RegisterDecoder(t reflect.Type, fn func([]byte) (interface{}, error))
```

--- Comment #6 by sebastien-rosset ---
We have a similar requirement for custom serialization. Our specific use cases are:
1) Data anonymization. For example, omit IP addresses in the JSON output.
2) Data masking. For example, omit specific fields depending on user privileges. 
3) Omit empty values (e.g. empty strings). This is useful to generate compact documents.
In all three cases, the decision to omit fields is done at runtime with contextual information. 

We are using https://github.com/CiscoM31/go/commit/1e9514f3c4225f67836f9b67cd68e97f45087325. In our case, the client interface is implemented by doing a simple lookup in a map, so there is no need to register hundreds of custom marshaller (we have lots of structs).
We could have used a technique similar to https://go-review.googlesource.com/c/31091.

--- Comment #7 by harrisonhjones ---
@rsc is there still interest in this feature on your end? I have a use-case for it and would be happy to implement it.

[Edit 1] Spelling
[Edit 2]

I wonder if the function signature should be 

```go
func (enc *Encoder) RegisterMarshaller(t reflect.Type, f func(reflect.Value) ([]byte, error))
```

with all standard Encoders exposed so that users can leverage them. Example redactor:

```go
package main

import (
	"bytes"
	"encoding/json"
	"os"
	"reflect"
	"strings"
	"unicode/utf8"
)

func main() {
	enc := json.NewEncoder(os.Stdout)
	text := "My password, foo, is totally secure"

	enc.RegisterMarshaller(reflect.TypeOf(""), StringMarshaller)
	enc.Encode(text)
	// Output
	// "My password, foo, is totally secure"

	enc.RegisterMarshaller(reflect.TypeOf(""), func(value reflect.Value) ([]byte, error) {
		return StringMarshaller(reflect.ValueOf(strings.Replace(value.String(), "foo", "[REDACTED]", -1)))
	})
	enc.Encode(text)
	// Output
	// "My password, [REDACTED], is totally secure"
}

// Largely taken from `func (e *encodeState) `string(s string, escapeHTML bool)` in `encoding/json/encode.go`
// This would exist in encoding/json.
func StringMarshaller(value reflect.Value) ([]byte, error) {
	e := bytes.Buffer{}
	s := value.String()
	escapeHTML := false // TODO: Refactor StringEncoder into a 'htmlEscaping' one and a non 'htmlEscaping' one.

	e.WriteByte('"')
	start := 0
	for i := 0; i < len(s); {
		if b := s[i]; b < utf8.RuneSelf {
			if json.HTMLSafeSet[b] || (!escapeHTML && json.SafeSet[b]) {
				i++
				continue
			}
			if start < i {
				e.WriteString(s[start:i])
			}
			e.WriteByte('\\')
			switch b {
			case '\\', '"':
				e.WriteByte(b)
			case '\n':
				e.WriteByte('n')
			case '\r':
				e.WriteByte('r')
			case '\t':
				e.WriteByte('t')
			default:
				// This encodes bytes < 0x20 except for \t, \n and \r.
				// If escapeHTML is set, it also escapes <, >, and &
				// because they can lead to security holes when
				// user-controlled strings are rendered into JSON
				// and served to some browsers.
				e.WriteString(`u00`)
				e.WriteByte(json.Hex[b>>4])
				e.WriteByte(json.Hex[b&0xF])
			}
			i++
			start = i
			continue
		}
		c, size := utf8.DecodeRuneInString(s[i:])
		if c == utf8.RuneError && size == 1 {
			if start < i {
				e.WriteString(s[start:i])
			}
			e.WriteString(`\ufffd`)
			i += size
			start = i
			continue
		}
		// U+2028 is LINE SEPARATOR.
		// U+2029 is PARAGRAPH SEPARATOR.
		// They are both technically valid characters in JSON strings,
		// but don't work in JSONP, which has to be evaluated as JavaScript,
		// and can lead to security holes there. It is valid JSON to
		// escape them, so we do so unconditionally.
		// See http://timelessrepo.com/json-isnt-a-javascript-subset for discussion.
		if c == '\u2028' || c == '\u2029' {
			if start < i {
				e.WriteString(s[start:i])
			}
			e.WriteString(`\u202`)
			e.WriteByte(json.Hex[c&0xF])
			i += size
			start = i
			continue
		}
		i += size
	}
	if start < len(s) {
		e.WriteString(s[start:])
	}
	e.WriteByte('"')

	return e.Bytes(), nil
}
```

--- Comment #8 by dsnet ---
I have a use-case for this as well, but it's a bit specialized. Essentially:
1. There is a type that I own (as a library author) that is used by many users where they pass it through `encoding/json` when they shouldn't.
2. I would like to make changes to my type, but it breaks these users. I have no intention to support the use of this type with `encoding/json`, but I can't just break these users since there are are sufficient number of them.
3. I would like to use the feature proposed here to migrate these users to an implementation of marshal/unmarshal that preserves the exact behavior as it exists today (even if its buggy and wrong).
4. This now frees me to make the changes I want to make.

For prior art, the `cmp` package has a [`Comparer` option](https://godoc.org/github.com/google/go-cmp/cmp#Comparer) that allows the caller to override the comparison of any specific type in the tree. The ability for users to specify custom comparisons has proven itself to be immensely powerful and flexible.

Even though I'd like to have something like this, I do have some concerns:
* It is already the case that users often complain that `encoding/json` is too slow. The addition of this feature may make things slower. For `cmp`, the need to check whether any given value node matches a custom comparer is a significant source of slow down.
* A decision needs to be made whether the type override only supports concrete types or interfaces. Concrete types are easier to implement efficiently. However, supporting interfaces provides significant flexibility, but also brings in significant implementation and performance costs.
* What's the expected behavior when `json.Marshal` encounters a type `T`, and the type override has a custom marshaler specified for `*T`? If the value is addressable, then it makes sense to address the value and call the override function. What if the value is not addressable?

--- Comment #9 by harrisonhjones ---
Thanks for the response! Some comments below:

> It is already the case that users often complain that encoding/json is too slow. The addition of this feature may make things slower. For cmp, the need to check whether any given value node matches a custom comparer is a significant source of slow down.

I'd have to run a benchmark but I would expect a map lookup to be fairly quick. Perhaps others are concerned with a different scale of "slow" than I.

> A decision needs to be made whether the type override only supports concrete types or interfaces. Concrete types are easier to implement efficiently. However, supporting interfaces provides significant flexibility, but also brings in significant implementation and performance costs.

Interesting. I hadn't considered supporting interfaces. At the moment I only need concrete type overrides but if there are users out there that would benefit from an interface check I'd be willing to at least prototype it.

[Edit] Perhaps we could rename `RegisterMarshaller` to `RegisterConcreteMarshaller` and introduce `RegisterInterfaceMarshaller` later if users needed it?

> What's the expected behavior when json.Marshal encounters a type T, and the type override has a custom marshaler specified for *T? If the value is addressable, then it makes sense to address the value and call the override function. What if the value is not addressable?

This actually came up in a discussion with a colleague. My preference would be to require users that want to custom marshal both T and *T to have to declare both marshaler overrides. You could use a single custom marshaler but would require both overrides.

```
...
var foo = ""
enc.RegisterMarshaller(reflect.TypeOf(foo), StringMarshaller)
enc.RegisterMarshaller(reflect.TypeOf(&foo), StringMarshaller)
...

func StringMarshaller(value reflect.Value) ([]byte, error) {
    ... check if value is a *String, if so deref ...
    ...
}

```

Alternately perhaps we modify the signiture of `RegisterMarshaller` to be something like:

```
func (enc *Encoder) RegisterMarshaller(reflect.Type, bool, func(reflect.Value) ([]byte, error))
```

where, if the `bool` was "true" it would match both T and *T and if it was false it would only match T or *T, depending on the passed in type. Looks a bit yucky to me though could be made to look better if we used the optional pattern.


--- Comment #10 by harrisonhjones ---
@dsnet I imagine you might be busy with the holidays but I wanted to give you a friendly ping on this. Any thoughts on my response?

--- Comment #11 by gopherbot ---
Change https://golang.org/cl/212998 mentions this issue: `encoding/json: implement type override for serialization`

--- Comment #12 by dsnet ---
While the logic certainly uses `reflect` under the hood, I'm not sure if we should expose that in the public API. I propose the following API instead:
```go
// RegisterFunc registers a custom encoder to use for specialized types.
// The input f must be a function of the type func(T) ([]byte, error).
//
// When marshaling a value of type R, the function f is called
// if R is identical to T for concrete types or
// if R implements T for interface types.
// Precedence is given to registered encoders that operate on concrete types,
// then registered encoders that operate on interface types
// in the order that they are registered, then the MarshalJSON method, and
// lastly the default behavior of Encode.
//
// It panics if T is already registered or if interface{} is assignable to T.
func (e *Encoder) RegisterFunc(f interface{})

// RegisterFunc registers a custom decoder to use for specialized types.
// The input f must be a function of the type func([]byte, T) error.
//
// When unmarshaling a value of type R, the function f is called
// if R is identical to T for concrete types or
// if R implements T for interface types.
// Precedence is given to registered decoders that operate on concrete types,
// then registered decoders that operate on interface types
// in the order that they are registered, then the UnmarshalJSON method, and
// lastly the default behavior of Decode.
//
// It panics if T is already registered or if interface{} is assignable to T.
func (d *Decoder) RegisterFunc(f interface{})
```

Arguments for this API:
* Most users of this API probably do not want to deal with `reflect.Type` and `reflect.Value`, but rather want to deal with concrete types. For this reason, `json.Unmarshal` takes in an `interface{}` rather than an `reflect.Value`.
* Using `interface{}` looses type safety, but the other proposed signatures also have type safety issues. For a signature like: `func (enc *Encoder) RegisterMarshaller(t reflect.Type, f func(reflect.Value) ([]byte, error))`, we still can't statically guarantee that `t` is the same type as the type that function `f` expects as it's input.
* It matches what's done in other API that also have type-safety issues. For example, [`sort.Slices`](https://golang.org/pkg/sort/#Slice) takes in an `interface{}` with the requirement that it be a slice kind, rather than a `reflect.Value`.

The proposed API combined with the ability to handle interfaces, allows you to do something like:
```go
e := json.NewEncoder(w)
e.RegisterFunc(protojson.Marshal)
e.Encode(v)
```
where [`protojson.Marshal`](https://godoc.org/google.golang.org/protobuf/encoding/protojson#Marshal) is a function that matches the expected function signature. It enables the standard `encoding/json` package to now be able to properly serialize all `proto.Message` types without forcing or expecting every concrete `proto.Message` type to implement the `json.Marshaler` interface.

Since this is something I need for my other work, I uploaded a [CL with my prototype implementation](https://go-review.googlesource.com/c/go/+/212998) that I've been testing with actual code.

Some additional thoughts:
* One concern is that `json.Decoder.DisallowUnknownFields` specifies a top-level option that should in theory affect the results of all unmarshal operations recursively. It is already a problem today that custom `json.Unmarshaler` implementations do not properly respect this option (and has actually been a real problem). It's unfortunate that we're adding another way where options are not properly propagated downward. However, the severity of the problem is not as bad as custom `json.Unmarshaler` implementations since the location where options are specified is most likely also the place where custom encoder functions are registered, so options can be properly replicated at the top-level.
* The implementation checks for custom functions to handle the current value type first, and if the value is addressable, also tries checking for a pointer to that value type. This matches the behavior of `encoding/json` for how it handles checking for `json.Marshaler` and `json.Unmarshaler` implementations.
* The implementation does not call decoder functions if the receiver type is a pointer/interface and the input JSON is `null`. It also does not call encoder functions if the receiver type is a pointer/interface and is nil. This matches the behavior of `encoding/json` for how it handles `json.Marshaler` and `json.Unmarshaler` implementations.
* I haven't benchmarked it yet, but expect decoding to take minimal performance hit and encoding to take no performance hit when there are no custom encoders/decoders.
* Generics _might_ enable greater type safety for the proposed API, but the current proposal for generics does not allow type parameterization at the granularity of individual methods. 

--- Comment #13 by dsnet ---
Adding `Proposal` label as there are at least two proposed APIs and this issue proposes added API to `encoding/json`.

--- Comment #14 by dsnet ---
This proposal can be used to give users to ability to address the following issues on their own:
* #10275: encoding: make stdlib types implement TextMarshaler/BinaryMarshaler consistently
* #21990: encoding/json: support struct tag for time.Format in JSON Marshaller/Unmarshaller
* #29678: net: add MarshalText/UnmarshalText to HardwareAddr
* #33564: crypto/ecdsa: make PublicKey implement json.Unmarshaler and json.Marshaler

Overall, I've been concerned with the proliferation of magic methods where more and more types have `MarshalJSON`, `UnmarshalJSON`, `MarshalText`, or `UnmarshalText` methods attached. As the maintainer of a number of widely used libraries, I've been pushing back against users who ask for these methods to be added. A type override gives users the flexibility to do what they want, rather than forcing library authors to be responsible for maintaining these methods.

--- Comment #15 by rsc ---
Why is it RegisterFunc and not Register?


--- Comment #16 by rsc ---
Overall this seems reasonable to me. I would push back a little about not needing, say, MarshalText on types. It's good if types can create their own good representations by default when that makes sense. I would hope the per-Encoder registration would be necessary for exceptions, not common cases.

For example even if we had this registration it would still seem good to accept proposals like #33564. 

--- Comment #17 by dsnet ---
> Why is it RegisterFunc and not Register?

Could be either. I don't feel strong about this name.

--- Comment #18 by rsc ---
Let's use json.Register like gob.Register (different kind of argument but same idea).
Otherwise this seems like a **likely accept**.


--- Comment #19 by dsnet ---
To clarify, are you suggesting that the type-override registration be a top-level `Register` *function* or are you merely suggesting that the `Decoder` and `Encoder` *methods* be named `Register` out of consistency with `gob.Register`?

--- Comment #20 by rsc ---
@dsnet, only that the method on Decoder/Encoder be called Register.
It will be clear at call sites that a func is being passed; it doesn't add much to call it RegisterFunc.


--- Comment #21 by rsc ---
No change in consensus, so accepting.


--- Comment #22 by mvdan ---
@dsnet ended up sending a CL for this just weeks after I had self-assigned it; see https://go-review.googlesource.com/c/go/+/212998. I'm not sure why the bot didn't pick it up.

This is good news, though, as it seems like a proof of concept is implemented and we could have it in 1.16. I'm noting this here so more eyes can help review it.

--- Comment #23 by mvdan ---
I started reviewing the change, and got surprised by the support for interfaces. @dsnet wrote:

> A decision needs to be made whether the type override only supports concrete types or interfaces. Concrete types are easier to implement efficiently. However, supporting interfaces provides significant flexibility, but also brings in significant implementation and performance costs.

How was the decision made? I'm looking at `decodeState.indirect` in the CL, an I'm not a fan of the nested loop in the rather hot function. The godoc has no warning about the map lookup vs linear search penalty cost. I can imagine that registering ten custom interface marshalers could be surprisingly slower than registering ten concrete type marshalers, and the API doesn't give that impression.

There were a few use cases mentioned in this thread: `net.IP` of type `[]byte`, `time.Time` of type `struct`, `ecdsa.PublicKey` of type `struct`, and `net.HardwareAddr` of type `[]byte`. @dsnet also talked about types that "they own", and @harrisonhjones also mentions he just needs concrete type matching. Does anyone have a compelling use case for "assignable to" interface matching?

If the types can't be known at build time, or otherwise can't be matched in a concrete way, then I suggest that we support *a single* `func([]byte, interface{})` fallback to be used if none of the concrete type funcs match. This won't be as powerful, but it will also remove the expensive linear search with `go/types.Type.AssignableTo`.

In any case, I suggest that we first implement this feature *without* support for interface types. After one Go release with support for concrete types, the users can tell us if it really is not powerful enough.

--- Comment #24 by dsnet ---
At Google, we have https://go-review.googlesource.com/c/go/+/212998 imported as a separate fork that adventurous users are already using. The ability to specify type-override based on an interface is widely used. For our cases, it is typically used to capture all types that implement a `proto.Message` interface, but it's also used for other cases where a type doesn't have natural JSON support, and an interface match allows capturing types based on the public API (as specified by an interface) and to provide custom serialization for that type (based on the methods of that interface).

> func([]byte, interface{}) fallback to be used if none of the concrete type funcs match. This won't be as powerful, but it will also remove the expensive linear search with go/types.Type.AssignableTo.

There are ways to implement the linear search in O(1) with type caches, I didn't implement that here because it seems like premature optimization for the case where there are many type-overrides given that are all interfaces (expected to be rare).

Also, a `func([]byte, interface{})` fallback is 1) less performant since it now needs to be called for every node in the tree, rather than just named types that match the interface, 2) does not compose well with disjoint sets of interface types, 3) needs to also provide an API for saying; "thanks for calling me, but I actually don't know how to serialize this specific type; please try something else".

--- Comment #25 by mvdan ---
> The ability to specify type-override based on an interface is widely used.

And would using concrete types be a big problem in those two use cases you mention? Perhaps my uses of protobuf haven't been at "google scale", but I can imagine that registering up to a dozen or so concrete types should be more than enough for the majority of programs.

> I didn't implement here because it seems like pre-mature for the case where there are many type-overrides given that are all interfaces.

Can you elaborate a bit? I'm not quite seeing how that cache would work in constant time. If we're confident that this can be made performant in the future, then I'm not as worried about adding both features at once.

> Also, a `func([]byte, interface{})` fallback is [...]

I do realise that a single fallback is less powerful, and perhaps less intuitive too. I brought it up because it seemed like the current design was bound to be a fairly expensive linear search by design.

--- Comment #26 by mvdan ---
I also think that shipping support for concrete types alone in 1.16 would still be very useful. Googlers have told you what they think of both features, but from what you've said, they haven't tried using concrete types alone. And there isn't an easy way for developers outside of Google to do the same kind of testing (and very few people will go through the trouble unless we ship it in a release), so I fear that the feedback doesn't represent Go use cases outside of Google.

--- Comment #27 by dsnet ---
> Googlers have told you what they think of both features, but from what you've said, they haven't tried using concrete types alone

Concrete overrides are used to. I didn't mention them since the question I was responding to was about interface overrides.

> And there isn't an easy way for developers outside of Google to do the same kind of testing (and very few people will go through the trouble unless we ship it in a release), so I fear that the feedback doesn't represent Go use cases outside of Google.

Is there something specific that you are proposing? More users of the feature would be great. For users that only care about concrete type overrides, the existence of the interface type override doesn't affect them if they don't use it. Am I missing something?

--- Comment #28 by mvdan ---
> Is there something specific that you are proposing?

Yes; perhaps I wasn't very clear. Releasing 1.16 with *just* support for concrete types, not interface types. A smaller and less powerful feature, but also simpler and faster. And we try to measure how many people find it useful versus how many people still want support for interface types.

If both are available at once, it's likely users will jump straight to interface types without thinking whether using concrete types would be enough. Which is also why the performance difference worries me.

--- Comment #29 by dsnet ---
(apologies for responding out-of-order; for some reason my browser didn't render the earlier comment)

> And would using concrete types be a big problem in those two use cases you mention?

Yes. For some cases, it would require registering dozens (if not hundreds) of concrete types. Even worse, it requires that the user of manually keep the code that declares their types constantly in sync with where those types are used with JSON serialization.

> Can you elaborate a bit? I'm not quite seeing how that cache would work in constant time. If we're confident that this can be made performant in the future, then I'm not as worried about adding both features at once.

You can imagine a `sync.Map` that is functionally a `map[reflect.Type]bool`. It caches the answer to "will type T implement the set of registered interface type overrides?" If T is in the cache, then the query is O(1), if not, then we perform a linear lookup over all registered interface type overrides (which I contend is usually close to 0).

The challenge with the implementation is that the specific cache we want to use is itself dependent on the set of possible interface types that we may want to match against. Since I don't see having many interface type overrides being a common pattern, I didn't want to implement this for now.

--- Comment #30 by dsnet ---
> If both are available at once, it's likely users will jump straight to interface types without thinking whether using concrete types would be enough. Which is also why the performance difference worries me.

Can you explain how this would be the case? If there was a concrete type T that you wanted to provide an override for, then it seems natural that you would register a concrete type override. It seems odd to me to reach for an interface override unnecessarily for that case.

For example, let's say the user wants to provide a type override for `time.Time`, what interface would they be using to match that type? It seems more natural that they would register a `func(t time.Time) ([]byte, error)`. Also, it would be easier to implement since working with concrete types is easier than interface types (where you're limited to the methods in the interface).
