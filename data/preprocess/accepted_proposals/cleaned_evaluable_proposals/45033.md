==== [Issue Title] ====
strconv: add QuotedPrefix

==== [Issue Body] ====
The existing [`Unquote`](https://golang.org/pkg/strconv/#Unquote) function unescapes a Go string assuming that the entirety of input string is the escaped the string. However, in many parsing applications, we have a quoted string followed by some amount of unconsumed input, the presence of arbitrary characters after the quoted string currently breaks the `Unquote` function.

I propose adding:
```go
// UnquoteLeading interprets the start of s as a single-quoted, double-quoted, or backquoted Go string literal.
// Any subsequent characters after the terminating quote are returned as rem.
func UnquoteLeading(s string) (out, rem string, error)
```

This functionality may simplify a number of standard packages that implement their own logic to determine the end of a quoted string so that they can pass the correctly sized string to `strconv.Unquote`:
* [fmt/scan.go](https://github.com/golang/go/blob/8ac6544564be04ed1c0bbf7831ad0f8ed1f067ed/src/fmt/scan.go#L842-L880)
* [text/template/parse/lex.go](https://github.com/golang/go/blob/8ac6544564be04ed1c0bbf7831ad0f8ed1f067ed/src/text/template/parse/lex.go#L620-L638)
* [reflect/type.go](https://github.com/golang/go/blob/a8d9fb2fcd1fc11b41651e0ea608b3a3e90755b7/src/reflect/type.go#L1172-L1192)

==== [Comments] ====

--- Comment #1 by mvdan ---
I think this proposal makes sense; having to find the end of the quote manually means reimplementing a basic version of Unquote.

I also wonder if the input should be a `[]byte`; I realise the package is called strconv, but the use case is precisely about reading and buffering, where one almost always has a byte slice. The fmt and reflect examples you show have to explicitly convert to string before calling strconv, for example. I think the result is less important, as it's possible to construct the result with a strings.Builder.

--- Comment #2 by rsc ---
It may be that the operation to expose is "find me the end of this string" and not "also Unquote it".
I was discussing recently with Austin about adding a similar operation to regexp/parse, but I was thinking it would be separate from actually parsing. You don't always want to parse it, but you always need to identify a boundary.



--- Comment #3 by mvdan ---
That sounds more flexible, with the downside that one would end up looping over the input bytes twice. That already happens today, so perhaps the cost isn't significant enough to matter.

--- Comment #4 by dsnet ---
Given that many strings do not have any escape characters, the operation could report whether the string had any escape characters. If not, the user could trivially truncate off the leading and trailing quote characters and avoid a second pass.

--- Comment #5 by rsc ---

This proposal has been added to the [active column](https://golang.org/s/proposal-status#active) of the proposals project
and will now be reviewed at the weekly proposal review meetings.
â€” rsc for the proposal review group


--- Comment #6 by rsc ---
So if we do the string-end-finder, I guess the API would be:

```
package strconv

// QuotedPrefix returns the quoted string (as defined by Quote and Unquote) at the prefix of s.
// If s does not start with a valid quoted string, QuotedPrefix returns an error.
func QuotedPrefix(s string) (string, error)
```

?

Reporting the presence of absence of escape characters seems like premature optimization.






--- Comment #7 by dsnet ---
Wouldn't you need to know where the prefixed quoted string ended so that the caller can start parsing what comes afterwards?

> Reporting the presence of absence of escape characters seems like premature optimization.

I agree. In my all my use-cases, performance was not paramount. Also, this loop does not seem hard to write in the [extremely performance sensitive cases](https://github.com/golang/go/blob/8ac6544564be04ed1c0bbf7831ad0f8ed1f067ed/src/text/template/parse/lex.go#L622-L635).

--- Comment #8 by ianlancetaylor ---
> Wouldn't you need to know where the prefixed quoted string ended so that the caller can start parsing what comes afterwards?

You can call the `len` function on the result.

--- Comment #9 by dsnet ---
Ah yes, I apologize. I missed the part where it "returns the **quoted** string".

--- Comment #10 by dsnet ---
I feel like an API that simply returns the length of a valid quoted string (and the entire length otherwise) is simpler to use.

Suppose we had:
```go

// QuotedPrefixLen returns the length of the quoted string (as defined by Unquote) at the prefix of s.
// If s does not start with a valid quoted string, QuotedPrefix returns len(s).
func QuotedPrefixLen(s string) int
```

For example, if I wanted to parse the following text:
```
"string1" "string2" "string3"
```
the code would look like:
```go
in = strings.TrimSpace(in)
for len(in) > 0 {
    n := strconv.QuotedPrefixLen(in)
    s, err := strconv.Unquote(in[:n])
    if err != nil {
        ...
    }
    ... // make use of s
    in = strings.TrimSpace(in[n:])
}
```

Alternatively, with the `QuotedPrefix` API, you have to do an additional error check:
```go
in = strings.TrimLeft(in, " ")
for len(in) > 0 {
    s1, err := strconv.QuotedPrefix(in)
    if err != nil {
        ...
    }
    s2, err := strconv.Unquote(s1)
    if err != nil {
        ... // technically this will never happen, but it's not obvious to reviewers
    }
    ... // make use of s2
    in = strings.TrimLeft(in[len(s1):], " ")
}
```

That said, I'm still okay with `QuotedPrefix` as its better than nothing.

--- Comment #11 by rogpeppe ---
> I feel like an API that simply returns the length of a valid quoted string (and the entire length otherwise) is simpler to use.
> 
> Suppose we had:
> 
> ```go
> // QuotedPrefixLen returns the length of the quoted string (as defined by Unquote) at the prefix of s.
> // If s does not start with a valid quoted string, QuotedPrefix returns len(s).
> func QuotedPrefixLen(s string) int
> ```
> 
> For example, if I wanted to parse the following text:
> 
> ```
> "string1" "string2" "string3"
> ```
> 
> the code would look like:
> 
> ```go
> in = strings.TrimSpace(in)
> for len(in) > 0 {
>     n := strconv.QuotedPrefixLen(in)

Would `QuotedPrefixLen` return 0 if there's an escaping error inside the quoted prefix?

I guess if that's the case, you could still call `Unquote` on the full string and it'll produce the expected error, so it'll work out OK.


--- Comment #12 by dsnet ---
I struggled between having it return 0 or len(s) on error situations. The advantage of returning len(s) is that naive slicing of the input would pass an invalid string to `strconv.Unquote`, which would then produce a good error message. The downside is that you can't distinguish between a valid string that happens to be the full length or an invalid one.

--- Comment #13 by mvdan ---
Have it return `(int, bool)`? You could just ignore the boolean result if you don't need it.

--- Comment #14 by rsc ---
You can always wrap QuotedPrefix to get the single-result.
Returning the error lets you get specific information about what went wrong,
which the sentinel integer does not.



--- Comment #15 by rsc ---

Based on the discussion above, this proposal seems like a **[likely accept](https://golang.org/s/proposal-status#likely-accept)**.
â€” rsc for the proposal review group


--- Comment #16 by rsc ---

No change in consensus, so **[accepted](https://golang.org/s/proposal-status#accepted)**. ðŸŽ‰
