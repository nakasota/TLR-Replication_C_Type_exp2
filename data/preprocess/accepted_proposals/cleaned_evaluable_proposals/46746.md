==== [Issue Title] ====
reflect: add Value.Equal, Value.Comparable

==== [Issue Body] ====
In Go 1.17 we have introduced a conversion that can panic (#395).  This is the first case in which a conversion can panic.  This means that code that calls `reflect.Type.ConvertibleTo` and then, if that returns `true`, calls `reflect.Value.Convert`, can see an unexpected panic.  (See #46730.)

Separately, for a long time now it has been possible for a comparison to panic, when comparing two interface values that have the same dynamic type but for which the dynamic type is not comparable.  Therefore, for a long time code that calls `reflect.Type.Comparable` and then, if that returns true, uses the `==` operator can see an unexpected panic.  (This is a fairly uncommon case as the problem only arises when working with indirectly accessed interface types, such as pointers to interfaces.)

I propose adding two new methods to `reflect.Value`.

```Go
// ConvertibleTo reports whether v can be converted to type t.
// If this reports true then v.Convert(t) will not panic.
func (v Value) ConvertibleTo(t Type) bool

// Comparable reports whether the type of v is comparable.
// If the type of v is an interface, this checks the dynamic type.
// If this reports true then v.Interface() == x will not panic for any x.
func (v Value) Comparable() bool
```


==== [Comments] ====

--- Comment #1 by josharian ---
One very minor observation:

> // If this reports true then v.Interface() == x will not panic for any x.

I'm not sure this is quite right. `x` could be an interface containing a dynamic type that isn't comparable. In the common case, comparing two reflect.Values, you need to call Comparable on both of them. I don't have better wording to suggest.



--- Comment #2 by ianlancetaylor ---
I think the statement is still true, because if the dynamic types of `v.Interface()` and `x` are different, then the comparison is `false`, and it doesn't matter whether either or both of the dynamic types are not comparable.  In other words, if the dynamic type of `v.Interface()` is comparable, then either `x` has a different dynamic type and the result of `v.Interface() == x` is `false`, or `x` has the same dynamic type and the comparison will be run without panicking.

--- Comment #3 by josharian ---
Ah, indeed. Thanks. The relevant sentence from the spec is:

> A comparison of two interface values with identical dynamic types causes a run-time panic if values of that type are not comparable.

--- Comment #4 by rsc ---
We have:

```
func (v Value) Addr() Value
func (v Value) CanAddr() bool

func (v Value) Interface() interface{}
func (v Value) CanInterface() bool
```

So it sounds like we want to add the second one of these:

```
func (v Value) Convert(t Type) Value
func (v Value) CanConvert(t Type) bool
```

And maybe:

```
func (v Value) Equal(u Value) bool
func (v Value) Comparable(u Value) bool
```

Comparable seems like a better name than CanEqual here, but Equal seems better than Compare (compare bytes.Compare, bytes.Equal).

We probably want CanConvert at least for Go 1.17.


--- Comment #5 by rsc ---

This proposal has been added to the [active column](https://golang.org/s/proposal-status#active) of the proposals project
and will now be reviewed at the weekly proposal review meetings.
â€” rsc for the proposal review group


--- Comment #6 by rsc ---

Based on the discussion above, this proposal seems like a **[likely accept](https://golang.org/s/proposal-status#likely-accept)**.
â€” rsc for the proposal review group


--- Comment #7 by twmb ---
If a `Value` is `Comparable`, does this mean the return from `Interface()` can be used as a key in a map? I don't think `reflect` currently has a way to answer this question.

(this is just a clarifying question, not a comment against the proposal)

--- Comment #8 by josharian ---
> We probably want CanConvert at least for Go 1.17.

Is this still true? The window for doing this is pretty small now.

--- Comment #9 by ianlancetaylor ---
> If a Value is Comparable, does this mean the return from Interface() can be used as a key in a map? I don't think reflect currently has a way to answer this question.

Assuming you have a `map[interface{}]T` (for some value type `T`), then yes: if `v.Comparable()` returns `true`, you can use `v.Interface()` as a key value for that map, and no panic will occur.

--- Comment #10 by gopherbot ---
Change https://golang.org/cl/334669 mentions this issue: `reflect: add Value.CanConvert`

--- Comment #11 by ianlancetaylor ---
I sent https://golang.org/cl/334669 in case we do want this in 1.17.

--- Comment #12 by rsc ---

No change in consensus, so **[accepted](https://golang.org/s/proposal-status#accepted)**. ðŸŽ‰
