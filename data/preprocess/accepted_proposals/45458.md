=== Fetching Proposal: MDU6SXNzdWU4NTM5ODE2NTg= ===
Issue URL: https://github.com/golang/go/issues/45458

==== [Issue Title] ====
constraints: new package to define standard type parameter constraints

==== [Issue Body] ====
### Note: Discussion is now at #47319 

This proposal is for use with #43651.  The [proposal document](https://go.googlesource.com/proposal/+/refs/heads/master/design/43651-type-parameters.md) for that issue mentions adding a constraints package to define some standard useful constraints.  Here we propose a specific API to define.  If this proposal is accepted, the new package will be included with the first release of Go that implements #43651 (we currently expect that that will be Go 1.18).

This description below is focused on the API, not the implementation.  In general the implementation will be straightforward.

The intent is that if we add any new predeclared types, such as [`int128` and `uint128`](https://golang.org/issue/9455), those types will be supported by these constraints as appropriate based on the constraint descriptions.  To make this work, code should follow these guidelines: 1) given a type parameter whose constraint is taken from the constraints package, don't use that type parameter to instantiate a type/function whose constraint is not any and is not taken from the constraints package; 2) don't write a type switch to handle all types when using a constraint taken from the constraints package.  We can add vet checks to detect cases where these guidelines are not followed.

```Go
// Package constraints defines a set of useful constraints to be used with type parameters.
package constraints

// Signed is a constraint that permits any signed integer type.
type Signed interface { ... }

// Unsigned is a constraint that permits any unsigned integer type.
type Unsigned interface { ... }

// Integer is a constraint that permits any integer type.
type Integer interface { ... }

// Float is a constraint that permits any floating-point type.
type Float interface { ... }

// Complex is a constraint that permits any complex numeric type.
type Complex interface { ... }

// Ordered is a constraint that permits any ordered type: any type that supports the operators < <= >= >.
type Ordered interface { ... }

// Slice is a constraint that matches slices of any element type.
type Slice[Elem any] interface { ~[]Elem }

// Map is a constraint that matches maps of any element and value type.
type Map[Key comparable, Val any] interface { ~map[Key]Val }

// Chan is a constraint that matches channels of any element type.
type Chan[Elem any] interface { ~chan Elem }
```

==== [Comments] ====

--- Comment #1 by gudvinr ---
I'd like to just quote [this blogpost](https://blog.golang.org/package-names):
> **Avoid meaningless package names.** Packages named util, common, or misc provide clients with no sense of what the package contains. This makes it harder for clients to use the package and makes it harder for maintainers to keep the package focused. Over time, they accumulate dependencies that can make compilation significantly and unnecessarily slower, especially in large programs. And since such package names are generic, they are more likely to collide with other packages imported by client code, forcing clients to invent names to distinguish them.  
> ...
> **Don't use a single package for all your APIs.** ...

--- Comment #2 by ianlancetaylor ---
@gudvinr I don't think this proposal fails on either of those points.  This package is named "constraints", and it contains type constraints.  Nothing else.  It doesn't contain a bunch of different APIs.

But I would be happy to hear an alternative suggestion.  Thanks.

--- Comment #3 by smasher164 ---
Given that these constraints seem to be centered around describing builtin types, is there a reason something like `comparable` can't be declared here as well? I'm assuming the reason is something like "`comparable` requires a language spec change, while these constraints are just definitions." However the `unsafe` package is also described in the spec and is its own separate package.

--- Comment #4 by zephyrtronium ---
What factors decide which constraints are defined in this package? E.g., why are there all of `Signed`, `Unsigned`, and `Integer`, but not, say, "types convertible to string" (string, []byte, []rune, rune) or "types appendable to []byte" (string, []byte)?

--- Comment #5 by ianlancetaylor ---
@smasher164 Yes, as you say, `comparable` requires a language spec change.  This proposed package isn't comparable to the `unsafe` package.  The `unsafe` package exists only in the language spec.  The source code found in the standard library is only documentation.  The proposed `constraints` package would be an ordinary package like any other in the standard library.

@zephyrtronium I picked the constraints that seemed most likely to be useful.  If you want to make the case for additional constraints to be defined by the package, this is the place to do it.

--- Comment #6 by zephyrtronium ---
@ianlancetaylor 
> @zephyrtronium I picked the constraints that seemed most likely to be useful. If you want to make the case for additional constraints to be defined by the package, this is the place to do it.

I do think that the constraints I mentioned would be useful, but they might be better suited to living in packages `strings` and `bytes`. Similarly, I think the proposed `Float`, `Complex`, and `Ordered` might be more intuitive in `math`, `math/cmplx`, and `sort`, respectively, for reasons along the lines of @gudvinr's comment.

This would leave the integer constraints in an awkward spot. They'll certainly be useful, but were we to try to place these constraints in relevant standard library packages, there doesn't seem to be an existing home for them.

--- Comment #7 by smasher164 ---
@zephyrtronium 
Given that `math` already holds information like `MaxInt`, I could see the integral constraints being placed there.

And I agree we should explore putting constraints in the stdlib differently from the way C++ provides generic algorithms and concepts in `std::algorithms` and `<concepts>`. Go is really good about putting definitions where they are most suitable.

Although one might distinguish types and metatypes as being on different levels of some hierarchy, a user might expect the constraint to be in a package with related types and operations. A type that implements `sort.Interface`'s `Less` method and an `Ordered` type are conceptually similar.

--- Comment #8 by gudvinr ---
> This package is named "constraints", and it contains type constraints. Nothing else.  
> I picked the constraints that seemed most likely to be useful.

Your suggested interfaces only related to numeric types. So, when some developer will come up with another likely useful constraint for string manipulation he will probably put it into `strings` package.  
But since it also likely useful and also constraint it might end up in `constraints`.

So it will either end up as `ioutil` with bunch of unrelated stuff or will contain only interfaces related to numeric types. But if it only contains numeric constrains maybe `math` and its subpackages is a better place for such constraints.

--- Comment #9 by komuw ---
I think we should add `Comparable` to the constraints package even it is just a type alias to the builtin `comparable`.    
This is so that you do not have to explain to newbies why they have to import some constraints from `package constraints` but they do not have to do the same for comparable 

The same logic can be extended to the predeclared `any` constraint.

--- Comment #10 by DeedleFake ---
@komuw
I feel like they'll become very annoying to use if the standard is to import it, especially from a package with a long name like `constraints`:

```go
type Map[K comparable, V any] struct { ... }
// vs.
type Map[K constraints.Comparable, V constraints.Any] struct { ... }
```

I also think that it'll be _more_ confusing for new people if you have to explain why both `constraints.Comparable` and `comparable` exist and are completely identical, not to mention they could run into some code that uses one and some that uses the other and if they've never seen it before they'll probably get confused trying to figure out the difference.

Edit: Since the new idea is to think of them as sets of types as per #45346, maybe it would make more sense to name it something type set related to try to get it shortened a bit? I'm not sure what to name it, though. `sets` seems too generic, especially if `container/set` ever winds up being a thing, and `tsets` is just not right.

--- Comment #11 by DeedleFake ---
@gudvinr
As proposed it already contains non-numeric types. `Ordered` should have `~string` in it.

--- Comment #12 by meling ---
Having the constraints in one location promotes discoverability, but I agree with the other commenters that it feels more Go-like to keep them in relevant packages like `math` and `strings` etc. 

--- Comment #13 by ianlancetaylor ---
Personally I continue to think that it makes more sense for to have a single constraints package that contains common constraints.  I think it is simpler to write

    func F[T constraints.Integer]() { ... }

then to write

    func F[T math.IntegerConstraint]() { ... }

I don't think it can just be `math.Integer`; that doesn't convey anything to the reader.

--- Comment #14 by meling ---
Good point. I agree. But `constraints` is a bit long, especially with multiple constraints. I suspect many people will import them with `.` to avoid the long package name.

--- Comment #15 by gudvinr ---
> I don't think it can just be `math.Integer`; that doesn't convey anything to the reader.

Why though? You can only use constraints in type parameters. So it _does_ convey that it is a constraint.

--- Comment #16 by meling ---
> > I don't think it can just be `math.Integer`; that doesn't convey anything to the reader.
> 
> Why though? You can only use constraints in type parameters. So it _does_ convey that it is a constraint.

Not when looking at the doc; there they are interfaces. 

--- Comment #17 by gudvinr ---
> Not when looking at the doc; there they are interfaces.

Their location doesn't restrict you from using `constraints.Integer` as an interface if language allows it.  
There's no package `interfaces` with common interfaces after all.

--- Comment #18 by zephyrtronium ---
> Their location doesn't restrict you from using `constraints.Integer` as an interface if language allows it.

Related to this, I think it is important to consider future language changes. If Go gets sum types that use type constraint syntax, then it no longer strictly makes sense to call the types in the proposed package just constraints. Contrarily, names like `sort.TypeSet` are future-proof in this sense.

--- Comment #19 by DeedleFake ---
Maybe `types` makes more sense as a package name? It fits with the naming (`types.Signed`, `types.Ordered`, etc.), fits with the idea of type sets, and works with type set interfaces potentially becoming available as sum types later.

--- Comment #20 by cespare ---
I think that if people are referring to constraints so frequently that typing `constraints.` becomes a hassle, there are other, deeper problems than the naming of the package.

We should expect that *defining* parameterized types and functions ought to be a lot less common than *using* them in real-world code that does useful things, and thus we need not optimize for code which excessively references the constraints package.

--- Comment #21 by tooolbox ---
I don't support this proposal as given; my suggestion would be to revisit it some time after generics are added to the language.  A couple of releases later, there may be enough constraints in the wild to analyze which are the most useful and canonicalize them by adding them to the stdlib.  Conjecture about what people will use or not use seems premature, because once in the stdlib it can't change.  Wait for 5 packages to have a `Signed` constraint before we standardize it.

--- Comment #22 by ianlancetaylor ---
> my suggestion would be to revisit it some time after generics are added to the language.

Certain kinds of generics are going to be annoying to write without this proposal.  We can remove constraints if they don't seem useful, but I believe we at least need `constraints.Ordered` if nothing else.

--- Comment #23 by tooolbox ---
Ordered looks like this, in the old syntax:

```
// Ordered is a type constraint that matches any ordered type.
// An ordered type is one that supports the <, <=, >, and >= operators.
type Ordered interface {
	type int, int8, int16, int32, int64,
		uint, uint8, uint16, uint32, uint64, uintptr,
		float32, float64,
		string
} 
```

That doesn’t seem atrocious to write in a package that needs it, does it?  As an exercise, I’m curious generally how many functions you predict will need it?  The example of Smallest is given in the proposal but you must be thinking of others.

--- Comment #24 by fzipp ---
I once suggested the name `is` for a constraints package on the mailing list.

```
// Smallest returns the smallest element in a slice.
func Smallest[T is.Ordered](s []T) T

// Double returns a new slice that contains all the elements of s, doubled. 
func Double[E is.Number](s []E) []E
```


--- Comment #25 by fzipp ---
> I think that if people are referring to constraints so frequently that typing `constraints.` becomes a hassle, there are other, deeper problems than the naming of the package.
> 
> We should expect that _defining_ parameterized types and functions ought to be a lot less common than _using_ them in real-world code that does useful things, and thus we need not optimize for code which excessively references the constraints package.

To me it's about readability. The parameterized function signatures will be shown in the documentation. The typographic bulkiness of the word `constraints` might visually drown the rest of the signature and distract from the actual relevant parts.

--- Comment #26 by gudvinr ---
> I once suggested the name is for a constraints package on the mailing list.

What about  poor souls with internal methods as `(Whatever[T]).is() bool`or variables `is := IsDouble(another)`?  
`is.XXX` visually just isn't very distinctive from `IsXXX` or `isXXX` which might be a problem too.

--- Comment #27 by fzipp ---
> > I once suggested the name is for a constraints package on the mailing list.
> 
> What about poor souls with internal methods as `(Whatever[T]).is() bool`or variables `is := IsDouble(another)`?
> `is.XXX` visually just isn't very distinctive from `IsXXX` or `isXXX` which might be a problem too.

Technically it's not a problem because of scopes and shadowing. Constraints are only used in type parameter lists or embedded in other constraints, so there's little room for mistaking the package name for something else.

--- Comment #28 by jmank88 ---
Some 4 letter package name options:
- `package anys`: `anys.Integer`
- `package only`: `only.Signed`

Or a 6 letter, based on the description language:
- `package permit`: `permit.Float`

:shrug: 

--- Comment #29 by urandom ---
I'm not really happy about the name. I'm not really sure why it's plural, for one. It's also too lengthy. Consider the various packages under `container`. They are separate, not defined under `container` itself, and you don't end up with `container.List` or `container.Heap`. With such a precedent, you could create a `constraint/is` package, and put any necessary constraints there. You'll end up with a type constraint that's a readable `is.Ordered`

--- Comment #30 by nemith ---
Bike-shedding of the name aside, I think having some well defined constraints in the standard library will greatly improve the readability of type-paramaterized functions/structs, etc.  

On the bike-shedding I would rather have a longer descriptive name than a "clever" name like `is`, `only` or `anys`.  Coming in new to a languague you shouldn't need to explain why there is a non-descriptive name for a specific use.  
