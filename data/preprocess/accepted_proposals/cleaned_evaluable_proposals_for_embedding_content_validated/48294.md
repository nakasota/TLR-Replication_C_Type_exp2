reflect: renam mapiter.setkey/setvalu -> value.setiterkey/setitervalu
(copi comment avoid forgotten 1.18 release)
bikeshed: littl confus direct setting. `reflect`, have:
```
func (v Value) Set(x Value)
func (v Value) SetBool(x bool)
func (v Value) SetBytes(x []byte)
func (v Value) SetCap(n int)
func (v Value) SetComplex(x complex128)
func (v Value) SetFloat(x float64)
func (v Value) SetInt(x int64)
func (v Value) SetLen(n int)
func (v Value) SetMapIndex(key, elem Value)
func (v Value) SetPointer(x unsafe.Pointer)
func (v Value) SetString(x string)
func (v Value) SetUint(x uint64)
```
store valu receiv `v` input argument.
added:
```
func (it *MapIter) SetKey(dst Value)
func (it *MapIter) SetValue(dst Value)
```
however, contrari `reflect.value.setxxx`, valu store input argument state receiv `it`. opposit direction.
perhap renam `setkeyinto` `setvalueinto`? `storekey` `storevalue` (per @josharian' suggestion)?
\cc @rsc @randall77
even,
```
func (v Value) SetKey(it *MapIter)
func (v Value) SetValue(it *MapIter)
```
?
like even better :)
although, probabl want add `map` name:
```go
func (v Value) SetMapKey(it *MapIter)
func (v Value) SetMapValue(it *MapIter)
```
sinc map function `map` name: `value.mapindex`, `value.mapkeys`, `value.maprange`, `value.setmapindex`.
`setiterkey`/`setitervalue`.
look sourc alloc use `reflect`. anoth found someth follow pattern:
```go
v.Set(m.MapIndex(k))
```
ideally, would abl allocation-fre api. perhaps:
```go
v.SetMapIndex(m, k)
```
whatev name chose here, would hope steal good name possibl api.
propos ad activ column propos project
review weekli propos review meetings.
â€” rsc propos review group
propos seem renam function
v.setiterkey(it) (but effici than) v.set(it.key())
v.setitervalue(it) (but effici than) v.set(it.value())
right? kind trick v.set enabl kind optim invisibly?
> kind trick v.set enabl kind optim invisibly?
would ideal. #48000 class problem similar propos solution.
sure can, `it.key()` `it.value()` allocations. pass directli `set()` nowher els optim possible.
guess compil could special case `reflect.set(it.key())` (and perhap `set` variants?) call unexport `setiterkey` reflect. gone road semantic-inlin reflect packag yet.
part `it.key` alloc inlinable, mayb possibl call `v.set(it.key())` alloc heap escap analysi prove input `v.set` escape.
`it.key()` need alloc heap regardless escap analysi size need alloc constant.
order avoid copy, need know map write oper happen `it.key()` `set()`. way see know detect `set(it.key())` compil rewrit that. make user tell us use `setiterkey`.
thank discuss optimizations. seem like setiterkey setitervalu way go.
base discuss above, propos seem like **like accept**.
â€” rsc propos review group
chang consensus, **accepted**. ðŸŽ‰
