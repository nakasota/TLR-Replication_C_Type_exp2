unsafe: add slice(ptr *t, len anyintegertype) []t
`reflect.sliceheader` `reflect.stringheader` clumsi use `data` field type `uintptr` instead `unsafe.pointer`.
propos add type `unsafe.slice` `unsafe.string` replacements. would declar like packag reflect analogs, except `unsafe.pointer`-typ `data` fields:
type slice struct {
data pointer
len int
cap int
}
type string struct {
data pointer
len int
}
additionally, suggest purpos type conversion, treat `string` `unsafe.string` underli type, also `[]t` `unsafe.slice`. example, would valid:
func makestring(p *byte, n int) string {
// direct convers unsafe.str string.
return string(unsafe.string{unsafe.pointer(p), n})
}
func memslice(p *byte, n int) (re []byte) {
// direct convers *[]byte *unsafe.slice, without use unsafe.pointer.
:= (*unsafe.slice)(&res)
s.data = unsafe.pointer(p)
s.len = n
s.cap = n
return
}
result achiev use `unsafe.pointer` conversions, use direct convers compil provid littl extra type safety.
this, figur way exempt new type go 1 compat guarantee, chang represent string slice future. sure best that.
@ianlancetaylor reflect.slicehead reflect.stringhead alreadi try:
> cannot use safe portabl represent may chang later release.
compat doc give strong exempt unsafe:
> packag import unsaf may depend intern properti go implementation. reserv right make chang implement may break programs.
istm unsafe.{slice,string} would alreadi exempt sufficiently.
go 2 seem like time think (and reflect.slicehead etc).
-rsc @golang/proposal-review
propos seem bit redund
much use-cas "creat string slice alias c memory" vs. "manipul exist string slice tweak header field unsafely"?
like suggest renew consider propos go 1.14. think use user tri address issu flag -d=checkptr.
also offer counter-propos think better address end user need ergonom manner:
packag unsaf
func slice(ptr *arbitrarytype, len, cap int) []arbitrarytyp
func string(ptr *byte, len int) string
[edit: discuss below, favor combin slice' len/cap paramet singl parameter.]
littl less versatil expos header types, think minim type users, also provid better type safety.
could also propos origin one, want still offer full flexibl header types. case, would suggest renam type slicehead stringheader, reserv shorter slice string identifi constructor functions.
like counter propos api.
addit thought add counter proposal:
1. decid happen `len < 0` `cap < len`. lean toward panic, mayb leav unspecified/undefined.
edit: `ptr == nil && len > 0` anoth case consider.
edit 2: also, `len > maxwidth / unsafe.sizeof(*ptr)`.
2. function would builtins; particular, user can't write `f := unsafe.string; f(...)`.
3. `cap` argument `unsafe.slice` optional; omitted, `len` argument used. (just like `make([]t, n)` shorthand `make([]t, n, n)`.)
4. perhap `int` paramet actual follow goofi semant `make([]t, n, m)` follows. (i.e., `make([]t, uint64(10), int8(20))` valid, even though uint64 int8 normal assign int.)
5. sinc `unsafe.string` would builtin, could evalu untyp string.
api closer suggest use variant within googl coupl year without complaints.
type desir slice match pointer user (for example, one cgo-gener type nativ go type), assum caller could someth like:
```go
	var s = unsafe.Slice((*someGoType)(unsafe.Pointer(cPtr)), len, cap)
```
set element type?
> decid happen `len < 0` `cap < len`. lean toward panic, mayb leav unspecified/undefined.
would leav unspecified, `panic` fine implement ‚Äúunspecified‚Äù.
> perhap `int` paramet actual follow goofi semant `make([]t, n, m)` follows.
would certainli smooth call site (overwhelmingli common) case `len` and/or `cap` `c.size_t`.
> type desir slice match pointer user (for example, one cgo-gener type nativ go type), assum caller could someth like:
>
> ```go
> var = unsafe.slice((*somegotype)(unsafe.pointer(cptr)), len, cap)
> ```
>
> set element type?
yeah, that' thought. user want convert `*t` `[]u`, think reason requir explicit convers there.
> would leav unspecified, panic fine implement ‚Äúunspecified‚Äù.
ack, though concern panic default, user might come reli panick write checking.
would easi put panic behind `-d=checkptr` though.
> func slice(ptr *arbitrarytype, len, cap int) []arbitrarytyp
instead do:
```
func Slice(ptr *ArbitraryType, len int[, cap int]) []ArbitraryType
```
... option cap. omit cap mean cap == len?
@bradfitz yeah, that' addit thought #3 above. :)
> panic default, user might come reli panick write checking.
hmm, good point. could make throw! üòâ
could make `panic` ordinari code `throw` `-race` `-d=checkptr`. (the import thing, think, vari enough caus test fail reasonably-common configuration.)
> (the import thing, think, vari enough caus test fail reasonably-common configuration.)
obvious make randomli one other, like map iter order. :>
need abl specifi len < cap? constructed, slice.
@jimmyfrasche, good point. requir cap would simplifi api remov number behavior questions.
yeah, like simplifi just:
func slice(ptr *arbitrarytype, cap int) []arbitrarytyp
much type write `unsafe.slice(ptr, cap)[:len]` instead `unsafe.slice(ptr, len, cap)`, like @bradfitz point littl simpler specifi implement.
> much type write unsafe.slice(ptr, cap)[:len] instead unsafe.slice(ptr, len, cap), like @bradfitz point littl simpler specifi implement.
argument 3-arg slice op: `a[x:y:z] = a[x::z][:y-x]`, would need 2-arg `[x:y]` `[x::y]` operators. lost argument :(
contain prototyp implement counter-propos cmd/compile.
edit: cl 202082 demonstr usag within go runtime.
chang mention issue: `cmd/compile: implement unsafe.slic unsafe.string`
chang mention issue: `runtime: make use unsafe.slice`
chang mention issue: `cmd/compile: recogn (*[big]t)(ptr)[:n:m] pattern -d=checkptr`
@rsc suggest ad new, optional, paramet `make` slice type:
```Go
    make([]byte, p, l, c)
```
exampl would make new slice type `[]byte` underli array set `p`, length set `l`, capac set `c`. could use slice type. new `p` paramet would requir type `unsafe.pointer` (which would permit distinguish new case exist ones, second paramet must integ type untyp constant). capac paramet `c` would option today.
see overload `make` buy much term parsimony. make less obviou call site go on; type paramet effect invis human reader code, `unsafe.slice` never be.
think `make` actual great fit. types, `make` alloc kind back store (on either stack heap) return header refer back store.
contrast, pun `unsafe.pointer` slice alloc kind back store ‚Äî *only* return header refer exist data. feel like differ oper ‚Äî like convers `make`.
initi reaction `make` construct `[]t` `unsafe.pointer` less type-saf `unsafe.slice` construct `[]t` `*t`, re-review like use sites, seem less problem initi suspected. case cl 202082, `*t` explicitli convert `unsafe.pointer` anyway.
think like @josharian says, might tricki read code understand what' go on, think technic work address issue.
@bcmill think there' analog made c++' placement `new` operator. normal `new` alloc new memory, placement `new` use exist memory.
go call "placement make"?
ergonom ‚Äúplacement make‚Äù form seem wors compar `unsafe.slice`. draw exampl
@mdempsky' proposal, have:
```go
	scases := unsafe.Slice(cas0, ncases)
```
element type propag element type exist `cas0` variable.
contrast, @rsc' altern would have:
```go
	scases := make([]scase, unsafe.Pointer(cas0), ncases)
```
