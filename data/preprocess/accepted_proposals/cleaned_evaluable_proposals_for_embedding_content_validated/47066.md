reflect: permit value.byt (but setbytes) address byte array
tri get []byte array via reflect, without allocations.
reflect.value.byt says:
> byte return v' underli value. panic v' underli valu slice bytes.
array, slice. slice it, reflect.value.slic call allocates:
```
func TestArraySliceAllocs(t *testing.T) {
        type T struct {
                X [32]byte
        }
        x := &T{X: [32]byte{1: 1, 2: 2, 3: 3, 4: 4}}
        var b []byte
        n := int(testing.AllocsPerRun(2000, func() {
                v := reflect.ValueOf(x)
                b = v.Elem().Field(0).Slice(0, 5).Bytes()
        }))
        if n != 0 {
                t.Errorf("allocs = %d; want 0", n)
        }
        const want = "\x00\x01\x02\x03\x04"
        if string(b) != want {
                t.Errorf("got %q; want %q", b, want)
        }
}
```
(fail 1 alloc, slice)
perhap reflect.value.byt could also permit get `[]byte` array bytes?
mayb hold reflect wrong there' alloc-fre way already.
/cc @josharian
_pointer_ array byte `reflect.value`, could
p := v.interface().(*[8]byte)[:]
(assum know `8`)
code, that' `b = v.elem().field(0).addr().interface().(*[32]byte)[:]`
know length, though. want packag run anybody' type runtime.
see. think would fine allow `bytes` work address array (or pointer array?).
possibl make `slice` alloc array address (or pointer array)?
~~mayb tire think complet misread someth here, test code make sure `slice()` _doesn't_ allocate? mark error `testing.allocsperrun()` return anyth zero. error messag even explicitli say `alloc = %d; want 0`.~~
edit: definit tire think. somehow complet miss
> (fail 1 alloc, slice)
underneath.
read `reflect.value.slice()` `reflect.value.bytes()`. think special-cas `bytes()` allow call array make sense. prefer abl get rid alloc `slice()`, sure that' particularli feasibl without chang structur `reflect.value`. correct alloc happen `reflect.value` hold word data, store pointer newli creat slice header instead, caus escap heap line 1810? `-gcflags='-m'` seem anyth stdlib packages, even combin `-a`.
also probabl note pretti easi workaround, especi go 1.17:
```go
package main
import (
	"fmt"
	"reflect"
	"testing"
	"unsafe"
)
func main() {
	v := reflect.ValueOf(&[...]byte{3, 5, 7}).Elem()
	var s []byte
	n := testing.AllocsPerRun(1024, func() {
		s = unsafe.Slice((*byte)(unsafe.Pointer(v.Addr().Pointer())), v.Len())
	})
	fmt.Println(n)
}
```
like @randall77' suggest allow `bytes` address array non-nil pointer array.
code, have:
```go
if t.Kind() == reflect.Array {
	b = va.Slice(0, t.Len()).Bytes()
} else {
	b = va.Bytes()
}
```
would like reduc simply:
```go
b = va.Bytes()
```
avoid alloc occur `slice`.
analyz modul proxy, found:
* 655 case `x.slice(...).bytes()`
* 648 case `x.slice(0, ...).bytes()` (98.9% total)
* 276 case `x.slice(0, x.len()).bytes()` (42.1% total)
372 case `x.slice(0, ...).bytes()` `x.slice(0, x.len()).bytes()`, mani like `x.slice(0, n).bytes()`, `n` length array, obtain elsewher avoid repeatedli call `reflect.value.len`.
make v.bytes() work v address byte array seem ok.
optim away slice convers v.slice().bytes()?
propos ad activ column propos project
review weekli propos review meetings.
â€” rsc propos review group
optim alloc `v.slice()` sound hard. tricki part keep track arg `slice` somewhere.
could conceiv introduc anoth flag `reflect.value.flag` mean "thi slice ptr array slice bound 0 len(v.type.elem())", set flag slice pointer-to-array right `slice` args. everywher accept slice type need special case recogn flag.
avoid let `bytes` work address arrays, seem overkill.
> could conceiv introduc anoth flag reflect.value.flag mean "thi slice ptr array slice bound 0 len(v.type.elem())"
would unfortun still help common pattern `reflect.value.slice` `reflect.append` (#48000) alway allocate.
> make v.bytes() work v address byte array seem ok.
addition, probabl updat `value.setbytes` stay consist `value.bytes`.
setbyt seem difficult.
happen v.setbytes(x) v.len() len(x) differ sizes?
chang mention issue: `reflect: allow value.byt value.setbyt byte arrays`
mail prototype.
> happen v.setbytes(x) v.len() len(x) differ sizes?
would expect panic. `bytes` method alreadi make implicit assumpt length `[]byte` return array. seem reason `setbytes` expect length accepts.
`setbytes` behavior subtli differ though. `setbytes` `[]byte` replac pointers, copying. wherea `setbytes` array copi underli data.
unlik `bytes`, return `[]byte` alway alias storag input slice array.
would make sens `setbytes` address `*[n]byte` updat pointer point first `n` byte input byte slice?
mean `setbytes` address `[n]byte`. would use `copy` (which behavior prototyp does, think).
fact subtle, @randall77.
make think leav setbyt is, maybe?
look like today setbyt requir slice.
seem safest keep way.
agreed. realli want alia behavior, use `set`, realli want copi behavior, use `copy`.
```
var a *[4]byte = ...
var b *[4]byte = ...
// copy b to a
va := reflect.ValueOf(a)
vb := reflect.ValueOf(b)
reflect.Copy(va.Elem(), vb.Elem())
// alias b to a
va := reflect.ValueOf(a)
vb := reflect.ValueOf(&b).Elem()
vb.Set(va)
```
unlik `[]byte`, array pointer put interfac (and `reflect.value`s) without allocation, separ `set` function less useful.
@randall77 good point subtli differ behavior `[]byte` regard `setbytes`.
feel weird `bytes` `setbytes` asymmetrical, mayb that' necessity.
inde - read write asymmetrical.
base discuss above, propos seem like **like accept**.
â€” rsc propos review group
chang consensus, **accepted**. ðŸŽ‰
