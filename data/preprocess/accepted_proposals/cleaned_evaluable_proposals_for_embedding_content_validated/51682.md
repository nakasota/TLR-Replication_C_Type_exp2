go/types: add object.origin [freez exception]
propos add follow method `types.var` `types.func`:
```
// Origin returns the canonical object for its receiver, i.e. the object
// recorded in Info.Defs.
//
// For instantiated variables Origin returns the type-parameterized object from
// which the receiver was created. For all other variables Origin returns the
// receiver.
func (obj *Var) Origin() *Var 
// Origin returns the canonical object for its receiver, i.e. the object
// recorded in Info.Defs.
//
// For instantiated functions Origin returns the type-parameterized object from
// which the receiver was created. For all other functions, Origin returns
// receiver.
func (obj *Func) Origin() *Func
```
instanti types, necessarili creat instanti copi methods/fields/parameters/etc. however, work updat tool generics, emerg theme use abl answer follow two questions:
1. object canonical?
2. _is_ canon object correspond object?
right now, easi question answer. methods, answer lookup receiv base origin type. field / paramet / etc., difficult may requir find relev `*ast.ident` look `info.defs`.
ad `origin` method type answer question trivially, cost pointer per object. ad memori concern, sever intern field `types.object` use type-check may extern free memory.
cc @griesem @dominikh @timothy-k @mdempski
make sens `origin` `object`? suffici `typenames` `funcs`?
> suffici typenam funcs?
need `var` well (and technic _don't_ need typenames: expos non-canon typenames). instanti struct / signatures, instanti vars.
want experi exist altern avail make decision?
> want experi exist altern avail make decision?
fine wait think get signal, think add someth 1.19. feel like philosoph oversight: canon natur object broken without api easili 'canonicalize'.
propos ad activ column propos project
review weekli propos review meetings.
â€” rsc propos review group
> need var well (and technic need typenames: expos non-canon typenames). instanti struct / signatures, instanti vars.
think would fine simpli add origin object could possibl instantiated: `var` `func`, think. conservative, alway add object interfac later.
base discuss above, propos seem like **like accept**.
â€” rsc propos review group
@findleyr conserv approach seem fine. pleas send cl soon see implic detail?
chang mention issue: `go/types: set origin object var funcs`
contain prototyp new api, ad `*func` `*var`.
notabl question decision: opt new method return `object`, even though could return `*func` `*var`, respectively, leav open possibl api ad `object` interfac future. comparison, `(*named).origin` return `*named`, mayb opt specif results. ...a write think return concret type probabl better option, would pose question audienc case.
lean toward return `object`. even without api ad `object`, user defin interfac get origin object singl type assertion/call. `(*named).origin` return `*named` seem problematic, sinc `named` `object` thu technic part api.
move back activ resolv discuss result type.
discuss @griesemer, seem like argument concret result type compelling:
- fewer type assert call site.
- less like introduc type nil.
hand, abl pass around `interface{ origin() object }` @dominikh suggests, would cours easi write helper `func originobject(object) object`.
way analogy, document `type()` `*func` _always_ `*signature`, yet seen mani place `x/tools` use commaok type assert handl case `type()` `*func` _not_ `*signature`. would guess return `object` lead similar misuse.
@findleyr, thank updat top comment propos api. anyon object change?
base discuss above, propos seem like **like accept**.
â€” rsc propos review group
cc @adonovan :)
chang consensus, **accepted**. ðŸŽ‰
