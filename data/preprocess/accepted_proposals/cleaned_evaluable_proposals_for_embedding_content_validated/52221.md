crypto/ecdh: new packag
accord debian googl intern code search, crypto/ellipt use almost exclus part ecdsa (via `crypto/ecdsa`) ecdh. howev low-level unsaf api ecdh.
part effort move `math/big` outsid secur perimeter, move nist curv implement safe api `nistec` packag (#52182). `nistec` api safe still lower-level necessary.
ecdh use tls, ssh, jose, openpgp, piv, hpke, well compon variou eci schemes. myriad standard (iso, nist, ansi, secg, ietf) thank work nist p curv ecdh level.
**i'm propos ad new `crypto/ecdh` packag expos safe, `[]byte`-bas api ecdh.**
packag `crypto/ecdsa`, need direct use `crypto/elliptic`, `big.int`-bas method `elliptic.curve` (`scalarmult`, `scalarbasemult`, `add`, `double`, `isoncurve`) **deprecated**.
propos api. motiv design goal api:
* direct use crypto/ellipt replac it.
* support custom curves.
* ideally, x25519 support alongsid nist curves.
* implement entir constant time.
* invalid state can't represented.
* example, possibl provid invalid point scalar multiplication.
* error return everi invalid input.
* use one curv make curv implement reachable.
* help binari size govulncheck accuracy.
* publickey privatekey compat analog type packages.
* privatekey `public() crypto.publickey` method.
* possibl add addit method realiz might necessari later.
* main interfac privat method, can't implement extern type extend retain backward compatibility.
* addit standard ecdh flow, possibl valid public key, convert privat key public key.
* collabor compil possibl use api zero allocations.
* propos api, requir devirtualization, inlining, escap analysis.
* see #52193
/cc @golang/secur @golang/proposal-review
---
```
package ecdh
type Curve interface {
	// ECDH performs a ECDH exchange and returns the shared secret.
	//
	// For NIST curves, this performs ECDH as specified in SEC 1, Version 2.0,
	// Section 3.3.1, and returns the x-coordinate encoded according to SEC 1,
	// Version 2.0, Section 2.3.5. In particular, if the result is the point at
	// infinity, ECDH returns an error. (Note that for NIST curves, that's only
	// possible if the private key is the all-zero value.)
	//
	// For X25519, this performs ECDH as specified in RFC 7748, Section 6.1. If
	// the result is the all-zero value, ECDH returns an error.
	ECDH(local *PrivateKey, remote *PublicKey) ([]byte, error)
	// GenerateKey generates a new PrivateKey from rand.
	GenerateKey(rand io.Reader) (*PrivateKey, error)
	// NewPrivateKey checks that key is valid and returns a PrivateKey.
	//
	// For NIST curves, this follows SEC 1, Version 2.0, Section 2.3.6, which
	// amounts to decoding the bytes as a fixed length big endian integer and
	// checking that the result is lower than the order of the curve. The zero
	// private key is also rejected, as the encoding of the corresponding public
	// key would be irregular.
	//
	// For X25519, this only checks the scalar length. Adversarially selected
	// private keys can cause ECDH to return an error.
	NewPrivateKey(key []byte) (*PrivateKey, error)
	// NewPublicKey checks that key is valid and returns a PublicKey.
	//
	// For NIST curves, this decodes an uncompressed point according to SEC 1,
	// Version 2.0, Section 2.3.4. Compressed encodings and the point at
	// infinity are rejected.
	//
	// For X25519, this only checks the u-coordinate length. Adversarially
	// selected public keys can cause ECDH to return an error.
	NewPublicKey(key []byte) (*PublicKey, error)
	// Has unexported methods.
}
func P256() Curve
func P384() Curve
func P521() Curve
func X25519() Curve
type PrivateKey struct {
	// Has unexported fields.
}
func (k *PrivateKey) Bytes() []byte
func (k *PrivateKey) Curve() Curve
func (k *PrivateKey) Equal(x crypto.PrivateKey) bool
func (k *PrivateKey) Public() crypto.PublicKey
func (k *PrivateKey) PublicKey() *PublicKey
type PublicKey struct {
	// Has unexported fields.
}
func (k *PublicKey) Bytes() []byte
func (k *PublicKey) Curve() Curve
func (k *PublicKey) Equal(x crypto.PublicKey) bool
```
chang mention issue: `crypto/ecdh: new package`
propos ad activ column propos project
review weekli propos review meetings.
‚Äî rsc propos review group
## spec complianc summari
broadli three publish relev specif matter us: nist, ansi, secg. nist make open standard us government, ansi make paywal standard bank industry, secg made coupl open standards. nist standard cite ansi standard recently, secg effect made open version them.
nist draft fip 186-5 specifi ecdsa. fip 186-4 (2013) use refer ansi x9.62 (2005). nist sp 800-56a rev. 3 (2018) specifi ecdh. rev. 2 (2013) use refer ansi x9.63 (2011). sec 1, version 2.0 (2009) profil above. see appendix b.6 sec 1 extens discuss interoperability.
nist p curv defin appendix fip 186-4, draft nist sp 800-186, sec 2, version 2.0 (2010).
refer sec 1, version 2.0 fip 186-4, target subset compat üéâ
## compress point
#34105, ad support marshalcompress unmarshalcompress crypto/elliptic. would seem logic support compress point crypto/ecdh, too.
want support them, would propos ad
```
func (k *PublicKey) BytesCompressed() []byte
type Curve interface {
	NewPublicKeyFromCompressed(key []byte) (*PublicKey, error)
}
```
technically, could make `curve.newpublickey` support compress uncompress encodings, differ type prefixes. however, it‚Äô unlik applic wish support time, would forc everi user (includ crypto/tls) check prefix call `newpublickey`.
wrinkl technic speak x25519 public key compressed. so, `bytes`/`bytescompressed` `newpublickey`/`newpublickeyfromcompressed` would thing x25519.
option like add method now, wait time see requir materializes, shape.
## cryptokit compat
peopl mention need interoper apple‚Äô cryptokit.
play swift playground figur encod are, doc intent vagu it.
summari public keys, `x963representation` `bytes()` method generates, `rawrepresentation` `x963representation` without `0x04` prefix, `compactrepresentation` `bytescompressed()` would return without `0x02`/`0x03` prefix.
‚Äúbut wait‚Äù, you‚Äôll say, ‚Äúthat prefix convey import bit information!‚Äù uh, agree? look implement reveal follow expir 2014 ietf draft, draft-jivsov-ecc-compact-05, basic says‚Ä¶ make sure key alway lexicograph lower coordinate. indeed, cryptokit loop find key, unless `compactrepresentable: false` use `init`, case `publickey.compactrepresentation` might fail. now, make sad doesn‚Äôt match disambigu spec use (which switch least signific bit, lexicograph order correspond signific bit instead), can‚Äôt say ‚Äúalway add remov `0x20` prefix‚Äù. however, sinc ecdh oper return x coordinate, coordin doesn‚Äôt *really* matter: alway use `0x20` prefix 50% chanc wrong, ecdh output correct either way.
privat keys, `rawrepresentation` `bytes()` method generates, `x963representation` concaten `publickey.bytes()` `bytes()`. share secret `ecdh()` method returns. pem/der encod pkcs#8 pkix format support crypto/x509.
summary, take tweak propos api compat cryptokit. implement compress encoding, possibl support appl `compactrepresentation` tweak approximation. otherwise, we‚Äôll support `x963representation` `rawrepresentation`.
<details>
```
import CryptoKit
import Foundation
let key = P256.KeyAgreement.PrivateKey()
print(key.pemRepresentation)
print(key.publicKey.pemRepresentation)
print("// Raw private key,", key.rawRepresentation)
print(key.rawRepresentation.base64EncodedString())
print("// X9.63 private key,", key.x963Representation)
print(key.x963Representation.base64EncodedString())
print("// Raw public key,", key.publicKey.rawRepresentation)
print(key.publicKey.rawRepresentation.base64EncodedString())
print("// Compact public key,", key.publicKey.compactRepresentation)
print(key.publicKey.compactRepresentation!.base64EncodedString())
print("// X9.63 public key,", key.publicKey.x963Representation)
print(key.publicKey.x963Representation.base64EncodedString())
try key.sharedSecretFromKeyAgreement(with: key.publicKey).withUnsafeBytes{
	print("// Raw shared secret,", Data(Array($0)))
	print(Data(Array($0)).base64EncodedString())
}
```
```
-----BEGIN PRIVATE KEY-----
MIGHAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBG0wawIBAQQgDmJcofW/gvmaAind
jjIEAWGyZ24MKbb5VDvjHzZL60mhRANCAATFC9iQkp8dYI5EiWXi2APCusnMtNEr
c00/Frv3gbfSzTE6SX8NKEjM6JaO7c1w2rO5MRzgn+iJA8KFijctsPi/
-----END PRIVATE KEY-----
-----BEGIN PUBLIC KEY-----
MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAExQvYkJKfHWCORIll4tgDwrrJzLTR
K3NNPxa794G30s0xOkl/DShIzOiWju3NcNqzuTEc4J/oiQPChYo3LbD4vw==
-----END PUBLIC KEY-----
// Raw private key, 32 bytes
DmJcofW/gvmaAindjjIEAWGyZ24MKbb5VDvjHzZL60k=
// X9.63 private key, 97 bytes
BMUL2JCSnx1gjkSJZeLYA8K6ycy00StzTT8Wu/eBt9LNMTpJfw0oSMzolo7tzXDas7kxHOCf6IkDwoWKNy2w+L8OYlyh9b+C+ZoCKd2OMgQBYbJnbgwptvlUO+MfNkvrSQ==
// Raw public key, 64 bytes
xQvYkJKfHWCORIll4tgDwrrJzLTRK3NNPxa794G30s0xOkl/DShIzOiWju3NcNqzuTEc4J/oiQPChYo3LbD4vw==
// Compact public key, Optional(32 bytes)
xQvYkJKfHWCORIll4tgDwrrJzLTRK3NNPxa794G30s0=
// X9.63 public key, 65 bytes
BMUL2JCSnx1gjkSJZeLYA8K6ycy00StzTT8Wu/eBt9LNMTpJfw0oSMzolo7tzXDas7kxHOCf6IkDwoWKNy2w+L8=
// Raw shared secret, 32 bytes
Jeh6s9Kz5HWtCik8jzfPL1qbmg53PyEtt2fS8LEEtjY=
```
</details>
made small chang propos api: `publickey` embed `privatekey` gone, `newprivatekey` gener public key everi time, expens operation. matter ephemer ecdh, public key need gener set peer, static ecdh would unnecessari overhead.
instead, two method `privatekey`, `publickey` comput public key `sync.once`. `curve` method visibl embed anymore.
```
func (k *PrivateKey) Curve() Curve
func (k *PrivateKey) PublicKey() *PublicKey
```
`publickey()` get away return error x25519 oper alway succeed, nist curv fail (well, return irregular encoding) ident element, happen zero key, reject `newprivatekey`.
`public()` `publickey()`? latter return `*publickey`, former return `crypto.publickey` implement inform `crypto.privatekey` interface.
```
interface{
    Public() crypto.PublicKey
    Equal(x crypto.PrivateKey) bool
}
```
> publickey() get away return error x25519 oper alway succeed, nist curv fail (well, return irregular encoding) ident element, happen zero key, reject newprivatekey.
word `publickey` panic? (think boringcrypto similar implementations.)
> > publickey() get away return error x25519 oper alway succeed, nist curv fail (well, return irregular encoding) ident element, happen zero key, reject newprivatekey.
>
> word `publickey` panic? (think boringcrypto similar implementations.)
no, long semant `newprivatekey` correctli implement (that is, zero scalar rejected, document do), `publickey()` can't hit panic conditions. boringcrypto expect follow semantics.
@filosottil know go' boringcrypto ecdh look like sinc exist yet, look mine right 5 spot "fail":
1. `ec_point_new` return null
2. `ec_point_set_affine_coordinates_gfp` return fals (zero)
3. `ec_key_new_by_curve_name` return null
4. `ec_key_set_private_key` return fals (zero)
5. `ecdh_compute_key` return invalid length
mayb miss someth pessimistic, case seem unavoidable.
chang mention issue: `crypto/ecdh: implement compress points`
@elagergren-spideroak hmm, `ec_point_new` fail malloc failure, `ec_point_set_affine_coordinates_gfp` fail point known valid, `ec_key_new_by_curve_name` fail curv known supported, `ec_key_set_private_key` fail privat key known good, `ecdh_compute_key` return invalid length unless privat key zero must reject `newprivatekey`.
general, think make go api significantli harder use accommod cgo reimplementations, specif case think panic' would fine case would unreachable.
otherwise, cgo reimplement free work newprivatekey (which return error) take perform hit.
@filosottil yeah, also agre `publickey` return error. mean `publickey` _exactly_ panic free (in way go implement panic free).
like mentioned, possibl overli pessimist here. boringssl great, also seen mani "that can't happen" failur c cryptographi librari written cgo for. ü§∑‚Äç‚ôÄÔ∏è
end day, cgo backend tradeoff simplicity, performance, reliabl compliance, yeah :)
cl crypto/ecdh readi reviewed:
implement compress point per decid wait land it. add complex alway add go 1.20.
chang mention issue: `crypto/ecdh,crypto/internal/nistec: enabl prune unus curves`
## encod decod key
ecdh public privat key encod exactli like ecdsa key (a pkix pkcs#8, respectively), alreadi parser encod crypto/x509, return `*ecdsa.publickey` `*ecdsa.privatekey`. two options: add method ecdsa key type convert ecdh key types, duplic parser encod crypto/ecdh.
hard preserv properti "if use curv x, implement curv reachable" properti use gener encoders/decoders, expect capabl return curv base oid encoding. unless make method `curve` make support one curv time, would nice nudg toward avoid needless agility.
could also both. like compress points, suggest leav go 1.20, alway add things, time collect feedback look earli adopters, too.
@filosottil
> public() publickey()? latter return *privatekey, former return crypto.publickey implement inform crypto.privatekey interface.
mean `publickey()` return `*publickey`?
part propos api seem confus me. clear use two methods, privatekey return publickey methods. could method name made clear?
> ecdh public privat key encod exactli like ecdsa key (a pkix pkcs#8, respectively), alreadi parser encod crypto/x509, return *ecdsa.publickey *ecdsa.privatekey.
use `crypto/elliptic` implement ecdh, current necessari import `*ecdsa.{publickey, privatekey}` type alreadi littl strange. ideal there'd gener `*ec.{publickey, privatekey}` type share ecdh, ecdsa, x509 packag (but obvious possibl due break changes).
> two options: add method ecdsa key type convert ecdh key types, duplic parser encod crypto/ecdh.
go option use abl convert either direction. option b somewhat strang differ way encoding/decod ecdh ecdsa key (through method vs. call crypto/x509)
> > public() publickey()? latter return *privatekey, former return crypto.publickey implement inform crypto.privatekey interface.
>
> mean `publickey()` return `*publickey`?
>
> part propos api seem confus me. clear use two methods, privatekey return publickey methods. could method name made clear?
typo! yeah meant return `*publickey` like api list top comment.
```
func (k *PrivateKey) PublicKey() *PublicKey
```
> > ecdh public privat key encod exactli like ecdsa key (a pkix pkcs#8, respectively), alreadi parser encod crypto/x509, return *ecdsa.publickey *ecdsa.privatekey.
>
> use `crypto/elliptic` implement ecdh, current necessari import `*ecdsa.{publickey, privatekey}` type alreadi littl strange. ideal there'd gener `*ec.{publickey, privatekey}` type share ecdh, ecdsa, x509 packag (but obvious possibl due break changes).
>
> > two options: add method ecdsa key type convert ecdh key types, duplic parser encod crypto/ecdh.
>
> go option use abl convert either direction. option b somewhat strang differ way encoding/decod ecdh ecdsa key (through method vs. call crypto/x509)
agre would bit weird, crypto/ecdsa type forc round-trip `big.int` unfortunate, would nice way avoid it. also want avoid make crypto/ecdh depend math/big all.
anyon object api proposed?
base discuss above, propos seem like **like accept**.
‚Äî rsc propos review group
chang consensus, **accepted**. üéâ
