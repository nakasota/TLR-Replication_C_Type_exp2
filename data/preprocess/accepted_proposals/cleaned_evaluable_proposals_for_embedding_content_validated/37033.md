runtime: provid central facil manag (c)go pointer handl
non-trivi program reli cgo eventu find need use callback interact go objects. current "customary" way deal situat packag implement come sort global map establish correspond go pointer sort custom cgo handle.
(i'm talk pointer complex go objects, normal disallow cgo call checker).
unfortunate, mani cgo enabl packag requir carri boilerpl code lot potenti hard find bugs, as:
1. handl assign collis
2. pointer "leaks"
3. concurr issues, access "pointer handle" map
therefore, nice go runtim provid small api handl case cleanly, tune of:
```
// Make i non-collectable and non-movable and return a cgo handle h for it
func cgoMakeHandle(i interface{}) (h uintptr)
// Given a cgo handle, return a Go reference for the object, if valid
func cgoGetHandle(h uintptr) (i interface{}, ok bool)
// Same as "get" above, but the handle h becomes invalid, and reference i becomes collectable
// and movable again
func cgoReleaseHandle(h uintptr) (i interface{}, ok bool)
```
`h` handle, valid, suppos safe passabl nativ code back.
go add gener purpos facil make arbitrari number pointer non-collect non-movable. goe one main goal fix known number pointer moment time.
see anyth wrong handl part proposal, see reason runtim package. package, use map.
even stay map, much better truli global, pointer keyed, concurrency-saf map.
current one big mess. everi complex cgo packag come creativ way store pointer alloc handles. caus prolifer global variabl unclear semantics, contribut non-obvi side effects.
great deal "applic domain specific" librari infeas port go anytim soon. hand, go alreadi reach suffici level popular prolifer places, conceiv earlier, link libraries.
therefore, make sens standard pointer pass issu bit further. comparison, java reason full featur jni spec cover aspect nativ code interact day one, help adopt lot earli 00' pure java code abund yet.
object basic idea, say runtim package.
reference, version idea wrote use insid googl api:
```Go
// H is the type of a handle to a Go value.  The underlying type may change, but
// values are guaranteed to always fit in a C.uintptr_t.
//
// The zero H is never a valid handle, and is thus safe to use as a sentinel in
// C APIs.
type H cUintptr
// New returns a handle for a Go value.  The handle is valid until the
// program calls Delete on it.  The handle uses resources, and this
// package assumes that C++ code may hold on to the handle, so the
// program must explicitly call Delete when the handle is no longer
// needed.  The intended use is to pass the returned handle to C
// code, which passes it back to Go, which calls Value.
func New(v interface{}) H
// Delete removes a handle.  This should be called when C code no
// longer has a copy of the handle, and the program no longer needs
// it.  This returns an error if the handle is not valid.
func Delete(h H) error
// MustDelete removes a handle, and calls log.Fatal if the handle is
// not valid.
func MustDelete(h H)
// Value returns the Go value for a handle.  If the handle is not
// valid, this returns an error.
func Value(h H) (interface{}, error)
// MustValue looks up a handle.  If the handle is not valid, it calls
// log.Fatal.
func MustValue(h H) interface{}
```
got packag like well. like mani people/companies. exactli point - someth like standardized.
understood. again, object basic idea, say runtim package.
next step pick packag defin api.
could easili publish packag outsid standard librari see much use gets. unclear _must_ standard library.
> much better truli global, pointer keyed, concurrency-saf map.
note singl global map would like encount lot cach content implement use primit standard librari today.
(#21035 would need address order implement librari use `sync.map` way scale appropri cpu core count.)
go standard library, alreadi runtime/cgo packag export api, could add
```
type Handle uintptr
func NewHandle(v interface{}) Handle
func (h Handle) Delete() // panics if h already deleted or invalid
func (h Handle) Value() interface{} // panics if h already deleted or invalid
```
seem come often, could good implementation. thoughts?
base discuss reaction last comment, seem like **like accept**.
peopl rejoiced!
chang consensus, accepted.
like newhandl function. could return error? duplic handled? mix types? return error uintptr 0 seem clearer here.
think worri duplicates. problem multipl handl singl go value. see error possibl (other run memori alway caus program crash).
chang mention issue: `runtime/cgo: add handl manag (c)go pointers`
sent prototype, roughli work except break non-cgo program request build extern link mode. implement introduc depend cgo package, wherea non-cgo program extern link mode explicitli import cgo need load cgo tl initi thu caus failur link phase.
good sens fix landed, idea suggestions?
chang mention issue: `runtime/cgo: add handl manag (c)go pointers`
case anyon wonder two cls. implement turn `newhandle` provid two differ behaviors:
1. `newhandle` return uniqu handl provid go valu refer object (cl 294670)
2. `newhandle` alway return differ handl go valu multipl handl (cl 295369)
either way, seem decis question.
think function name `newhandle` need realli return uniqu handl time. would also ok function return (reference-counted) handl everi time, would need differ name.
said, suspect much easier detect diagnos use-after-fre bug `newhandle` return uniqu handl call.
personally, would prefer first behavior, total make sens `newhandle` name fulli match behavior itself, thu choos first, mayb could name `createhandle`, `openhandle` someth fit more. examples, as: `os.create`, `os.openfile`, etc.
understand would want tri provid handl go value. go type comparable, well defined. see address purpos issue.
trivial produc handl go value, would one thing. think cl show trivial. think try.
no, get comment wrong. express possibl implementation, argu one better other. live both, matter decid eventu :)
@rsc approv proposal, want take anoth look?
