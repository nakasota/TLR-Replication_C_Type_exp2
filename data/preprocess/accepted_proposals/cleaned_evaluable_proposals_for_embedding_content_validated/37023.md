runtime: panicmem expos address panick about.
### version go use (`go version`)?
1.13
### issu reproduc latest release?
probabl
### oper system processor architectur use (`go env`)?
amd64
### do?
know, result segfault. :) start experi panic recover, discov (somewhat surprise) *can* catch segv' panic.
### expect see?
runtim error/exception/someth compar inform get recover().
### see instead?
string "invalid memori address nil pointer dereference"
so, contrast:
```
unexpected fault address 0x7f84e68d6112
fatal error: fault
[signal SIGSEGV: segmentation violation code=0x1 addr=0x7f84e68d6112 pc=0x5f17cb]
goroutine 992352 [running]:
runtime.throw(0xfab924, 0x5)
        /usr/local/Cellar/go/1.13/libexec/src/runtime/panic.go:774 +0x72 fp=0xd5b852e7f8 sp=0xd5b852e7c8 pc=0x42f3b2
runtime.sigpanic()
        /usr/local/Cellar/go/1.13/libexec/src/runtime/signal_unix.go:401 +0x3de fp=0xd5b852e828 sp=0xd5b852e7f8 pc=0x444a3e
[...]
```
look [runtime/]debug.stacktrace(), get information, can't necessarili get actual address unexpect fault. look like runtim inform time panic gener (or would be, turn setpaniconfault):
```
        case _SIGSEGV:
                if (g.sigcode0 == 0 || g.sigcode0 == _SEGV_MAPERR || g.sigcode0 == _SEGV_ACCERR) && g.sigcode1 < 0x1000 {
                        panicmem()
                }
                // Support runtime/debug.SetPanicOnFault.
                if g.paniconfault {
                        panicmem()
                }
                print("unexpected fault address ", hex(g.sigcode1), "\n")
                throw("fault")
```
look like panicmem expos values. possibl should. can't think reason approach immedi -- obvious like siginfo_t exposed, except unport even memori fault handl standard compat implementations. seem like expos affect address (g.sigcode1) possibl kind-of-error (segv_maperr segv_accerr?)
simpl baselin think probabl support current systems, panicmem took uintptr, result panic error type could queri uintptr, display default, might make life easier.
one hand, want catch panic prevent break things, hand, diagnos sort benefit address available.
(on third hand, might chang exact panic result case would break compat promise, without hypothet new debug.setfancypaniconfault() would use exist code.)
could someth this. type runtim panic explicitli unspecified:
add addr() method valu panic with,
```
type addrable interface {
    Addr() uintptr
}
e := recover()
if a, ok := e.(addrable), ok {
   _ = a.Addr()
}
```
includ kind-of also? sure. rapidli reach implementation-specif areas, think want do.
can't alway get address either. exampl amd64 fault address malform (top 17 bit 0s 1s) get address fault all. case definit can't pass anywher else. convinc this.
want it? there' usual much use it.
yeah, notic lack address high bit set recently. rememb mc68k program said "oh hey address bu 24 bits, use top word mask out", *so* look forward amd64 littl bit here.
reason want turn let distinguish "i idea garbag here" "wow amaz coincid address space got munmap recently".
get throw(), dump everi mmap oper happen *in case* there' crash later, week logging, get crash relev thing last five line logs. use paniconfault, can't tell thing relevant, look recent activity. use paniconfault, got address (when possible/applicable), could look recent activ report exactli happened, life would lot simpler. (and realli seem days-to-week events.)
agre there' usual *much* use it, specif case mmap involv (which pretti much time like want paniconfault anyway), distinct "an invalid address" "an invalid address trace specif memory-map region" significant.
ad address help paniconfault, could see mayb this.
thoughts, @aclements, @ianlancetaylor, @randall77?
see problem long document inform system-dependent, alway avail reliable.
would languag spec chang runtim packag change? spec say runtim error "perhap methods" guess runtime.
three signal produc runtim panic: `sigbus`, `sigsegv`, `sigfpe`. set `si_addr` field. `sigbus` `sigsegv` set memori address caus fault. `sigfpe` set memori address instruct faulted. provid address cases? think not, soft float point implement get float point except without signal without specif associ instruction.
intuitively, would realli confus runtim panic sigfp gave differ *kind* address two do, redund already-avail stack backtrace. think probabl confus provid one. (if sigfp gave address float point object, might almost useful, know code executing, alreadi abl narrow pretti well.)
think make sens add spec change, specif particular runtim implementation; runtime.paniconfault, never come up.
sigfp alreadi turn differ panic.
target paniconfault would appli panic gener case, sigbus, sigsegv.
need languag spec chang (it mention paniconfault either), suitabl non-committ good address is.
base discussion, seem like **like accept**.
chang consensus, accepting.
chang mention issue: `runtime/debug: provid address method error setpaniconfault`
