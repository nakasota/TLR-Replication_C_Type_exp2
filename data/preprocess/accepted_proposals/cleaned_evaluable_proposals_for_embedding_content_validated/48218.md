reflect: add value.fieldbyindexerr
see among others.
panick value.fieldbyindex follow chain embed field encount nil. way caller fieldbyindex prevent panic arbitrari data essenti implement type walk itself. fix issu wrap fieldbyindex turn panic error, seem reflect provid that.
mild propos reflect.valu get new method return error instead panicking. (we can't chang origin would requir signatur change.) trivial implement; hard part choos name.
`tryfieldbyindex`?
`fieldbyindexerr` - keep simpl
`fieldbyindexwitherror`
`fieldbyindexnopanic` - descript
`stablefieldbyindex` || `fieldbyindexstable` - follow convent `stable` depict panick crash allowed.
name aside, also option `canfieldbyindex(index []int) bool`, similar other like `canint` `canconvert`. least would consist rest api design.
@mvdan would requir doubl iter arguabl code call site, unfortunate. error return pattern better model?
probably. intent list anoth option - api-consist - sake lay out.
seem worth doing. suggest fieldbyindexerr, return error instead panick invalid index nils, error unexpect embed nil someth like "nil t1' embed *t2", give use context nil is.
propos ad activ column propos project
review weekli propos review meetings.
â€” rsc propos review group
similar function stdlib return error instead panicking?
naiv look goroot see export function end `err`, look bit odd.
<details>
```console
$ rg 'func [A-Z]\w+Err\(' $(go env GOROOT)/src --glob '*.go' --glob '!*_test.go'
$ rg 'func [A-Z]\w+Error\(' $(go env GOROOT)/src --glob '*.go' --glob '!*_test.go' | pbcopy
/usr/local/Cellar/go/1.17/libexec/src/syscall/syscall_plan9.go:func NewError(s string) error { return ErrorString(s) }
/usr/local/Cellar/go/1.17/libexec/src/syscall/zsyscall_windows.go:func GetLastError() (lasterr error) {
/usr/local/Cellar/go/1.17/libexec/src/os/error.go:func NewSyscallError(syscall string, err error) error {
/usr/local/Cellar/go/1.17/libexec/src/go/scanner/errors.go:func PrintError(w io.Writer, err error) {
/usr/local/Cellar/go/1.17/libexec/src/cmd/vendor/golang.org/x/mod/module/module.go:func VersionError(v Version, err error) error {
/usr/local/Cellar/go/1.17/libexec/src/cmd/vendor/golang.org/x/xerrors/adaptor.go:func FormatError(f Formatter, s fmt.State, verb rune) {
/usr/local/Cellar/go/1.17/libexec/src/cmd/vendor/golang.org/x/sys/windows/zsyscall_windows.go:func GetLastError() (lasterr error) {
/usr/local/Cellar/go/1.17/libexec/src/cmd/vendor/golang.org/x/sys/unix/gccgo.go:func SyscallNoError(trap, a1, a2, a3 uintptr) (r1, r2 uintptr) {
/usr/local/Cellar/go/1.17/libexec/src/cmd/vendor/golang.org/x/sys/unix/gccgo.go:func RawSyscallNoError(trap, a1, a2, a3 uintptr) (r1, r2 uintptr) {
/usr/local/Cellar/go/1.17/libexec/src/cmd/vendor/golang.org/x/sys/unix/syscall_linux_gc.go:func SyscallNoError(trap, a1, a2, a3 uintptr) (r1, r2 uintptr)
/usr/local/Cellar/go/1.17/libexec/src/cmd/vendor/golang.org/x/sys/unix/syscall_linux_gc.go:func RawSyscallNoError(trap, a1, a2, a3 uintptr) (r1, r2 uintptr)
/usr/local/Cellar/go/1.17/libexec/src/cmd/api/testdata/src/pkg/p2/p2.go:func NewError(s string) error {}
/usr/local/Cellar/go/1.17/libexec/src/cmd/go/internal/mvs/errors.go:func NewBuildListError(err error, path []module.Version, isVersionChange func(from, to module.Version) bool) *BuildListError {
/usr/local/Cellar/go/1.17/libexec/src/cmd/go/internal/robustio/robustio.go:func IsEphemeralError(err error) bool {
/usr/local/Cellar/go/1.17/libexec/src/cmd/vet/testdata/print/print.go:func UnexportedStringerOrError() {
```
</details>
opposit case, use `must` want panic instead error, perhap ask whether establish counterpart "must"?
---
decid look gopath / modul cache. find occurr `func somethingorerror(...) error`. would `fieldbyindexorerror` good fit func propos here?
```go
// FieldByIndexOrError returns the nested field corresponding to index.
// It returns a non-nil error if v's Kind is not struct or if (...).
func (v Value) FieldByIndexOrError(index []int) (Value, error)
```
current `fieldbyname` return "zero value" field found. can't chang `fieldbyindex` also return "zero value" field found. generally, backward compat switch case panick one doesn't. case reli panic probabl still panic sinc usag zero `value` panic.
@dsnet two reason rather go way, least exclusively.
first code panic annoying, least panic point line thing went wrong. fieldbyindex return zero value, code might (and exist code certainli would) continu execut would either crash somewher else, make problem obscure, execut complet incorrectly.
second fieldbyindex unusu loops. that' root problem: difficult caller protect bad data might nest deep. thu fail, reason still hidden. would like error come back fieldbyindex know field nil. return zero value, caller must still work tri avoid order give help error message.
although might want chang function panic well, sake debug help error messag variant explain went wrong, error return canon way that.
> least panic point line thing went wrong
that' good argument.
> would like error come back fieldbyindex know field nil. return zero value, caller must still work tri avoid order give help error message.
error intend human consumption, machin interpretation, both?
mani suggest return `error`. somewhat hesit `error` return type because:
1) suspect valid use case abl machin interpret problem occurred, `error` sharp api sinc need type assert name `error` type semant information,
2) api `reflect` thu far tend avoid ever return error. @mvdan notes, seem much api built around predic tell whether oper possibl (e.g., `value.canxxx`) oper may panic (e.g., `value.set`).
add new api, prefer see someth return `error` return suffici inform explain what' happening. perhaps:
```go
// FieldByIndexN iterates through index successively trying to index the nth field of v.
// If the current value is not a struct, is a nil pointer, or the index is out of bounds,
// then iteration ends returning the current value and the iteration index.
//
// FieldByIndexN (if fully successful) is equivalent to returning (v.FieldByIndex(index), len(index)).
func (v Value) FieldByIndexN(index []int) (Value, int)
```
thus, easili construct error messag information, also make use machin interpret whether index valid.
understand reluct go grain exist api reflect package, value.fieldbyindex unusu (unique?) way operates, reflect api old. think thing today stare over. zero valu serious annoy program against, example. rather know went wrong. written reflect-driven code most, alway pain track miss zero valu go wrong.
particular fieldbyindexn suggest, unpack simpl loop insid fieldbyindex throw back caller, make needlessli cumbersom slower. loop alreadi written, tightly, insid exist function.
although argument return error make sens isolation, modern go error do. invent new way looping, adher api convent weather well, much messier trivial chang add error return.
go add new api this, like discuss whether relat function also ad not.
"encoding/json" package, logic `unmarshal` similar `value.fieldbyindex`, instead panick nil pointers, expect alloc new struct behalf proceed index nest struct. could call `value.mutablefieldbyindex` something.
serious propos ad method, clear one function might meet bar inclus one.
cases, work around lack nativ method 10-20 line code.
@dsnet sure say here. mix two packag hypothet there. pleas clarify?
make argument use variant `fieldbyindex` exist beyond one avoid panicking. given exist variants, like know variant meet bar inclus reason variant (e.g., `mutablefieldbyindex` mention comment).
suggest one variant, one proposing, suffici easi use. histori saddl us panick variant, troublesome.
note wide use function. standard library, outsid test appear hand times, gob xml template, one vendor package.
anoth answer, would fine with, leav thing alon deal panic wrapper. open issu get sens peopl want. sometim "noth new" right answer.
> suggest one variant, one proposing, suffici easi use.
easi use nice, perform key too. current propos variant return error, probabl impli alloc (otherwis question util `error` return value). such, think prevent use perform sensit code. example, "encoding/json":

would correct switch logic variant propos here, probabl still perform reasons.
@dsnet jump "but perform" gun, much would like see metric claim. suspect chang negligible, definit let' back numbers. ;)
> much would like see metric claim.
sure. show `fieldbyindexn` (a propos above) 2.7x faster `fieldbyindexerr` `fieldbyindexerr` return fairli useless error. `fieldbyindexerr` spend effort construct someth meaning like field nil, end 12x slower.
also, usag `fieldbyindexn` `json` logic would someth like:
```go
fv, n := v.FieldByIndexN(f.index)
if n < len(f.index) {
    continue FieldLoop
}
```
cheers, thank numbers! that' good point, document comment function sacrific perform turn stability.
@dsnet understand point allocation. overwhelm major case error nil, allocation. case caus problem nest embed field nil pointer struct inside. that' rare.
seem differ idea whole problem. propos make easier client use routin shorter safer. mismatch expect here. noth seen practic would indic bottleneck. argu performance-crit function.
fieldbyindexn would serve, client would need work get valuabl error. guess that' disagreement: want good error return functionâ€”in fact that' wantâ€”but seem interest that.
look, tini matter requir much discussion. let' see propos committe thinks.
agre overanalyzed.
reflect api, misus - like call .len pointer pass invalid index - panics.
go reconsid decis today.
ad fieldbyindex, thought possibl error misuse, henc error.
embed nil struct pointer misuse:
properti input cannot predict caller.
given index set clearli valid t.fieldbyindex(index),
way predict whether valid v.fieldbyindex(index)
short execut exact code function does.
rememb context #48215:
type struct {
string
}
type b struct {
*a
}
tmpl := template.must(template.new("").parse(`{{ .s }}`))
// tmpl.execut panic
err := tmpl.execute(io.discard, b{}); err != nil {
t.fatal(err)
}
templat engine' call v.fieldbyindex panic case, misuse.
yes, could look return zero valu fieldbyindex.
adjust panic messag 2014.
surmis believ chang fact panic fear break callers.
sure argument stronger now.
leav ad variant panic.
could cours make variant return zero value, error "no field s", confusing.
return error let us give clearer message: "b embed nil *a".
seem like clear win.
yes, function return error today reflect,
that' api design entir potenti failur due misuse.
combin nil embed struct pointer fieldbyindex _only_ case see non-misus failure.
also preced function error result turn need one.
usual care that.
see interact earli enough.
unchart water two differ way here.
fieldbyindexerr seem like complet reason cours chart unusu situation.
litmu test `reflect` express oper possibl ordinari go code straightforward way, tri simplifi oper _not_ possibl ordinari go code.
ordinari go equival code #48215 someth like (
```go
func TestFieldAccess(t *testing.T) {
	type A struct {
		S string
	}
	type B struct {
		*A
	}
	b := B{}
	fmt.Println(b.S)
}
```
panic-avoid version ordinari go code today would travers (implicit) field individually, check `nil` step:
```go
	b := B{}
	if a := b.A; a != nil {
		fmt.Println(a.S)
	}
```
exactli equival `reflect` code must today, use `reflect.value.isnil` `reflect.value.field` instead `reflect.fieldbyindex` (
variant `.s` oper avoid panic might look like `_, ok` form:
```go
func TestFieldAccess(t *testing.T) {
	type A struct {
		S string
	}
	type B struct {
		*A
	}
	if s, ok := b.S; ok {
		fmt.Println(b.S)
	}
}
```
more-or-less exactli propos `fieldbyindexerr` would implement.
think add panic-avoid shorthand `reflect.value` api (and if!) add correspond panic-avoid shorthand languag proper. otherwise, `reflect`-bas code need travers embed field pointer type use pattern requir ordinari go code.
start believ right respons make function document littl stronger, use recov alreadi written.
good deed goe unpunished.
disagre specif case fieldbyindex. could avoid ad first place, decid incred common merit it, avoid make everyon reinvent it. everyon reinvent fieldbyindexerr too, one way another. address need.
true fieldbyindex special. realli special (and common).
base discuss above, propos seem like **like accept**.
â€” rsc propos review group
chang consensus, **accepted**. ðŸŽ‰
