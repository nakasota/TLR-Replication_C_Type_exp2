cmd/go: cach tool output tool print stdout/stderr
# **update, oct 7 2020**: see recent propos issue.
### version go use (`go version`)?
tip (2e5c32518ce6facc507862f4156d4e6ac776754f), also go 1.11
### issu reproduc latest release?
ye
### oper system processor architectur use (`go env`)?
darwin/amd64
### do?
```
$ go build -toolexec=/usr/bin/time hello.go
# command-line-arguments
        0.01 real         0.00 user         0.00 sys
# command-line-arguments
        0.12 real         0.11 user         0.02 sys
$ go build hello.go 
# command-line-arguments
        0.01 real         0.00 user         0.00 sys
# command-line-arguments
        0.12 real         0.11 user         0.02 sys
$
```
### expect see?
second invoc `go build` `-toolexec`, invok toolexec command (which think doesn't), reprint output.
### see instead?
toolexec output reprinted.
fact, think probabl cach `-toolexec` specified, sinc extern command toolexec invok may anything, (intentionally) reproducible.
cc @dr2chase
use cook command "wrap" =
```
#!/bin/bash
echo -n `basename "$1"` 1>&2 ; /usr/bin/time "$@"
date 1>&2 
```
keep reprint date+time. definit cach output.
```
go build -toolexec wrap .
go build .
rm hello
go build .
```
#27207 `-exec prevent test caching`. mayb need holist review -exec, -toolexec, friends, relat caching.
sure whether cach result `-toolexec` (see *do*, valu `-toolexec` flag includ cach key.
there' definit problem either way: need decid whether fix updat cach key exclud result caching.
actual think right choices. plausibl use `-toolexec` invok debugg interact program, case never cach `-toolexec` used. plausibl use `-toolexec` invok logger build annotator, complet ignor `-toolexec` argument cach purposes. can't think import use case want cach base whether use `-toolexec` option before.
would probabl pick "never cach `-toolexec` used" feel strongli it.
> would probabl pick "never cach -toolexec used"
vote this.
look like consensus. (move `needsdecision` `needsfix`.)
agre bug need fix one way another. way find `-toolexec` use right like `-a -toolexec=whatever`.
thought caching, though. unfortun simpli throw cach window, entir reason toolexec program determinist given input.
way `go build` handl cach properli `go tool compile` seem first ask `compil -v=full`, use part cach key. mean compil oper need re-do compil version changes, otherwise.
could `-toolexec` opt-in? example, one `go build -toolexec=mytool`, go tool would run well defin version flag like `mytool -toolversion`, similar compiler' `-v=full`. fails, cach `-toolexec=mytool`. succeeds, output ad cach key, cach take place.
think best worlds, current non-determinist toolexec program would continu use cach all, go-specif complex tool could take advantag build cache.
would defin bare minimum inform `-toolversion` report, though. example, would stringifi enough, available? perhap hash file content
think comment bit more, think issu still fix simpli cach `-toolexec` used. would strictli better right now.
issu fixed, file "opt-in cach `-toolexec`" idea separ proposal.
go mark propos sinc answer unclear bound #41145. mayb merged.
think answer clear here; default behavior `-toolexec` use build cach all. see #41145 extens behavior, allow opt use build cach properly.
term implementation, want issu implemented, could implement together. think issu need proposal, far tell there' consensu need done.
turn build cach `-toolexec` *is* possible, simpli alter output `[...]/compil -v=full` `[...]/link -v=full`. see follow comments.
bring forward dilemma. propos accept implemented, abil use go build cach method break, `-toolexec` simpli disabl build cach entirely.
problem still `-toolexec` know whether given determinist tool cached, interactive/chang tool entir disabl cache.
here' suggest idea: make wrapper not-to-be-cach tool like `time`, call `-v=full` return random version, mean never cached. would quickli fill build cach though, perhap could take shortcut make `-v=full` return non-zero exit statu print nothing, cach take place.
use wrapper seem complicated. command like `time` `gdb` need understand arguments. go wrapper, need pars arguments.
however, command like `time` `gdb` extra output ask -v=full output. mayb extra output signal go command cache? ideal: imagin command record thing file extra output.
agre use wrapper seem complicated, seem like simplest answer point view toolchain.
use extra output signal "no caching" probabl worst option all, solut use extra output add extra hashes/input cach key.
say `-v=full` perfect, russ suggest thread, take less supported. would unfortun fix issu break mean need reopen proposal.
still think -toolexec complet orthogon cache. time want forc tool run (a extrem case, -a), handl independ whether -toolexec used.
read last comment number times, troubl understand it, sorry.
mean one abl use `-toolexec` without build build cache, agree, rais propos add knob. mean someth else, lost :)
mean use build cach _completely_ separ -toolexec.
two oper independ other, today.
neither know anyth other. stay way.
problem want avoid certain entri build cach certain times,
that' gener problem, limit -toolexec, solut involv -toolexec.
want cache, current -a.
that' big hammer, let' address separ -toolexec.
fair enough, agre need make toolexec.
> want cache, current -a.
think that' quit right, though. `-a` disabl cache, mere forc rebuilding, still write cache. result unintend behavior one want truli use cach all, sinc still write cach - example:
```
$ cd tools # golang.org/x/tools
$ go build -a -toolexec=time ./cmd/stringer
[...]
# golang.org/x/tools/cmd/stringer
0.23user 0.04system 0:00.17elapsed 160%CPU (0avgtext+0avgdata 75048maxresident)k
0inputs+0outputs (0major+14062minor)pagefaults 0swaps
$ go build ./cmd/stringer
[...]
# golang.org/x/tools/cmd/stringer
0.23user 0.04system 0:00.17elapsed 160%CPU (0avgtext+0avgdata 75048maxresident)k
0inputs+0outputs (0major+14062minor)pagefaults 0swaps
```
stdout/stderr tool compil linker also cached, written cach entri `-toolexec=time` effect. way get rid rebuild without toolexec, like `go build -a ./cmd/stringer`. `-a` quit disabl build cach use way.
see, thanks. got issu mix head one (#41145).
@mvdan, wrote:
> think answer clear here; default behavior -toolexec use build cach all.
disagre answer clear. mayb clear one exampl -toolexec=time, that' -toolexec for.
ad -toolexec specif toolstash. use -toolexec toolstash definit _do_ want cach results: substitut altern compil disabl caching?
build cach came -toolexec, design explicitli contempl -toolexec take care preserv good perform -toolexec toolstash. see `go doc -u cmd/go/internal/work.toolid`. accid lightli discarded.
design -toolexec directli intend -toolexec=tim -toolexec=gdb. accid - mostli happi one, accid nonetheless. fact -toolexec=tim fell natur design mean forc awkward chang design.
far propos issue' current titl - "do cach tool output use -toolexec" - believ that' right decision.
one possibl way address -toolexec=tim would add new -cachewrite=fals flag allow read build cach disabl write it. run -toolexec=tim -cachewrite=false. easi forget, though. also, exist flag would encourag think cach someth manual managed, disturb quit bit. cach need manag hand get semant correct behavior actual cache.
counter-proposal: **ani time command print stdout stderr, result cached.**
common time tool print stdout/stderr failures, alreadi cach non-zero exit status. new rule would gener that: print cannot cached.
first seem bit surpris tie tool behavior expect, turn would remov bunch special case code introduc sinc build cach first added.
origin build cach save stdout/stderr - seem necessary.
one unintend effect -toolexec=tim pollut futur build output cach time prints.
`go build -gcflags=-m errors` reprint -m output second run (#22587).
fix cl 77110 cach reprint stdout/stderr too.
still miss stdout/stderr certain skip compile+link step (#23877).
fix cl 128903 even special logic.
`go build -toolexec=time` print time output without -toolexec,
kind opposit `-gcflags=-m` issue.
(there probabl issu forgetting.)
instead continu finess exact behavior stdout/stderr cach not,
turn back clock re-fix #22587 saying:
"don't cach build artifact command print anything".
#22587 fixed, #23877 happen, issu happen either,
-toolexec stay independ cach decision, -toolexec=toolstash stay fast.
would let us delet output-handl code build cach (the test cach separ would stay).
thoughts?
fine counter-proposal. almost time want compil print someth (use toolexec not), expect actual invok compiler.
> disagre answer clear.
record, chang mind sinc then, entir reason retract proposal. yes, agre comment.
fine counter-propos too. tool wrap compil linker chang behavior, alter output `-v=full` propag build cache, otherwis print anyth extra stdout/stderr. noth would break me.
like counter-propos also.
rooki compil develop use add code like compil somewher testing/debug change:
```
  if os.Getenv("ENABLE_EXPERIMENTAL_FOOBAR") {
     fmt.Fprintf("enabling the experimental foobar!\n")
     <do something that causes the compiler to emit different code or DWARF>
  }
```
sinc new environ variabl visibl build cach machinery, caus end trouble. sinc move away entir (i use explicit command line flags, make sure add new flag recordflags() call gc' main). counter-propos would make process littl easier; make sure "experimental" code trace output.
retitl includ propos minut new title, seem head like accept.
(crosslink) #41973 exampl fix this.
base discuss above, seem like **like accept**.
case anyon want start work soon, head write `testdata/script/toolexec.txt` #15677, could reus issu later too.
chang consensus, accepted.
turn also affect `cmd/go.testscript/toolexec` `cmd/go.testscript/vet`.
`vet` test expect `go vet` silent packag `vet` errors, `toolexec` test end rebuild share packag standard librari (e.g. otherwis stale; see #46347), output pollut `vet` test.
seen thing printout previou run _godebug=gctrace=1_, printed, even start without environ variable, later (pleas see better explanation).
related?
chang mention issue: `cmd/go: cach compil linker output`
