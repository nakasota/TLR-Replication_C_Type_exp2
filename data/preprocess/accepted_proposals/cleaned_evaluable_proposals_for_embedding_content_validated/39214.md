testing: add cpu name standard benchmark label
current `goarch` `goos` print bechmark labels.
propos suggest add cpu name `cpu` label label print top benchmark output.
happen `internal/cpu` abl detect cpu type otherwis `cpu` label printed.
exampl prototyp
```
goos: darwin
goarch: amd64
pkg: strconv
cpu: Intel(R) Core(TM) i7-3520M CPU @ 2.90GHz
BenchmarkAtof64Decimal-4        	24431032	        46.8 ns/op
```
option disabled/en cpu featur could print addition:
`features: aesni, avx, sse41` ...
help understand, reproduc document benchmark result better context differ system configurations.
commit messag benchmark made go contributor alreadi contain information, ad manually:









....
relat proposal:
also print inform memori disk models/speeds? imagin greatli depend bottleneck benchmark is.
would leav cpu inform common factor mani microbenchmarks. also identifi system benchmark on, help examin log benchmark later.
agree; think outloud anything. could mani factor play too, kernel version special boot option use (such intel mitig could slow syscalls).
chang mention issue: `testing: print cpu name benchmarks`
@mvdan agreed. could potenti expand futur flag print even inform (ram, caches, kernel, ...) would leav futur extra separ proposal.
inform could easili ad e.g. go env command inform bug report consid helpful.
gather benchmark multipl machin differ cpu late comparison reaction posted/emoji seem positive. anyon object ad go1.16?
seem ok. know procur inform wide enough varieti architectur oper systems?
> seem ok. know procur inform wide enough varieti architectur oper systems?
linux: `cat /proc/cpuinfo`
mac: `sysctl -n machdep.cpu.brand_string`
windows: `wmic cpu get`
oper system 386 amd64 use cpuid instruct (see get cpu name.
gener linux architectur `/proc/cpuinfo` read.
arm oper system anoth (more indirect) univers approach read model vendor id cpu instruct map common architectur name common cpu (e.g. cortex-a55, cortex-a77 ...).
ppc64x, reli os. currently, expos hardwar cpu id userspace. linux, get `/proc/cpuinfo` directli auxiliari vector (via `at_platform` variabl â€” see `ld_show_auxv=1`)
@ceseo thank point out.
work ammend protoyp patch linux cpu architectur use at_platform aux vector. alreadi use mechan get hwcap bit at_hwcap auxillari vector. seem could also work bsds.
@martisch pleas bear mind that, want add processor capabl futur (vsx, etc), read `at_hwcap` `at_hwcap2` ppc64x.
@ceseo alreadi use ppc64x identifi processor capabilities:


test bit around at_platform mostli use print along line `x86_64`, `aarch64` similar.
pars `/proc/cpuinfo` cover linux base combin unfortun complex first glanc might suggest. everi architectur linux format store specifi cpu name differ name fields.
*bsd seem get inform use sysctl call alreadi implement runtime. howev test differ across architectur *bsd may need implement sysctlbynam call first mib static.
first iter seem could cover x86, amd64 linux leav support initially:
```
aix/ppc64
darwin/arm64
freebsd/arm
freebsd/arm64
js/wasm
netbsd/arm
netbsd/arm64
openbsd/arm
openbsd/arm64
plan9/arm
windows/arm
```
sound like command auxv get info covered.
one argu this, seem like **like accept**.
chang consensus, accepted.
chang mention issue: `testing: print cpu type label benchmarks`
