cmd/vet: warn use reflect.deepequ == reflect.valu
code think does:
```
func f(x, y reflect.Value) bool {
    return reflect.DeepEqual(x, y)
}
```
compar intern detail two `reflect.value` structs, contents. correct code would `reflect.deepequal(x.interface(), y.interface())`.
see reason ever want use `deepequal` `reflect.value`. henc fals positives.
realli want compar two `reflect.value` (but shouldn't), `==` equival `deepequal`.
seem like easi mistak make (see #43986 ). sure common might be, suspect might common enough warrant check.
minut search github turn instances.
look like confus code, vet check might least point someon right direction:
line 106-110
line 19, 37, ...
one probabl someon hit bug, fix code, left comment it:
line 212-221
anoth exampl (now fixed)
related:
perhap defin pass reflect.valu deepequal, deepequ use directli instead call reflect.valueof it. instead warn broken code make broken.
would work exampl case. sure right behavior for, e.g., struct `reflect.value`-typ field.
agre appli reflect.value-typ fields, vet go catch either.
histori fmt.print interpret reflect.valu use contains.
case reflect.value:
// handl extract valu special method
// sinc printvalu handl depth 0.
f.isvalid() && f.caninterface() {
p.arg = f.interface()
p.handlemethods(verb) {
return
}
}
p.printvalue(f, verb, 0)
@ianlancetaylor say ran recent due go 1.16 intern chang clear given call (like keith' exampl top) even problem. either vet chang "make work" change.
lean toward "make work".
propos ad activ column propos project
review weekli propos review meetings.
â€” rsc propos review group
anyon object make deepequ handl reflect.valu argument interpret valu represent?
(that is, would avoid call reflect.valueof argument proceed before.)
> avoid call reflect.valueof
typo? avoid call `.interface()`?
appli `reflect.value` valu interfac underli values?
underli valu underli interfac valu also `reflect.value` values,
...
> > avoid call reflect.valueof
>
> typo? avoid call .interface()?
typo. current code
```Go
    v1 := ValueOf(x)
    v2 := ValueOf(y)
```
suggest chang someth like
```Go
    var v1, v2 Value
    xv, xok := x.(Value)
    yv, yok := y.(Value)
    if xok && yok {
        v1 = xv
        v2 = xv
    } else {
        v1 = ValueOf(x)
        v2 = ValueOf(y)
    }
--- Comment #13 by ianlancetaylor ---
> Does it apply to reflect.Value values with interfaces as underlying values?
No.
> And what about the underlying values of the underlying interface values are also reflect.Value values,
No.
> And ...
No.
--- Comment #14 by zigo101 ---
OK, I misinterpreted it affects user code. It affects std lib code actually.
But is it required both of the arguments are `Value`? Should it be like
```
var v1, v2 valu
xv, xok := x.(value); xok {
v1 = xv
} els {
v1 = valueof(x)
}
yv, yok := y.(value); yok {
v2 = yv
} els {
v2 = valueof(y)
}
```
--- Comment #15 by ianlancetaylor ---
Good question.
--- Comment #16 by bcmills ---
IMO `reflect.Value` should be treated as analogous to a pointer type. We treat `&x` as semantically different from `x`,[Â¹](https://play.golang.org/p/cPgs5BJdmb0) so we should also treat `reflect.ValueOf(x)` as semantically different from `x` itself.
--- Comment #17 by liggitt ---
> @ianlancetaylor says he ran into this recently due to a Go 1.16 internal change
Yeah, we just hit this as well with the following code in a validation library that was attempting to check zero value:
```
reflect.deepequal(reflect.zero(reflect.typeof(data)), reflect.valueof(data))
```
As it turns out, what it intended to do with a zero-value condition was incorrect, but the incorrect branch was never triggered before.
We'll deal with fixing that issue in that particular library, but is it acceptable that the following code has a different result in go1.16 than it did in all prior go versions?
```go
func main() {
data := ""
fmt.println(reflect.deepequal(reflect.zero(reflect.typeof(data)), reflect.valueof(data)))
}
```
Looks like https://go-review.googlesource.com/c/go/+/192331 was likely the relevant change
--- Comment #18 by randall77 ---
@liggitt 
Yes, it is unfortunate that it changed in 1.16 but the code is relying on an implementation detail of `reflect.Value`.
Kind of like `&struct{} == &struct{}`, it all depends on whether the implementation dedups two zero values into identical `reflect.Value`s, or just two equivalent ones.
> // To compare two Values, compare the results of the Interface method.
> // Using == on two Values does not compare the underlying values
> // they represent.
`==` is the same as `DeepEqual` in this situation (which is what this issue is proposing changing).
--- Comment #19 by liggitt ---
Still probably worth a mention in the 1.16 release notes, since the externally visible behavior of reflect.Zero changed. Highlighting problematic comparisons of reflect.Values that would be affected would have prompted us to audit for that.
--- Comment #20 by randall77 ---
> Still probably worth a mention in the 1.16 release notes, since the externally visible behavior of reflect.Zero changed. 
It's only visible because of violations of `reflect.Value`'s contract. Not sure what you'd put in the release notes about that. Have a suggestion?
> Highlighting problematic comparisons of reflect.Values that would be affected would have prompted us to audit for that.
This issue (and #18871) was originally about highlighting problematic comparisons, hopefully more robustly than a release note would. i think we'll just end up fixing the behavior to do the right thing instead.
--- Comment #21 by liggitt ---
> It's only visible because of violations of `reflect.Value`'s contract. Not sure what you'd put in the release notes about that. Have a suggestion?
Something like what was described in https://golang.org/doc/go1.10#reflect, describing the change made to the reflect package and describing potential impact for callers relying on incorrect or unspecified behavior. Perhaps something like:
> The `Zero` function has been optimized to avoid allocations in many scenarios. Code which incorrectly compares the returned `Value` to another `Value` item using `==` or `DeepEqual` can now evaluate to `true`, where previous versions of `go` always evaluated to `false`. To compare two `Values`, compare the results of the `Interface` method. Using `==` or `DeepEqual` on two `Values` does not compare the underlying values they represent.
--- Comment #22 by gopherbot ---
Change https://golang.org/cl/300992 mentions this issue: `[release-branch.go1.16] doc: describe how Zero optimization might change results of incorrect reflect.Value comparison`
--- Comment #23 by gopherbot ---
Change https://golang.org/cl/302269 mentions this issue: `doc: describe how Zero optimization might change results of incorrect reflect.Value comparison`
--- Comment #24 by rsc ---
Given that everyone on Go 1.16 is already broken and we're not hearing a big uproar, it seems like a vet check and keeping the ValueOf semantics simpler is a better path forward.
--- Comment #25 by rsc ---
Based on the discussion above, this proposal seems like a **[likely accept](https://golang.org/s/proposal-status#likely-accept)**.
â€” rsc for the proposal review group
--- Comment #26 by randall77 ---
What about also flagging use of `==` on `reflect.Value`s? That would fix #18871 but avoid the main objection there, which was use of `reflect.Value` as a map key for sets of `reflect.Value`s.
We'd have to allow comparing to the zero `Value` (aka `reflect.Value{}`) as [Dominik noted](https://github.com/golang/go/issues/18871#issuecomment-277027019).
--- Comment #27 by rsc ---
It seems OK to put the == check in as well, with an exception for reflect.Value{}.
If it breaks too much, we can always back it out.
Will leave this in likely accept for another week.
--- Comment #28 by rsc ---
No change in consensus, so **[accepted](https://golang.org/s/proposal-status#accepted)**. ðŸŽ‰
