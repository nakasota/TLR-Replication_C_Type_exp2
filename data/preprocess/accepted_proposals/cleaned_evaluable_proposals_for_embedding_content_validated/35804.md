database/sql: add error getter sql.row
<!-- pleas answer question submit issue. thanks! -->
### version go use (`go version`)?

$ go version
go version go1.13.4 linux/amd64

small featur request.

moment `queryrow()` variant return row, mention comments, easi chaining. make bit inconveni program `queryrow()` one want check error return row as-i higher level caller. instance, usecas would like wrap `queryrow()` go routin multipl host return first success result.
would possibl **error getter method** (eg. `row.err()`) `sql.row` type? way "chaining" still possible, give also control error check mechanism.
**edit:** forgot mention will implement pr myself.
hi @muhlemmer, could provid code exampl chain api chang would improve?
/cc @bradfitz @kardiano
> hi @muhlemmer, could provid code exampl chain api chang would improve?
exampl 1:
````
// Node represents a database server connection
type Node struct {
	db             *sql.DB
        // other stuff that keeps track of Node health statistics and re-connection parameters.
}
// CheckErr checks for "serious" errors, like connection and database consistency.
// For example: lib/pq has predefined error codes which can be checked.
// Serious errors are counted as failures.
// If a the configured failure trashhold is reached, this node will we disconnected.
func (n *Node) CheckErr(err error) error {
    // Call helper methods for checking and decision making
    return err  //return the original error
}
// QueryRowContext wrapper around sql.DB.QueryRow.
// Implements boil.ContextExecutor
func (n *Node) QueryRowContext(ctx context.Context, query string, args ...interface{}) *sql.Row {
        row, err := n.DB().QueryRowContext(ctx, query, args...)
	return rows, n.CheckErr(row.Err()) // <--- This is what I would like to do
}
````
exampl 2 extend exampl 1:
````
// MultiNode holds a slice of Nodes.
// All methods on this type run their sql.DB variant in one Go routine per Node.
type MultiNode []*Node
// QueryRowContext runs sql.DB.QueryRowContext on the Nodes in seperate Go routines.
// The first non-error result is returned immediatly.
// Errors from remaining Nodes will not be returned,
// just logged for stastics and descison making.
//
// The following errors can be returned:
// - If all nodes respond with the same error, that exact error is returned as-is.
// - If there is a variaty of errors, they will be embedded in a MultiError return.
//
// Implements boil.ContextExecutor.
func (mn MultiNode) QueryRowContext(ctx context.Context, query string, args ...interface{}) (*sql.Row, error) {
	rc := make(chan *sql.Row, len(mn))
	for _, n := range mn {
		go func(n *Node) {
			rc <- n.QueryRowContext(ctx, query, args...)
		}(n)
	}
	var me MultiError
	for i := 0; i < len(mn); i++ {
		row := <-rc
		if err := row.Err(); err == nil { // <-- Same here: this is what I would like to do
			return row, nil
		} else {
			me.append(err)
		}
	}
	return nil, me.check() // Compare errors and return accordingly.
}
````
would like `node` `multinode` interfac compat `sql.db` `sql.tx`. specif interface:
````
// ContextExecutor can perform SQL queries with context
type ContextExecutor interface {
	Executor
	ExecContext(ctx context.Context, query string, args ...interface{}) (sql.Result, error)
	QueryContext(ctx context.Context, query string, args ...interface{}) (*sql.Rows, error)
	QueryRowContext(ctx context.Context, query string, args ...interface{}) *sql.Row
}
````
pass type db tx connet object orm.
ultimately, caller package' object could replace:
````
var int i
err := db.QueryRowContext(ctx, "select $1", 1).Scan(&i)
````
with:
````
var int i
err := nodes.QueryRowContext(ctx, "select $1", 1).Scan(&i)
````
keep chain `database/sql` packag current provides, packag inspect error given moment.
see still `waitingforinfo` tag issue. anyth els would like clarify?
@muhlemm time. thanks.
@kardiano thought this? thanks.
`*row` struct ad new method would fine, ad `err() error` would symmetr `*rows`. see technic reason add it.
benefit would cite ad would allow differenti queri error scan error framework act appropri each.
two strike propos (1) make less conveni method (expand use case rather use *result use cases) (2) tend make differ type abstract present here.
fine ad this.
@kardiano wrote "contin method" mean "conveni method"?
@ianlancetaylor yes, intend write "conveni method" way commentari upon person continence; though given confus two, may shed doubt upon cognizance.
base discussion, seem like **like accept**.
leav open week final comments.
final comments, accepted.
chang mention issue: `database/sql: add error getter sql.row`
