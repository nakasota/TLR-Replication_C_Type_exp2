math/big: rat: add floatprec() (int, bool)
**update, nov 13, 2023**: current api -gri
---
current pars string like `123.34` `setstring()` want print back full precision, one manual pick right precis `floatstring()` function get that. propos instead `floatstring()` accept neg `prec` parameter. full semant `prec` paramet would be:
* posit `prec`, format `prec` digit radix point, pad 0 right necessary. last digit round nearest, halv round away zero, round necessary.
* `prec` 0, digit radix point.
* `prec` less 0, then:
* finit number digit radix point precis repres number, digit append radix point.
* number digit infinite, `abs(prec)` number digit use radix point, round last digit nearest, halv round away zero.
`floatstring(3)` number return `123.340`, `floatstring(-3)` return `123.34`.
`big.newrat(1, 3).floatstring(3)` return `0.333` `big.newrat(1, 3).floatstring(-3)` would return `0.333`.
wrote long complic answer this, perhap better state rather chang floatstr peculiar possibl incompat way, better answer add function tell mani bit precis need. problem simpl answer general, may repeat decimal, function could tell that:
func (r *rat) floatsize() (digitsleftofdecimal, digitsrightofdecim int, repeat bool)
solv problem far convinc problem signific enough requir messi fix, either mine yours. want clever, comput (10 gcd denominator) get answer yourself, sinc infinite-length represent happen factor denomin factor print base.
good point like idea `floatsize`.
> far convinc problem signific enough requir messi fix
messi fix mean neg precis propos `floatsize`?
both. said, "mine yours".
see.
problem marshal unmarsh json larg decim number string use way pars marshal back precis came in. pars fix length string know format back one well (so repeat infinit digits). issu easi way back conversion. hand want lose precis necessary.
`floatsize` would address me.
made implement signatur `func ratprecision(rat *big.rat) (int, int)`, first `int` number non-rep digit decim dot, second number repeat (cycling) digit follow. seem work pretti well, mayb could includ stdlib.
seem like awkward use big.rat. use big.rat case all? use json.numb round-tripp representation?
oh, sorri unclear proposal. roundtrip saniti check motivation, data structur read json number `big.rat` fields, would least like abl gener back origin json ease. current hard. course, main use pars json number info struct `big.rat` field, one would take process struct. potenti later tri save json, point valu might represent without lose precision. fine, would least like abl save json without lose precis necessari (e.g., finit number digits). current possibl use stdlib render `big.rat` number know lose precis (when possible).
care repeat size digit left?
repeat size n/d particular therefor requir big.int represent.
digit left irrelev use floatprec.
finit digit right guarante 10 log d, fit int whenev fit memory.
perhap
func (r *rat) floatprec() (digit int, ok bool)
return 0, fals rat non-finit float representations?
yes, agre digit left important. implement made follow signature:
```
func (r *Rat) FloatPrec() (digits int, repeating int)
```
`repeat == 0` `ok == true`.
mayb implement eleg could be.
would ok `func (r *rat) floatprec() (digit int, ok bool)` well.
practice, use signatur implementation, gener `l+j` number digits, non-rep digit follow one cycl repeat digits.
@mitar problem >2^64 repeat digits.
propos ad activ column propos project
review weekli propos review meetings.
â€” rsc propos review group
> problem >2^64 repeat digits.
sure, caller function would decid limit appli pass digit further. say `int` return valu type enough? think yes, could flag somehow would overflow something.
yes, problem result fit int, even int64.
repeat count realli necessary? would argu not, case
func (r *rat) floatprec() (digit int, ok bool)
fine that.
clarity:
(1/10).floatprec() = 1, true
(10/100).floatprec() = 1, true
(3/100).floatprec() = 2, true
(1/3).floatprec() = 0, fals
(10).floatprec() = 0, true
anyon object floatprec describ
examples:
```
(1/3).FloatPrec() = 0, false
(1/6).FloatPrec() = 1, false
(1/7).FloatPrec() = 0, false
(1/9).FloatPrec() = 0, false
(1/28).FloatPrec() = 2, false
(1/67).FloatPrec() = 0, false
(1/81).FloatPrec() = 0, false
(1/96).FloatPrec() = 5, false
(8/13).FloatPrec() = 0, false
(2/14).FloatPrec() = 0, false
(3/30).FloatPrec() = 1, true
(2/3).FloatPrec() = 0, false
(9/11).FloatPrec() = 0, false
(7/12).FloatPrec() = 2, false
(22/7).FloatPrec() = 0, false
```
disagre examples. bool false, count alway zero.
bool distinguish 0, fals (some infinit eventu repeat decimal)
0, true (an integ digit decim point).
number digit repetit begin may fit int64 (i'm sure)
also seem like use number have. also know comput efficiently.
trivial comput non-rep prefix _and_ guarante fit int64 _and_ useful, mayb could think ad it. none three seem true.
clarification, anyon object ad floatprec
still sure problem worth solv due rariti practice.
origin messag said use case:
> current pars string like 123.34 setstring() want print back full precis
> roundtrip saniti check motivation, data structur read json number big.rat fields, would least like abl gener back origin json ease.
sympathet see aris varieti programs.
fact, bit annoy ivi 0.1 + 0.1 = 1/5 instead 0.2.
would give ivi way print shorter decim that' still precise.
base discuss above, propos seem like **like accept**.
â€” rsc propos review group
chang consensus, **accepted**. ðŸŽ‰
