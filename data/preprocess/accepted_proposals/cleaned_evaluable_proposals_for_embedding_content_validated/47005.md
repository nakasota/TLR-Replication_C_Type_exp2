net/url: add joinpath, url.joinpath
url join often use
unsatisfactori use path.joinï¼š -> http:/www
want add join method url packag
```go
// Join  concatenates baseUrl and the elements
// - check baseUrl format
// - concatenates baseUrl and the elements
func Join(baseUrl string, elem ...string) (result string, err error) {
	url, err := Parse(baseUrl)
	if err != nil {
		return
	}
	if len(elem) > 0 {
		elem = append([]string{url.Path}, elem...)
		url.Path = path.Join(elem...)
	}
	result = url.String()
	return
}
```
unit test
```go
func TestJoin(t *testing.T) {
	type args struct {
		baseUrl string
		elem    []string
	}
	tests := []struct {
		name       string
		args       args
		wantResult string
		wantErr    bool
	}{
		{
			name: "test normal url",
			args: args{
				baseUrl: "https://go.googlesource.com",
				elem:    []string{"go"},
			},
			wantResult: "https://go.googlesource.com/go",
			wantErr:    false,
		},
		{
			name: "test .. parent url",
			args: args{
				baseUrl: "https://go.googlesource.com/a/b/c",
				elem:    []string{"../../../go"},
			},
			wantResult: "https://go.googlesource.com/go",
			wantErr:    false,
		},
		{
			name: "test . cul path",
			args: args{
				baseUrl: "https://go.googlesource.com/",
				elem:    []string{"./go"},
			},
			wantResult: "https://go.googlesource.com/go",
			wantErr:    false,
		},
		{
			name: "test multiple Separator",
			args: args{
				baseUrl: "https://go.googlesource.com//",
				elem:    []string{"/go"},
			},
			wantResult: "https://go.googlesource.com/go",
			wantErr:    false,
		},
		{
			name: "test more elems",
			args: args{
				baseUrl: "https://go.googlesource.com//",
				elem:    []string{"/go", "a", "b", "c"},
			},
			wantResult: "https://go.googlesource.com/go/a/b/c",
			wantErr:    false,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			gotResult, err := Join(tt.args.baseUrl, tt.args.elem...)
			if (err != nil) != tt.wantErr {
				t.Errorf("Join() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if gotResult != tt.wantResult {
				t.Errorf("Join() = %v, want %v", gotResult, tt.wantResult)
			}
		})
	}
}
```
chang mention issue: `net/url: add join method`
actual implement someth like request client library:
think slightli better name `joinpaths` host changing, path.
also propos method url, rather packag level function.
```go
// JoinPaths joins the provided path to any existing Path 
// and cleans the result of any ./ or ../ elements.
func (u *URL) JoinPaths(paths ...string) {
	if len(paths) == 0 { 
		return
	}
	paths = append([]string{url.Path}, paths...)
	url.Path = path.Join(paths...)
	return
}
```
one complication: think quit reason expect path begin / interpret absolut (which url.resolveref does), implement might surpris user either way.
like topic%20function%20is,join%20url%20paths%20in%20go.&text=parse%20parses%20a%20url%20in,is%20the%20same%20as%20resolvereference%20.)
!imag
continu paid attent to. path.join cannot use directly. generally, string type convert url type, error checked, resolverefer path.join, final complet url path output. ordinari users, process repetit
agre probabl worth level, total clear semant user expect. example, use resolverefer standard, get differ results:
```go
func Join(u *url.URL, path string) {
	*u = *u.ResolveReference(&url.URL{Path: path})
}
func main() {
	u, _ := url.Parse("http://example.com")
	fmt.Println(u)
	for _, p := range []string{"a/", "b/", "c", "d", "../e", "/f"} {
		Join(u, p)
		fmt.Println(u)
	}
}
```
results:
```
http://example.com
http://example.com/a/
http://example.com/a/b/
http://example.com/a/b/c
http://example.com/a/b/d
http://example.com/a/e
http://example.com/f
```
yes, use resolverefer inde confuse,
opinion, function url.join similar path.join.
true liter understand
note surpris behavior pythonâ€™ url.parse:
> suppos someon accident creat url web page look like ' (with two slash host instead one) visit it, attempt decod result apach hand you:
>
> >>> urllib.parse.urlparse("//your/page/url")
> parseresult(scheme='', netloc='your', path='/page/url', params='', query='', fragment='')
>
> problem '//ahost.org/some/path' perfectli legal protocol-rel url, that' urllib.pars produc give someth look like one, say someth start '//'.
could problem url.join well. either assum // wrong / assum itâ€™ right could lead surpris behavior depend context.
add this, seem like join restrict manipul path, top stackoverflow answer:
```
u, err := url.Parse("http://foo")
u.Path = path.Join(u.Path, "bar.html")
s := u.String() // prints http://foo/bar.html
```
is, anyth like resolvereference, deal full url syntax second argument. mayb make clear call url.joinpath?
api would be:
```
func JoinPath(baseURL string, elem ...string) (string, error)
func (u *URL) JoinPath(elem ...string) (*URL, error) 
```
right?
propos ad activ column propos project
review weekli propos review meetings.
â€” rsc propos review group
@rsc thank answer
api need return new object url? modifi path directli origin object, two method suitable?
```golang
func (u *URL) JoinPath(elem ...string) (*URL, error) 
```
# 1
```golang
func (u *URL) JoinPath(elem ...string)  *URL{
       url := URL{
             Scheme : u.Scheme
	     Opaque : u.Opaque
	     User   : u.User
	     Host   : u.Host
	     Path       : u.Path
	     RawPath     : u.RawPath
	     ForceQuery  : u.ForceQuery
	     RawQuery     : u.RawQuery
	     Fragment    : u.Fragment
	     RawFragment  : u.RawFragment
        }
	if len(elem) > 0 {
		elem = append([]string{u.Path}, elem...)
		url.Path = path.Join(elem...)
	}
      return  &url
}
func JoinPath(baseUrl string, elem ...string) (result string, err error) {
	url, err := Parse(baseUrl)
	if err != nil {
		return
	}
       urlAfterJoin := url.JoinPath(elem...)
	result = urlAfterJoin.String()
	return
}
```
# 2
```golang
func (u *URL) JoinPath(elem ...string) {
	if len(elem) > 0 {
		elem = append([]string{u.Path}, elem...)
		u.Path = path.Join(elem...)
	}
}
func JoinPath(baseUrl string, elem ...string) (result string, err error) {
	url, err := Parse(baseUrl)
	if err != nil {
		return
	}
	url.JoinPath(elem...)
	result = url.String()
	return
}
```
believ method url today modifi receiv (except unmarshal).
seem like mistak start.
especi sinc path.join return new thing rather modifi anything.
object api
@rsc hi, iâ€™m sure realli understand mean, resubmit code, pleas help review again, thank
cleaner implementation, sure packag url import path without caus depend cycl somewhere:
```go
func (u *URL) JoinPath(elem ...string)  *URL{
	u2 := *u
	if len(elem) > 0 {
		elem = append([]string{u.Path}, elem...)
		u2.Path = path.Join(elem...)
	}
      return  &u2
}
func JoinPath(baseUrl string, elem ...string) (result string, err error) {
	u, err := Parse(baseUrl)
	if err != nil {
		return
	}
	return u.JoinPath(elem...).String()
}
```
ok net/url import path. path definit import url.
base discuss above, propos seem like **like accept**.
â€” rsc propos review group
chang consensus, **accepted**. ðŸŽ‰
