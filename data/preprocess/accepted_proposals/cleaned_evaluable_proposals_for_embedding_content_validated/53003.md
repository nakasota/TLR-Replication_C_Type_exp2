unsafe: add stringdata, string, slicedata
`reflect.stringheader` `reflect.sliceheader` offici deprecated, think time revisit ad function satisfi reason peopl use types. afaict, reason deprec `reflect.sliceheader` `reflect.stringheader` commonli misused. well, type _always_ document unstabl reli upon.
see github code search usag type ubiquitous. common use case seen are:
- convert `[]byte` `string`
- convert `string` `[]byte`
- grab `data` pointer field ffi nich use
- convert slice one type slice anoth type
first use case also commonli seen `*(*string)(unsafe.pointer(&myslice))`, never actual offici document anywher someth reli upon. hood, shape string less slice, seem valid per unsaf rule (1), reli undocu behavior. second use case commonli seen `*(*[]byte)(unsafe.pointer(&string))`, by-default broken cap field past end page boundari (exampl here, wide use code) -- violat unsaf rule (1).
regardless thought peopl never reli upon types, peopl do, over. peopl also reli _invalid_ convers go never made easy. part discuss #19367 way peopl misus type today. convers small trick allevi memori pressur improv latenc cpu usag real programs. use case real, go provid enough unsaf buggi way work around problem larg ecosystem technic invalid code happen work.
rather consist say "don't use this", `go vet` _somewhat_, duck respons buggi programs, go provid actual safe(ish) api peopl reli perpetuity. new function live `unsafe` well document rule around use cases, go final document peopl want common escap hatch.
# concret propos
follow api unsaf package:
```
// StringToBytes returns s as a byte slice by performing a non-copying type conversion.
// Slices returned from this function cannot be modified.
func StringToBytes(s string) []byte
// BytesToString returns b as a string by performing a non-copying type conversion.
// The input bytes to this function cannot be modified while any string returned from
// this function is alive.
func BytesToString(b []byte) string
```
~`func datapointer[t ~string|~[]e, e any](t t) unsafe.pointer`~ eliminating, realist person `&slice[0]` (although correspond analogu exist strings)
think `unsafe.slice` cover use case convert slice differ types, although 100% sure use case `unsafe.slice` is.
thanks, see actual propos here. want discuss ideas, pleas use golang-nuts. propos process proposal. is, suggest specif function introduce. thanks.
sure, good point. edit comment actual propos ~three~two new functions. think `unsafe.slice` cover fourth common use case mention above, 100% sure.
one main use case `unsafe.slice` creat slice whose back array memori buffer return c code call `syscall.mmap`. agre use (unsafely) convert slice one type slice differ type.
cc @mdempski
> call `syscall.mmap`
mmap'd slice standard lib would huge win (pun intended). concret propos refer address string -- get mmap part too?
@paulstuart sure exactli asking, sound like differ issue. note code alreadi call `syscall.mmap` `unsafe.slice` creat slice back mmap' memory.
file #53079. perhap undeprec go 1.19, sinc replac valid use case yet. thanks.
propos ad activ column propos project
review weekli propos review meetings.
â€” rsc propos review group
fwiw, propos function close parallel `ofstring` `asstring` function `unsafeslice` package.
packag also provid best-effort mutat detection, sinc go `string` variabl suppos immut go program may gener assum variabl pass type `string` never mutat garbage-collected.
seen package, one thing mutat detect (which gate behind `unsafe` build tag). expect mutat detect automat done test / built `-race`, automat appli releases. use unsaf package, :).
think link packag origin writeup, sinc evid use case.
least, think import document propos function explicitli call lifetim issues, especi `bytestostring` â€” `string` use map key caus arbitrari memori corrupt mutat map still live.
fulli replac `reflect.stringheader` `reflect.sliceheader`, let' consid permit us do. use read and/or modifi content string slice.
reading, alreadi extract element slice, via `&s[0]`, `len(s)`, `cap(s)`. get length string via `len(s)`, can't get pointer data.
writing, creat new slice set elements, via `unsafe.slice` follow slice expression. can't creat new string.
suggests, packag unsafe,
```Go
// StringData returns a pointer to the bytes of a string.
// The bytes must not be modified; doing so can cause
// the program to crash or behave unpredictably.
func StringData(string) *byte
// String constructs a string value from a pointer and a length.
// The bytes passed to String must not be modified;
// doing so can cause the program to crash or behave unpredictably.
func String(*byte, int) string
```
function remain meaning even somehow chang represent slice string future.
restrict chang byte unfortunate, fact peopl kind transform today. omit function unsaf packag mean go program them, mean way sometim even less safe.
feasibl add dynam detector modif bytes. could perhap enabl use race detector. would perfect would detect egregi misuses.
function suggest would written
```Go
func StringToBytes(s string) []byte {
    return unsafe.Slice(unsafe.StringData(s), len(s))
}
func BytesToString(b []byte) string {
    return unsafe.String(&b[0], len(b))
}
```
(to clear, revers also possible: write `string` `stringdata` term `stringtobytes` `bytestostring`.)
seem like unsafe.str unsafe.stringdata match unsafe.slic bit better fundament oper
provid stringtobyt bytestostr primitives.
wonder add unsafe.slicedata well (code often work around len 0 use &s[0]).
like suggest reconsid origin propos #19367: add new `unsafe.stringheader` `unsafe.sliceheader` types, handl remain advanc use case support `reflect.{string,slice}header` cover `unsafe.slice`.
concretely, propos adding:
```
package unsafe
type StringHeader struct {
    Data *byte
    Len int
}
type SliceHeader[Elem any] struct {
    Data *Elem
    Len, Cap int
}
```
allow convers `string` `unsafe.stringheader`, also `[]elem` `unsafe.sliceheader[elem]`.
convert invalid `unsafe.{string,slice}header` (e.g., len > cap, data==nil len>0) normal string slice type fail, least `-d=checkptr` mode. lean toward make run-tim panic (like `unsafe.slice`) failur condit easi specify/detect, simpli leav undefin (like `unsafe.add`) seem unreason too.
n.b., origin #19367 propos also allow convers `*string` `*unsafe.stringheader`, etc. think could still allow (e.g., particularli help user transit away `reflect.{string,slice}header`), think less error-pron (and margin better escap analysis) encourag user construct `unsafe.stringheader`, valu convert `string`, store memory; rather creat `*unsafe.stringheader` individu assign field memory.
concern `stringheader` `sliceheader` lock possibl implement either use exact header strang contort compiler.
`stringheader` `sliceheader` can't `slice`, `slicedata`, `string`, `stringdata`?
think more, inclin agre `{slice,string}{,data}` builtin function way go. say, support functionality. think easier tool author extend convers semant too.
sound like converg consid unsafe.stringdata, unsafe.string, unsafe.slicedata.
anyon object those?
base discuss above, propos seem like **like accept**.
â€” rsc propos review group
chang consensus, **accepted**. ðŸŽ‰
