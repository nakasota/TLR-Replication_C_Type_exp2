encoding/csv: add abil get line number record
issu close nich feature, actual quit common need information.
example, record read, syntax field might checked, could invalid. case, use abl produc good error messag points, least roughly, problem is. csv file million line long, important.
workaround propos awkward implement (it' easi get `io.reader` implement wrong) work current anyway. current altern wrap underli reader reader count line read line time, awkward implement, introduc second unecessari layer buffer slow thing down.
`csv.reader` alreadi keep track line numbers, provid inform api seem natural.
propos new method:
```
// Line returns the line number of the start of the most
// recently returned record. If no records have been returned,
// it returns zero.
func (r *Reader) Line() int
```
there' straw-man implement here.
thank @mvdan consult issue.
propos
// line return line number start
// recent return record. record returned,
// return zero.
func (r *reader) line() int
`line` alreadi defin
// parseerror return pars errors.
// line number 1-index column 0-indexed.
type parseerror struct {
startlin int // line record starts; ad go 1.10
line int // line error occur
column int // column (rune index) error occur
err error // actual error
}
seem use `line` refer `startline`. that' confusing. renam method `startline`.
straw-person implement reflect confusion.
// line return line number start
// recent return record. record returned,
// return zero.
func (r *reader) line() int {
return r.startlin
}
method document precise. add index inform `parseerror` documentation.
revis method
// startlin return line number start
// recent return record. record returned,
// return zero.
// startlin number 1-indexed.
func (r *reader) startline() int
actual suggest renam `startline` method `line`, sinc otherwis seem like line number start entir csv document instead current record.
@mvdan said, initi version propos use `startline` rather `line`. easi either way tbh. votes?
mayb
// po return posit recent read record.
func (r *reader) pos() (startline, endlin int)
seem like want one might want both?
propos ad activ column propos project
review weekli propos review meetings.
â€” rsc propos review group
never seen requir find last line particular.
_would_ use howev would abil find line column given field current line. sure: csv encod reversible? so, mayb would possibl determin given current line number current field values, could provid last line number natur consequence.
even need endlin normally, po return make clear might different, could useful.
could even call lastpo instead pos.
could also save column info field easili enough. tini amount data would reused.
api would want return per-field info?
someth like this?
```
// FieldPos returns the line and column corresponding to
// the field with the given index in the entry most recently
// returned by Read. Numbering of lines and columns starts at 1.
//
// If this is called with an out-of-bounds index, it panics.
func (r *Reader) FieldPos(index int) (line, column int)
```
equival origin `line` method obtain
call `fieldpos(0)`.
@rogpeppe, confirm api suggest previou comment implementable?
assum is, sound good.
anyon object fieldpo api?
pretti sure implementable. main concern would whether implement ad neglig runtim overhead.
occur point past week reader need []int reus across decoding. can't possibl much overhead.
> occur point past week reader need []int reus across decod
need slice (line, column) pairs? still much overhead, might non-neglig some.
guess line number rel line number start line, need worri line part overflow 32 bit int.
base discuss above, propos seem like **like accept**.
â€” rsc propos review group
one question here: correct unit use column: byte runes? current error count column runes, counter-example, go compiler' posit count column bytes. count byte cheaper easier, inclin except current document export semant `column` field `parseerror` type.
would _too_ bad `fieldpos` return column byte offset, inconsist column `parseerror` ?
write code calcul rune offset lazili `fieldpos` call avoid overhead calcul fly, pain properly, especi presenc `trimleadingspace` trim unicod charact end result field data.
rune pointless; pleas bytes. :-)
think chang exist behaviour column `parseerror` ?
quick scan go corpu spring 2020. found zero use column field, think safe change.
found test check ascii inputs.
found implement set column csv.parseerrors:
- biogo think column integ field number, rune offset.
- dolt set column correctli rune index, zero use field.
made chang think would easi approach biogo dolt folk get implement fixed.
here' actual instances:
correctli comput rune-bas column (would affected)
```
github.com/dolthub/dolt/go@v0.0.0-20200327004621-c4414210ff5e/libraries/doltcore/table/untyped/csv/reader.go:385:				err = &csv.ParseError{StartLine: recordStartLine, Line: csvr.numLine, Column: col, Err: csv.ErrQuote}
github.com/dolthub/dolt/go@v0.0.0-20200327004621-c4414210ff5e/libraries/doltcore/table/untyped/csv/reader.go:403:				err = &csv.ParseError{StartLine: recordStartLine, Line: csvr.numLine, Column: col, Err: csv.ErrQuote}
```
test check column ascii only, implement wrap encoding/csv (would unaffected):
```
github.com/mzimmerman/multicorecsv@v0.0.0-20160707020140-e722d0bc1822/multicorecsv_test.go:306:			} else if tt.Line != 0 && (tt.Line != perr.Line || tt.Column != perr.Column) {
```
hard-cod column: 1 (unaffected):
```
github.com/jszwec/csvutil@v1.2.3/csvutil_go110_test.go:10:var testUnmarshalInvalidFirstLineErr = &csv.ParseError{
github.com/jszwec/csvutil@v1.2.3/csvutil_go110_test.go:17:var testUnmarshalInvalidSecondLineErr = &csv.ParseError{
github.com/jszwec/csvutil@v1.2.3/csvutil_go17_test.go:7:var testUnmarshalInvalidFirstLineErr = &csv.ParseError{
github.com/jszwec/csvutil@v1.2.3/csvutil_go17_test.go:13:var testUnmarshalInvalidSecondLineErr = &csv.ParseError{
```
think column csv field index (unaffected):
```
github.com/biogo/biogo@v1.0.2/io/featio/bed/bed.go:100:		panic(&csv.ParseError{Column: column, Err: err})
github.com/biogo/biogo@v1.0.2/io/featio/bed/bed.go:108:		panic(&csv.ParseError{Column: column, Err: err})
github.com/biogo/biogo@v1.0.2/io/featio/bed/bed.go:126:		panic(&csv.ParseError{Column: index, Err: ErrBadStrandField})
github.com/biogo/biogo@v1.0.2/io/featio/bed/bed.go:130:		panic(&csv.ParseError{Column: index, Err: ErrBadStrand})
github.com/biogo/biogo@v1.0.2/io/featio/bed/bed.go:142:		panic(&csv.ParseError{Column: index, Err: ErrBadColorField})
github.com/biogo/biogo@v1.0.2/io/featio/bed/bed.go:402:		if err, ok := err.(*csv.ParseError); ok {
github.com/biogo/biogo@v1.0.2/io/featio/gff/gff.go:241:		panic(&csv.ParseError{Line: line, Column: index, Err: err})
github.com/biogo/biogo@v1.0.2/io/featio/gff/gff.go:252:		panic(&csv.ParseError{Line: line, Column: index, Err: err})
github.com/biogo/biogo@v1.0.2/io/featio/gff/gff.go:263:		panic(&csv.ParseError{Line: line, Column: index, Err: err})
github.com/biogo/biogo@v1.0.2/io/featio/gff/gff.go:281:		panic(&csv.ParseError{Line: line, Column: index, Err: ErrBadStrandField})
github.com/biogo/biogo@v1.0.2/io/featio/gff/gff.go:285:		panic(&csv.ParseError{Line: line, Column: index, Err: ErrBadStrand})
github.com/biogo/biogo@v1.0.2/io/featio/gff/gff.go:312:				panic(&csv.ParseError{Line: line, Column: column, Err: ErrBadTag})
github.com/biogo/biogo@v1.0.2/io/featio/gff/gff.go:338:			panic(&csv.ParseError{Line: line, Column: index, Err: ErrBadTag})
github.com/biogo/biogo@v1.0.2/io/featio/gff/gff.go:376:		return nil, &csv.ParseError{Line: r.line, Err: ErrEmptyMetaLine}
github.com/biogo/biogo@v1.0.2/io/featio/gff/gff.go:382:			return nil, &csv.ParseError{Line: r.line, Err: ErrNotHandled}
github.com/biogo/biogo@v1.0.2/io/featio/gff/gff.go:388:			return nil, &csv.ParseError{Line: r.line, Err: ErrBadMetaLine}
github.com/biogo/biogo@v1.0.2/io/featio/gff/gff.go:394:			return nil, &csv.ParseError{Line: r.line, Err: ErrBadMetaLine}
github.com/biogo/biogo@v1.0.2/io/featio/gff/gff.go:405:			return nil, &csv.ParseError{Line: r.line, Err: ErrBadMetaLine}
github.com/biogo/biogo@v1.0.2/io/featio/gff/gff.go:414:			return nil, &csv.ParseError{Line: r.line, Err: ErrBadMetaLine}
github.com/biogo/biogo@v1.0.2/io/featio/gff/gff.go:423:			return nil, &csv.ParseError{Line: r.line, Err: ErrBadMetaLine}
github.com/biogo/biogo@v1.0.2/io/featio/gff/gff.go:427:		return nil, &csv.ParseError{Line: r.line, Err: ErrNotHandled}
github.com/biogo/biogo@v1.0.2/io/featio/gff/gff.go:441:			return nil, &csv.ParseError{Line: r.line, Err: err}
github.com/biogo/biogo@v1.0.2/io/featio/gff/gff.go:449:			return nil, &csv.ParseError{Line: r.line, Err: ErrBadSequence}
github.com/biogo/biogo@v1.0.2/io/featio/gff/gff.go:488:			return nil, &csv.ParseError{Line: r.line, Err: err}
github.com/biogo/biogo@v1.0.2/io/featio/gff/gff.go:504:		return nil, &csv.ParseError{Line: r.line, Column: len(fields), Err: ErrFieldMissing}
github.com/biogo/biogo@v1.0.2/io/seqio/fai/error.go:11:func parseError(line, column int, err error) *csv.ParseError {
github.com/biogo/biogo@v1.0.2/io/seqio/fai/error.go:12:	return &csv.ParseError{
github.com/biogo/biogo@v1.0.2/io/seqio/fai/error_go1.10.go:11:func parseError(line, column int, err error) *csv.ParseError {
github.com/biogo/biogo@v1.0.2/io/seqio/fai/error_go1.10.go:12:	return &csv.ParseError{
github.com/biogo/biogo@v1.0.2/io/seqio/fai/fai.go:71:// contains non-unique records the error is a csv.ParseError identifying the second non-unique
github.com/biogo/biogo@v1.0.2/io/seqio/fai/fai.go:84:			if _, ok = r.(*csv.ParseError); !ok {
github.com/biogo/hts@v1.1.0/fai/fai.go:127:func parseError(line, column int, err error) *csv.ParseError {
github.com/biogo/hts@v1.1.0/fai/fai.go:128:	return &csv.ParseError{
```
chang mention issue: `encoding/csv: add fieldpo method`
ok, updat implement discuss semantics, also chang semant `parseerror.column` `go/token.position` (i.e. byte-base, one-bas index).
unfortun perform differ notic (i think that' probabl append 128 bits, 64 bit `fieldinfo` slice, sure).
chang consensus, **accepted**. ðŸŽ‰
