go/ast: add rang token.po rangestmt
current `rangestmt`:
```go
	RangeStmt struct {
		For        token.Pos   // position of "for" keyword
		Key, Value Expr        // Key, Value may be nil
		TokPos     token.Pos   // position of Tok; invalid if Key == nil
		Tok        token.Token // ILLEGAL if Key == nil, ASSIGN, DEFINE
		X          Expr        // value to range over
		Body       *BlockStmt
	}
```
propos changes:
```diff
 	RangeStmt struct {
 		For        token.Pos   // position of "for" keyword
+		Range      token.Pos   // position of "range" keyword
 		Key, Value Expr        // Key, Value may be nil
 		TokPos     token.Pos   // position of Tok; invalid if Key == nil
 		Tok        token.Token // ILLEGAL if Key == nil, ASSIGN, DEFINE
 		X          Expr        // value to range over
 		Body       *BlockStmt
 	}
```
add extra 8 byte size 64-bit platforms. unfortun coincid right size 80 bytes, exactli size class. make 88 byte get next size class, 96 byte alloc (so effect add 16 byte per rang statement 64-bit platforms).
although would assum rang statement frequent as, say, `*ast.ident`, might big deal.
need this: partial code search/replacements, may want use structur element anchor make span range. instance, gogrep support rang pattern like `rang $x`, mean match `*ast.rangestmt` captur rang expression. bad part hard figur what' start po partial syntax is.
way find `range` posit right take `tokpos` walk sourc text manually, hope inlin `/**/` comment thing may float `:=` `range`. unusu anyth tok range, still possibl even gofmt' code.
side note, look like gofmt move comment there: `for _, x := /*ok*/ rang xs {}` becom `for _, x := rang /*ok*/ xs {}`.
rational convincing, actual need pattern match standalon `range` claus rule engin (base go-ruleguard) base gogrep. get precis locat (po range) import appli automat fix.
issu may meet fate #44257 did, figur still report fact issu peopl get creat untrivi go tools.
propos accepted, would like send cl implementation.
## kludg / workaround
propos never accepted, emb partial solut may also show awkward find "range" po right now.
```go
var from int
if rng.TokPos.IsValid() {
	// Start from the end of the '=' or ':=' token.
	from = int(rng.TokPos + 1)
	if rng.Tok == token.DEFINE {
		from++ // ':=' is 1 byte longer that '='
	}
	// Now suppose we have 'for _, x := range xs {...}'
	// If this is true, then `xs.Pos.Offset - len(" range ")` would
	// lead us to the current 'from' value.
	// It's syntactically correct to have `:=range`, so we don't
	// unconditionally add a space here.
	if int(rng.X.Pos())-len(" range ") == from {
		// This means that there is exactly one space between Tok and "range".
		// There are some afwul cases where this might break, but let's
		// not think about them too much.
		from += len(" ")
	}
} else {
	// `for range xs {...}` form.
	// There should be at least 1 space between "for" and "range".
	from = int(rng.For) + len("for ")
}
```
cc @griesem @findleyr
also ever encount problem:
relat issue:
two similar cases:
* token.po `else` if-els block
* token.po `type` type-switch block
currently, need effort get positions, sure implement bug free.
add context kludg manual token (describ referenc thread + issue) discoveri hard: also use minifi go corpu queri structur patterns.

sourc minifi minformat, consum ~25% less space (which signific 80mb vs 60mb) . structur search still work fine care thing like space explicit semicolon (it work ast same).
probabl obviou usag go code (structur ast pattern + minifi sourc code), thing.
#13590 closed, think anyth chang sinc then?
object proposal. concern right `go/ast` gener difficult use refactor tools, due miss information, wish could take step back holist evalu would requir solv _all_ problem (miss posit information, float comments, captur irrelev syntax, etc.). feel like realli want layer top go/ast captur full syntax origin (unmodified) input. focus design layer (in consider prior art), rather ad addit inform go/ast that' need gofmt go/types?
ask 16 bytes, think philosoph concern blocking.
@go101
> two similar cases:
list comprehensive? wonder much would take invari "go/ast captur posit semant relev tokens".
think list comprehensive. three one found develop go101/golds.
base discuss above, propos seem like **like accept**.
â€” rsc propos review group
chang consensus, **accepted**. ðŸŽ‰
