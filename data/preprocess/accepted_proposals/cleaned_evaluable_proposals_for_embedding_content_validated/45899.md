io: add offsetwriter, newoffsetwrit
```go
CopyAt(dst WriterAt, src Reader, off int64) (written int64, err error)
CopyAtBuffer(dst WriterAt, src Reader, off int64, buf []byte) written int64, err error)
CopyFileRange(dst WriterAt, woff int64, src ReaderAt, roff int64) (written int64, err error)
```

```go
func NewSectionWriter(r WriterAt, off int64, n int64) *SectionWriter
func (s *SectionWriter) Write(p []byte) (n int, err error)
func (s *SectionWriter) WriteAt(p []byte, off int64) (n int, err error)
func (s *SectionWriter) Seek(offset int64, whence int) (int64, error)
func (s *SectionWriter) Size() int64
```
help concurr writes.
would used? come often enough stdlib?
@seankhliao
- download file concurr use http ranges.
- merg multipl file one.
- use case multipl go routin tri write concurr specif locat file.
inconveni current implementations:
- `writeat()` need wrap loop temporari buffer need keep track check everyth written.
- `writeat()` buffer length equal data read, use much memory.
- `seek()`, use seek multipl go routin valid option.
better perform concurr writes.
- zero copi function like `readfrom()`, `writeto()` use concurr writes, possibl now.
anoth option would povid `readfromat()` `writetoat()`
in-cas `unix` `copyfilerange` system call, exactli this.
thank you.
note use `copy_file_range` system call `io.copy` gener `os.file.readfrom`. true current alway pass offset argument `nil`.
`copyat` immedi clear whether `off` argument appli reader writer. infer writer type `writerat`. gener think pass offset one pass offset both, give us `copyfilerange` function.
think gener `io.copy` `io.copybuffer` mistake, want repeat mistake.
alreadi `io.writerat` `writeat` method, `os.file` alreadi `writeat` method. alreadi call method concurr multipl goroutines. clear handl new function get new functions.
> alreadi `writeat`
yes, book-keep needed. `writeat()` similar `write()`.
> clear handl new function get new functions.
like `io.copy()` `write()`, `io.copyat()` `writeat()`
```go
// CopyBufferAt , copies `src` to `dst` at `off` using `buf`
//
// copied from io.copyBuffer
func CopyBufferAt(dst io.WriterAt, src io.Reader, off int64, buf []byte) (written int64, err error) {
	for {
		nr, er := src.Read(buf)
		if nr > 0 {
			nw, ew := dst.WriteAt(buf[0:nr], off+written)
			if nw < 0 || nr < nw {
				nw = 0
				if ew == nil {
					ew = errors.New("invalid write result")
				}
			}
			written += int64(nw)
			if ew != nil {
				err = ew
				break
			}
			if nr != nw {
				err = io.ErrShortWrite
				break
			}
		}
		if er != nil {
			if er != io.EOF {
				err = er
			}
			break
		}
	}
	return written, err
}
```
limit understand goes,
current possibl zero copi oper specif locations.
featur added, would good.
thank you.
ad variant copi seem like mistake, other noted.
ad sectionwrit match sectionread seem plausible.
anyon object ad sectionwriter?
propos ad activ column propos project
review weekli propos review meetings.
â€” rsc propos review group
call `newsectionwriter(w, off, n)` impli size `w` alway becom least `off` + `n`? depend subsequ writes? error size alreadi least `off` + `n`?
@ianlancetaylor
think `n` necessari here.
copi definit `sectionreader` chang `sectionwriter`.
edit:
take cue `newsectionreader()`:
- `newsectionreader()`, `off` repres start point `n` end point, tri read `n` result `io.eof`. thu repres section `off` `n`.
- `newsectionwriter()`, `off` repres start point `n` end point, tri write `n` result error `x`. thu repres section `off` `n`.
`n` stay, error `newsectionwriter()` return, new error defined?
`n` remov `newsectionwriter()`, allow write go user need it.
still call `sectionwriter`, repres **section** anymore.
think `n` stay, new error defined.
`n` stay, think need answer earlier questions:
> call newsectionwriter(w, off, n) impli size w alway becom least + n? depend subsequ writes? error size alreadi least + n?
thanks.
depend subsequ writes.
> depend subsequ writes.
would help concurr writes, then?
@opennota
go work?
```go
func main() {
	var length, ps, i int64 = 1000000, 100000, 0
	f, _ := os.Create("file")
	for ; i < length; i += ps {
		go func(from, to int64) {
			req, _ := http.NewRequest(http.MethodGet, "https://someurl.com/file", nil)
			setRange(req, from, to)
			resp, _ := http.DefaultClient.Do(req)
			nw := io.NewSectionWriter(f, from, to)
			io.Copy(nw, resp.Body)
			resp.Body.Close()
		}(i, i+ps)
	}
}
func setRange(req *http.Request, start, end int64) {
	req.Header.Set("Range", fmt.Sprintf("bytes=%d-%d", start, end-1))
}
```
true, seem need n (the section length). make realli sectionwrit like offsetwriter. that' fine course.
ok sound like api is:
```
// An OffsetWriter maps writes at offset o to offset o+off in the underlying writer.
type OffsetWriter struct { }
func NewOffsetWriter(r WriterAt, off int64) *OffsetWriter
func (s *OffsetWriter) Write(p []byte) (n int, err error)
func (s *OffsetWriter) WriteAt(p []byte, off int64) (n int, err error)
func (s *OffsetWriter) Seek(offset int64, whence int) (int64, error)
```
right? anyon object this?
> anyon object this?
person no.
base discuss above, propos seem like **like accept**.
â€” rsc propos review group
clairfying, offset method end top origin offset use creat `*offsetwriter`, correct?
```
func (s *OffsetWriter) WriteAt(p []byte, off int64) (n int, err error)
func (s *OffsetWriter) Seek(offset int64, whence int) (int64, error)
```
@kortschak
> top origin offset?
sure mean `on top of` mean relatively, yes.
```go
NewOffsetWriter(x, 10)
WriteAt(y, 10) // y is written at offset 20 of x.
```
> mean relatively, yes.
yes. thanks.
chang consensus, **accepted**. ðŸŽ‰
