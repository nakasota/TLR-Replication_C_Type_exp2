runtime: enabl address sanit go
address sanit (asan) memori error detector, find number memori access error occur c, out-of-bound access heap, stack global objects, use-after-free. general, issu occur pure go code, unless peopl intent use unsaf package. however, peopl use cgo pass memori back forth c go, caus memori access problems.
pleas refer follow cases.
case (case-1) c pass go invalid pointer, caus go code use-after-fre errors. case (case-2) go pass c pointer, c code out-of-bound access heap object errors. case (case-3) go pass c pointer, c code out-of-bound access global object errors.
integr asan go would detect memori errors. useful. addition, asan help detect memori error msan cannot. example, use-after-fre memori error case msan cannot detect write uniniti memory, asan can.
instrument asan exactli way msan. -msan option, run -asan option, effect code execution, use it, may find memori errors.
although case real world cases. however, hand, debug memori error access go program call c code, realli good abl use asan ensur code correct. obviously, requir code maintain toolchain, sinc almost code next exist msan code, quit limited.
besides, arm hardwar featur mte (memori tag extension), aim mitig memori safeti bug enabl us detect low overhead. asan proven useful, may consid enabl mte asan. way, asan even enabl product environ help detect memori error low overhead. saw blog introduc enabl mte android detect common class memori safeti bugs. pleas refer document
thank you.
updat cl address sanit support, implement divid smaller cl 298610, 298611, 298612, 298613, 298614 review. current implementation, -asan option check error memori access heap objects. thank you.
care size binary. compar size includ small samples(<5m) big samples(>10m)?
@az-x run go program without -asan option, size binari change. generally, enabl address sanit test environ help detect memori access issues, think size binari important. thank you.
@az-x regard question, answer seem one-sided. wrote test case compar size binary, size binari -asan almost 10% larger without -asan. pleas refer follow results.
```
func main() {
        var overall [][]int
        var m runtime.MemStats
        s := 2*1024*1024                 //  >10M big samples
        //s := 10*1024                     // <1M small samples
        for i := 0; i < 10; i++ {
                a := make([]int, 0, 10*s)
                overall = append(overall, a)
        }
        runtime.ReadMemStats(&m)
        fmt.Printf("Alloc = %v MB", bToMb(m.Alloc))
}
func bToMb(b uint64) uint64 {
        return b / 1024 / 1024
}
```
// binay size:
```
  size           binary
2154616   big_asan               // build with -asan and big samples
1950161   big_noasan           // build without -asan and big samples  
2154624   small_asan            // build with -asan and small samples
1950161   small_noasan        // build without -asan and small samples
1940941   big_main              // build with master go and big samples
1940949   small_main           // build with master go and small samples
```
result, size binari bigger. mention above, recommend open asan option product environment. factor consid size, also performance. good news arm64 new featur mte, design detect error memori access lower overhead. asan mte enabl go future, impact perform size binari rel small. thank you.
> asan mte enabl go futur
need support all?
would assum done export env var enabl mte system malloc, e.g.:


mayb futur default, one need anyth all.
though make sens support mte _go_ runtime:

> mayb futur default, one need anyth all.
fact, need something. go memori allocator, see may follow implementaion glic, refactor go memori allcat (regard implement details, done in-depth research. ðŸ™‚), setup memori tag support hardwar support user request it. thank you.
yes, that' mean "support mte go runtime". need anyth relat asan (link asan, asan hooks, etc)
> yes, that' mean "support mte go runtime". need anyth relat asan (link asan, asan hooks, etc)
yes, right. mte, load store instructions, except sp base regist immedi offset, check tags. introduc mte work stack. thank you.
chang mention issue: `cmd/link: add -asan option`
chang mention issue: `cmd/compile: add -asan option`
chang mention issue: `cmd/go: add -asan option`
chang mention issue: `runtime, runtime/asan: add asan runtim support`
chang mention issue: `runtime, syscall: add call asan functions`
chang mention issue: `cmd/dist: add asan test misc/cgo/testsanit package`
updates?
> updates?
enter code freez go 1.17. ðŸ˜Ÿ
@ianlancetaylor plan 1.18? thank you.
> @az-x regard question, answer seem one-sided. wrote test case compar size binary, size binari -asan almost 10% larger without -asan. pleas refer follow results.
>
> ```
> func main() {
> var overal [][]int
> var runtime.memstat
> := 2*1024*1024 // >10m big sampl
> // := 10*1024 // <1m small sampl
> := 0; < 10; i++ {
> := make([]int, 0, 10*s)
> overal = append(overall, a)
> }
> runtime.readmemstats(&m)
> fmt.printf("alloc = %v mb", btomb(m.alloc))
> }
> func btomb(b uint64) uint64 {
> return b / 1024 / 1024
> }
> ```
>
> // binay size:
>
> ```
> size binari
> 2154616 big_asan // build -asan big sampl
> 1950161 big_noasan // build without -asan big sampl
> 2154624 small_asan // build -asan small sampl
> 1950161 small_noasan // build without -asan small sampl
> 1940941 big_main // build master go big sampl
> 1940949 small_main // build master go small sampl
> ```
>
> result, size binari bigger. mention above, recommend open asan option product environment. factor consid size, also performance. good news arm64 new featur mte, design detect error memori access lower overhead. asan mte enabl go future, impact perform size binari rel small. thank you.
assum measur done arm, right? x86?
also, plan implement first-class asan support x86-64? (obviously, without mte, avail x86)
yours,
andrey
\===
advanc softwar technolog lab
huawei
> assum measur done arm, right? x86?
size binari -asan almost 11% larger without -asan. pleas refer follow results.
binari size x86-64.
```
      size                 binary
    1998048          big_asan
    1785270          big_noasan
    1785246          big_main
    1998048         small_asan
    1785270         small_noasan
    1785246         small_main
```
> also, plan implement first-class asan support x86-64? (obviously, without mte, avail x86)
current implement also enabl asan support x86-64. thank you.
chang mention issue: `cmd/compile: enabl asan check global variables`
chang mention issue: `cmd/dist: add asan test global object testsanit package`
hello!
plan support asan stack-bas objects? problem usag unsafe.point affect escap analysis, lot case potenti insecur derefer unsafe.point stack objects. afaik go gener stack canari code, vulner easili exploitable.
simpl example:

here, due misus unsafe.point easi ip control.
also, add mte support, runtim go use, part go asan implementation, anoth feature?
best wishes, alex
reference, discuss differ aspect propos golang-dev thread:

@ph1048, fyi, discuss around stack objects, though perhap @zhangfanni say here.
> also, add mte support, runtim go use, part go asan implementation, anoth feature?
>
@ph1048 add mte support anoth feature, @dvyukov comment above, need call compiler-rt address sanit runtim functions. thank you.
implement cl 321715 , asan go detect error memori access heap object global objects. stack objects, discuss golang-dev mail list current plan add support it. way, support asan go complete.
welcom review patches. thank you.
hi @zhangfanni
respect, find two statements:
> stack objects, discuss golang-dev mail list current plan add support it.
> way, support asan go complete.
mutual contradictory.
without stack object supported, asan go definit "complete". "asan heap global objects" call complete, sure -- still maintain user care object allocated, especi give escap analysi move object heap stack easily.
plan add support stack objects, @dvyukov wrote mail list:
> either way, would consid stack heap implement
> deployed. littl point planning/decid stack
> that.
read "let' heap object first, decid stack object support".
@andreybokhanko
thank correct express "asan heap global object complete" accurate.
plan add support stack objects, wrote mail list:
> support heap objects, chang go memeori alloc insert redzon around heap objects. support stack object also need chang frame layout insert redzon around stack objects, refactor may caus problems.
one problem compat abi. go pass value, also equal pass memory, use unsafe.point access paramet adress return adress. far, clear definit go call convention. sure pass value, pass memori region share caller callee.
example, follow case, asan go want detect error memori acc stack objects, **we need insert redzon around pass variables(a, b) return variabl (ret)**, break current abi.
```
package main
import "fmt"
import "unsafe"
//go:noinline
func add(x int, y int) (ret int) {
	*(* int)(unsafe.Pointer((uintptr(unsafe.Pointer(&ret)) - 1*unsafe.Sizeof(ret)))) = 123    // Is it an error?
	*(* int)(unsafe.Pointer((uintptr(unsafe.Pointer(&ret)) - 2*unsafe.Sizeof(ret)))) = 543    // Is it an error?
	ret = x + y
	return
}
func main() {
	fmt.Println(add(42, 13))
}
```
present, good idea support it. 3 kind stack memori need considered, includ local variables, argument variabl return variables.
clear call convers definit moment, mayb part discuss regabi. @cherrymui
hello!
review design, great solution. so, would like make suggestions.
first, approach unpoison mallocgc side may cover cases. modifi exampl way "growslice" code generated, produc asan output me:
problem built-in object constructor alloc memori real size data: e.g. slice alloc memori capacity, length; case alloc size rounded. suggest move poison handl insid object constructors, take account real data length.
second, typic asan report conveni read, produc brief error information, limit stack trace information. implement poison check yourself, may point implement pretty-print asan error go stacktrace, similar one gener panic/throw.
best wishes,
alexand
@ph1048 thank review suggestion.
> first, approach unpoison mallocgc side may cover cases. modifi exampl way "growslice" code generated, produc asan output me:
first, need discuss whether access case out-of-bound access error.
example, follow case, slice variabl `sl1` `sl2` point underli array slice `sa`. slice copi slice' data, creat new slice valu point origin array. index greater capac slice instead length, caus runtim panic.
therefore, access case valid.
```
package main
/*
#include <stdlib.h>
#include <stdio.h>
void test(int *a) {
        int c = a[5];           // the access is valid.
        printf("c=%d\n", c);
}
*/
import "C"
func main() {
        sa := []C.int{1, 2, 3, 4}
        sa = append(sa, 5) 
        var sl1 []C.int
        sl1 = sa[4:7] 
        sl1[1] = 6          // &sl1[1] = &sa[5],
        C.test(&sa[0])
}
```
>
>there may point implement pretty-print asan error go stacktrace, similar one gener panic/throw.
good suggestion. spend time look whether implemented.
thank you.
fanni
@zhangfanni thank explanation. agre slicing, document method reus underli memory, refer capac slice, access valid example. creat go object permit access memori region.
but, previou case ( creat slice origin slice: memori access term go. so, mean access still valid, despit index oper would panick cintslice[5]?
best wishes,
alexand
@ph1048
> but, previou case ( creat slice origin slice: memori access term go. so, mean access still valid,
>
yes, access valid. poison handl consid capac slice. take account real data length (equl 5 case), cintslice[5] unaddressable, slice cintslice[5:6] fail, incorrect behavior.
thank you.
fanni
