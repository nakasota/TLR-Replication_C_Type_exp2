hash, crypto: add writebyte, writestr method hash implement
propos initi embed io.bytewrit hash.hash, ad writebyte() method signature.
method alreadi ad new maphash.hash. ad elsewher extend benefit perform usabl hash implementations.
per feedback @ianlancetaylor below, instead propos addit `writebyte()` io.bytewrit standard librari hash.hash implementations, including:
adler32
crc32
crc64
fnv
unfortunately, propos chang would backward compatible. would mean exist type satisfi hash.hash interfac would longer implement interface. could break work code, violat go 1 compat guarante (
so, short, can't this.
got it. ad anoth interface, ad writebyte() method standard library' hash implementations?
hash sometim part performance-sensit code paths, would benefici avoid convers byte slice whose purpos satisfi api.
sure need anoth interface, sinc peopl alway type assert `io.bytewriter`.
want repurpos propos ad `writebyte` method variou hash implementations?
perform benefit? experi writebyt slower append byte slice use classic write method everi 256 512 bytes.
perform benefit hash byte slices. hash everyth else: primitives, structs, maps, arrays, combin thereof.
provid exampl code help understand statement?
usual hash oper much faster block data singl byte time.
one potenti problem ad writebyt use would inher slower
pass larger slice data.
use case writebyt would prefer construct (presum larger one byte) slice call write?
```
type T struct {
    A byte
    B string
    C byte
    D string
}
func HashT(h hash.Hash, t *T) { ... }
```
implement `hasht()`, would conveni convers byte slices. current option use `encoding/binary`, api express avoid byte slice call gener `io.writer`. ditto support `writestring()`.
combin bufio.writ hash.hash creat buffer hash
test here:
```Go
package main
import (
	"bufio"
	"crypto/sha256"
	"fmt"
	"hash"
)
type BufferedHash struct {
	h hash.Hash
	*bufio.Writer
}
func NewBufferedHash(h hash.Hash) *BufferedHash {
	return &BufferedHash{
		h:      h,
		Writer: bufio.NewWriter(h),
	}
}
func (bh *BufferedHash) Sum(p []byte) []byte {
	if err := bh.Flush(); err != nil {
		panic(err)
	}
	return bh.h.Sum(p)
}
func (bh *BufferedHash) Reset() {
	bh.h.Reset()
	bh.Writer.Reset(bh.h)
}
func (bh *BufferedHash) Size() int {
	return bh.h.Size()
}
func (bh *BufferedHash) BlockSize() int {
	return bh.h.BlockSize()
}
type T struct {
	A byte
	B string
	C byte
	D string
}
func HashT(bh *BufferedHash, t T) {
	bh.WriteByte(t.A)
	bh.WriteString(t.B)
	bh.WriteByte(t.C)
	bh.WriteString(t.D)
}
func main() {
	bh := NewBufferedHash(sha256.New())
	t := T{A: 'A', B: "B", C: 'C', D: "D"}
	HashT(bh, t)
	fmt.Printf("hash(%+v): %x\n", t, bh.Sum(nil))
	bh.Reset()
	t = T{A: 'A', B: "B", C: 'C', D: "Dee"}
	HashT(bh, t)
	fmt.Printf("hash(%+v): %x\n", t, bh.Sum(nil))
}
```
proverb "if time, would written shorter letter" appli here. need creat extra type:
```go
package main
import (
	"crypto/sha256"
	"fmt"
	"io"
)
type T struct {
	A byte
	B string
	C byte
	D string
}
func SerializeT(w io.Writer, t T) {
	fmt.Fprintf(w, "%c%s%c%s", t.A, t.B, t.C, t.D)
}
func main() {
	h := sha256.New()
	t := T{A: 'A', B: "B", C: 'C', D: "D"}
	SerializeT(h, t)
	fmt.Printf("hash(%+v): %x\n", t, h.Sum(nil))
	h.Reset()
	t = T{A: 'A', B: "B", C: 'C', D: "Dee"}
	SerializeT(h, t)
	fmt.Printf("hash(%+v): %x\n", t, h.Sum(nil))
}
```
what' context hash non-byte-slic function like sha256?
build hash table, hash/maphash packag use, maphash.hash _does_ writebyte.
need well-defin fix hash function, that' almost alway use specif byte sequence.
suppos crypto/* hash buffer alreadi hash/* function oper byte time. still run faster larg sequences.
build relat database. understand reserv chang / additions, high scale high performance, import api requir avoid overhead.
> high scale high performance, import api requir avoid overhead.
argument tri make _against_ ad writebyt precis realli can't high performance. arrang larger write alway go beat writebyt loop. reserv provid writebyt exactli would tempt peopl toward less effici path.
may still want add convenience, especi case care "high scale high performance", think want use relat database.
hash buffer underneath, implement writebyt effici - well, effici anyon implement writebyte.
still effici call write mani byte call writebyt loop, given io.bytewrit exists, seem reason make hash.hash implement implement it.
(to clear, can't modifi hash.hash itself, origin proposed.)
earlier year declin #14757 implement would use unsafe, @bradfitz point buffer enabl writebyt would also enabl safe implement writestring. mayb add writestr time, use safe code. (if pass long string, writestr would copi buffer, process buffer, repeat. would still bit copying, convert []byte.)
retitl issu writebyt writestr leav open anoth week, seem head like accept.
premis hash buffer underneath correct. non-cryptograph hash adler32, crc32, crc64 fnv packag hash directori standard librari buffers. cours possibl implement writebyt writestr hash base write logic.
cost proposal, implement writebyt writestr hash standard library, increas code size addit test code. implement requir replic write logic
new method unless method implement wrapper around write.
conveni argument writebyt still convinc me. necessari add method hash function someth result slow code. beginn still struggl
know need convert hash bytewrit experienc develop abl use `fmt.fprintf(w, "%c", c)` write wrapper sinc perform cannot concern
case.
wonder whether look gener problem: **how writebyt writestr support io.writer?**
one option use bufio.writ wrapper. complic program logic requir call flush ensur data written underli writer.
writestr io.writestr function, disadvantag alloc new byte slice copi data string. packag unsaf probabl use requir
write method modifi slice cannot enforc compiler. suggest provid unsafe.writestr function assum writer modifi slice. may use
case perform critical.
writebyt io.writebyt conveni function would address problem. perform concern here.
propos still allow implement writebyt writestr hashes, make mandatory.
adler32, crc32, crc64, fnv buffer byte-at-a-tim algorithm (the chunk size 1 byte).
implement writebyt writestr call single-byt updat function.
(that may involv refactor write, inlin good enough keep slow write.)
io.writebyt conveni function would alloc everi byte fallback, like io.writestr alloc everi call (but mani fewer call typic cases!). that' expens hide innocuous-look function.
thank ross response. agre state alreadi possibl implement writebyt writestr adler32, etc. type support write method alway possibl implement
writebyt writestr regardless whether write oper buffer not.
understand perform argument writestring, still convinc writebyte. actual use case requir implement hashes? origin propos cite direct marshal serial struct valu hash. convinc struct may includ type like larger integ hash support directly.
also question consist writer standard library. propos implement hash support writebyt writestring, os..fil support writestr writebyt net.tcpconn support write. gener rule support writebyt writestring?
```
% go doc io.ByteWriter
package io // import "io"
type ByteWriter interface {
	WriteByte(c byte) error
}
    ByteWriter is the interface that wraps the WriteByte method.
% go doc io.ByteReader
package io // import "io"
type ByteReader interface {
	ReadByte() (byte, error)
}
    ByteReader is the interface that wraps the ReadByte method.
    ReadByte reads and returns the next byte from the input or any error
    encountered. If ReadByte returns an error, no input byte was consumed, and
    the returned byte value is undefined.
    ReadByte provides an efficient interface for byte-at-time processing. A
    Reader that does not implement ByteReader can be wrapped using
    bufio.NewReader to add this method.
% 
```
bytewrit doc help - there' noth anywher writebyt means.
possibl say bytewrit bytereader: implement efficiently, okay one. not, not.
hash implement effici enough probabl worth doing.
base discuss above, seem like **like accept**.
extend bytewrit document sure helpful. bufio writer remark must howev modifi requir addit use flush method.
wrote packag provid wrioter wrapper return writer three write methods: write, writebyt writestring. write direct new fluse required.
github.com/ulikunitz/xio.
chang consensus, accepted.
chang mention issue: `crypto/*, hash: add writestr method hash.hash algorithms`
> earlier year declin #14757 implement would use unsafe, @bradfitz point buffer enabl writebyt would also enabl safe implement writestring.
make fast safe implement `writestring` use generics.
```go
func write[T interface{ string | []byte }](d *digest, p T) (int, error) {
          // Write implementation...
}
func (d *digest) Write(p []byte) (int, error) { return write[[]byte](d, p) }
func (d *digest) WriteString(p string) (int, error) { return write[string](d, p) }
```
idea propos go implemented? recent need work sha256 wrap bufio.writ get decent perform ( tri use unsaf `s2b` first although reduc allocs, benchmark suggest thing slower.
chang mention issue: `crypto/sha256: add writestr writebyt method`
@imack clear help you, patch add `writestring` `writebyte` crypto/sha256. make differ code?
chang mention issue: `crypto/sha1: add writestr writebyt method`
chang mention issue: `crypto/sha512: add writestr writebyt method`
chang mention issue: `revert "crypto/sha256: add writestr writebyt method"`
chang mention issue: `revert "crypto/sha512: add writestr writebyt method"`
