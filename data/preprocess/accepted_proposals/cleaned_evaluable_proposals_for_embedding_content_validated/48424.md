spec: allow elid interface{ } constraint liter
propos addit rule constraint type paramet lists:
`[t noninterfacetype]` â‰¡ `[t interface{~noninterfacetype}]`
rationale:
function propos `maps` packag (#47649) function `slices` packag (#45955, #47203) current use constraint `constraints` packag (#45458) maximum generality. hypothet `chans` packag would probabl similar (there' alreadi propos `constraints.{readonlychan|writeonlychan}`: #48366). excerpts:
func equalfunc[m1 constraints.map[k, v1], m2 constraints.map[k, v2], k comparable, v1, v2 any](m1 m1, m2 m2, cmp func(v1, v2) bool) bool
func clone[ constraints.slice[t], any]( s)
propos would become:
func equalfunc[m1 map[k]v1, m2 map[k]v2, k comparable, v1, v2 any](m1 m1, m2 m2, cmp func(v1, v2) bool) bool
func clone[ []t, any]( s)
benefit:
- `constraints.{slice|map|chan|readonlychan|writeonlychan}` would necessari all.
- visual incongru plain old go type like `map[k]v`, `[]t`, `chan t`, `<-chan t`, `chan<- t` accompani constraints.
propos stem discuss
summary:
```
  [M map[K]V, K comparable, V any]
â‰¡ [M interface{~map[K]V}, K comparable, V any]
â‰¡ [M constraints.Map[K, V], K comparable, V any]
  [S []T, T any]
â‰¡ [S interface{~[]T}, T any]
â‰¡ [S constraints.Slice[T], T any]
  [C <-chan T, T any]
â‰¡ [C interface{~<-chan T}, T any]
â‰¡ [C constraints.ReadOnlyChan[T], T any]
  [C chan<- T, T any]
â‰¡ [C interface{~chan<- T}, T any]
â‰¡ [C constraints.WriteOnlyChan[T], T any]
  [C chan T, T any]
â‰¡ [C interface{~chan T}, T any]
â‰¡ [C constraints.Chan[T], T any]
```
cc @griesem
interest idea (intern go team) discuss essenti thing: write type express `x` constraint posit syntact sugar `interface{x}`. think there' someth it, quit figur (not spent time on) determin idea would fit smoothli rest type system.
case, propos would gener bit. instance, would want say `int|string` instead `interface{int|string}`. also, clear exactli `~` omit why.
this, think automat insert `~`. seem like unnecessari magic. would give us
```Go
func EqualFunc[M1 ~map[K]V1, M2 ~map[K]V2, K comparable, V1, V2 any](m1 M1, m2 M2, cmp func(V1, V2) bool) bool
func Clone[S ~[]T, T any](s S) S
```
imagin "type set express hoist type paramet list level", henc | ~. intend keep complex nuanc constraint definit insid interfaces. see "expand non-interfac type sole use constraint form". admittedli amount magic.
know probabl late syntax chang re. constraints, person would prefer this:
```
My preference                             Vs. current design
[T interface { M() }]                     [T interface { M() }]
[T nonInterfaceType]                      [T interface { ~nonInterfaceType }]
[T union {A|B|C}]                         [T interface { ~A|~B|~C }].               
[T interface { nonInterfaceType; M() }]   [T interface { ~nonInterfaceType; M() }] 
[T interface { union {A|B|C}; M() }]      [T interface { ~A|~B|~C; M() }] 
```
`union` non-interfac type well. rule would simple: non-interfac type match approxim use constraints, match exactli use regular types:
```
var x nonInterfaceType
var x union { A|B|C }
```
tilde, type like `map[k]v` could act directli `constraints.map[k, v]` etc.
@fzipp want make change, let' keep issu tightli focus specif change, discuss possibl altern syntaxes. thanks.
might abl say constraint simpli type set. type set may express interfac (a now), may _also_ type express form `~t` `a|b`. additionally, could say ordinari type repres type set `interface{t}` expect type set. syntactically, allow type express form `~t` `a|b` outsid interfac (in constraint posit only).
or, look slightli differ angle, could say write `t`, `~t` , `a|b` constraint posit form syntact sugar `interface{t}`, `interface{~t}` , `interface{a|b}`.
agre @ianlancetaylor ~ tie shortening.
point [c x] [c interface{x}] same.
alreadi case [c interface{x}] [c interface{interface{x}}] same,
make shorten safe 100% time.
would let us remov constraints.map, constraints.slice, etc.
get spell '~' now, [m ~map[k]v].
@griesem prototyp prepar cl show effect code.
ok prefer variant.
propos ad activ column propos project
review weekli propos review meetings.
â€” rsc propos review group
definit readabl win: understand `constraints.map[k, v]` thing necessari first all, mention annoy import take lot space. (newbie) code reader, understand `map[k]v`, go `constraints` packag docs, find `map` type, look definition, notic `~`. propos syntax, understand `~` means. (i prefer without `~`, know mean see desir avoid magic impli it.)
@rsc track (appar numer thought) propos relat generics, like ask, that' ok: _discussion_ around propos _temporarily_ suspend introduct `constraints` packag (until one decided)? sure what' statu latter, would feel weird `constraints.map` e.g. introduc go 1.18, becom insta-legaci one (#48424) make go1.18 (or wherev gener introduced) yet possibl land (say) go1.19. (in fact, kinda guess that' probabl one main reason got one fast track, still curiou ok explicit statement relat two. thanks!)
@akavel confid propos either accept declin go 1.18. accepted, consid remov `constraints.map`, `constraints.slice`, `constraints.chan`.
chang mention issue: `cmd/compile/internal/types2: allow elid interfac constraint literals`
chang mention issue: `cmd/compile/internal/types2: accept constraint liter elid interfaces`
chang mention issue: `cmd/compile: accept constraint liter elid interfaces`
chang mention issue: `x/tools/go/internal/gcimporter: exclud file testimporttypeparamtests`
chang mention issue: `cmd/compile/internal/types2: mark implicit interfac such`
implement compil master branch tip explor practice. note **thi propos accept yet**, write code expect remain valid month now...
compil understand notat moment, tool gofmt, vet, etc. cannot handl yet.
propos accepted, quickli disabl featur chang flag compiler.
per part propos explicitli remov `constraints.slice`, `constraints.map`, `constraints.chan`, ad part #45458. propos accepted, longer needed. current tree, part releas still remov them.
base discuss above, propos seem like **like accept**.
â€” rsc propos review group
interestingly, accepted, also allow constraint ordinari interfac type might open door almost exactli syntax propos here. example, could express someth must `[]byte` `string` `[]byte | string` rather `interface{ []byte | string}`.
ðŸ¤” world constraint valu types, option would
type maybe[t any] interfac { }
var none maybe[int] = nil
var maybe[int] = 1
@carlmjohnson person think interfac valu admit singl type admit nil well, awar other differ opinion that.
chang mention issue: `go/parser: allow elid interfac constraint literals`
chang mention issue: `go/types: mark implicit interfac such`
chang mention issue: `go/types: accept constraint liter elid interfaces`
chang mention issue: `go/internal/gcimporter: enabl import typeparam/issue48424.go`
chang consensus, **accepted**. ðŸŽ‰
