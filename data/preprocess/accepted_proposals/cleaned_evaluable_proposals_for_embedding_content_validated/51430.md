cmd/cover: extend coverag test includ applic
# proposal: extend code coverag test includ applic
author(s): mcintosh
last updated: 2022-03-02
detail design document: markdown, cl 388857
## abstract
document contain propos improving/revamp system use go code coverag testing.
## background
### current support coverag test
go toolchain current includ support collect report
coverag data golang unit tests; facil made avail via "go
test -cover" "go tool cover" commands.
current workflow collect coverag data bake "go test"
command; assumpt sourc code interest go packag
set packag associ tests.
request coverag data packag test run, user invok test(s)
via:
```
  go test -coverprofile=<filename> [package target(s)]
```
command build specifi packag coverag instrumentation,
execut packag tests, write output file "filename"
coverag result run.
result output file viewed/examin use command
```
  go tool cover -func=<covdatafile>
  go tool cover -html=<covdatafile>
```
hood, implement work sourc rewriting: "go test"
build specifi set packag tests, run packag sourc file
interest source-to-sourc translat tool produc
instrumented/aug equivalent, instrument record
portion code execut test runs.
function
```Go
  func ABC(x int) {
    if x < 0 {
      bar()
    }
  }
```
rewritten someth like
```Go
  func ABC(x int) {GoCover_0_343662613637653164643337.Count[9] = 1;
    if x < 0 {GoCover_0_343662613637653164643337.Count[10] = 1;
      bar()
    }
  }
```
"gocover_0_343662613637653164643337" tool-gener structur
execut counter sourc posit information.
"go test" command also emit boilerpl code gener
"_testmain.go" regist instrument sourc file unpack coverag
data structur someth easili access runtime.
finally, modifi "_testmain.go" code call runtim routin
emit coverag output file test completes.
### strength weak current provid
current implement simpl easi use, provid good user
experi use case collect coverag data packag unit tests.
sinc "go test" perform build invocation/execut
test, provid nice seamless "singl command" user experience.
key weak current implement scale well--
difficult imposs gather coverag data **applications** oppos
collect packages, test scenario involv multipl
runs/executions.
example, consid medium-s applic go compil ("gc").
variou packag compil sourc tree unit tests, one
use "go test" obtain coverag data tests, unit test
exercis small fraction code path compil
one would get actual run compil binari larg
collect go sourc files.
applications, one would like build coverage-instru copi
entir applic ("gc"), run instrument applic mani
input (say, go sourc file compil part "make.bash" run
multipl goarch values), produc collect coverag data output files,
final merg togeth result produc report provid
visualization.
mani folk golang commun run problem; larg
number blog post page describ issue, recommend
workaround (or provid add-on tool help); web search
"golang integr code coverage" turn mani page links.
addit weak current go toolchain offer relat way
coverag data present user "go tool cover")
commands. report produc "flat" hierarch (e.g. flat list
functions, flat list sourc file within instrument packages).
way structur report work well number instrument
packag small, becom less attract hundr
thousand sourc file instrumented. larger applications, would make
sens creat report hierarch structure: first summari module,
packag within module, sourc file within package, on.
finally, number long-stand problem aris due use
source-to-sourc rewrit use cmd/cover go command, includ
#23883
"cmd/go: -coverpkg=al give differ coverag valu run
packag list vs ./..."
#23910
"cmd/go: -coverpkg packag import tests, even one
otherwis use it"
#27336
"cmd/go: test coverpkg panic defin flag
multipl packages"
problem aris introduct addit import
`_testmain.go` shim creat go command carri coverag
test run combin "-coverpkg" option.
## propos chang
### build coverag
exist "go test" base coverag workflow continu
supported, propos add coverag new build mode "go build".
way user build race-detector instrument execut
use "go build -race", possibl build coverage-instru
execut use "go build -cover".
support goal, plan migrat support coverag
instrument compiler, move away source-to-sourc
translat approach.
### run instrument applic
applic deploy run mani differ ways, rang
simpl (direct invoc singl executable) complex (e.g. gang
cooper process involv multipl distinct executables). allow
complex execution/invoc scenarios, make sens
tri serial updat singl coverag output data file
run, sinc would requir introduc synchron
mechan ensur mutual exclus access.
non-test applic built coverage, user instead select
output directori oppos singl file; run instrument
execut emit data file within directory. example:
```
$ go build -o myapp.exe -cover ...
$ mkdir /tmp/mycovdata
$ export GOCOVERDIR=/tmp/mycovdata
$ <run test suite, resulting in multiple invocations of myapp.exe>
$ go tool cover -html=/tmp/mycovdata
$
```
coverag run context "go test", default continu
emit singl name output file test run.
file name within output directori chosen runtim
minim possibl collisions, e.g. possibl someth effect
```
  covdata.<metafilehash>.<processid>.<nanotimevalue>.out
```
invok reporting, coverag tool test input
argument see whether file directory; latter case,
read process file specifi directory.
### program call os.exit(), never termin
current coverag tooling, go unit test invok `os.exit()` pass
non-zero exit status, instrument test binari termin immedi
without write output data file. test invok `os.exit()` pass zero exit
status, result panic.
unit tests, perfectli acceptable-- peopl write test gener
incent need call `os.exit`, simpli would add anyth
term test functionality. real applic routin finish call `os.exit`,
however, includ case non-zero exit statu reported.
integr test suit nearli alway includ test ensur applic
fail properli (e.g. return non-zero exit status) applic
encount invalid input. go project' `all.bash` test suit mani sort tests,
includ test case expect caus compil linker error (and
ensur proper error path tool covered).
support collect coverag data programs, go runtim need
extend detect `os.exit` call instrument program ensur (in
form) coverag data written program terminates.
could accomplish either introduc new hook `os.exit`
code, possibl open mmap' coverag output file earlier
run, let write counter variabl go directli mmap'd
region, would elimin need close file exit (credit
austin idea).
handl server program (which mani case run forev may call
exit), api provid write coverag profil user
control, e.g. someth along line
```Go
  import "<someOfficialPath>/cover"
  var *coverageoutdir flag.String(...)
  func server() {
    ...
    if *coverageoutdir != "" {
        f, err := cover.OpenCoverageOutputFile(...)
        if err != nil {
            log.Fatal("...")
	   }
    }
    for {
      ...
      if <received signal to emit coverage data> {
        err := f.Emit()
        if err != nil {
            log.Fatalf("error %v emitting ...", err)
        }
      }
    }
```
addit opencoverageoutputfile() emit() above, emit() function
provid accept io.writ (to allow coverag profil
written network connect pipe, case write file
possible).
### coverag modul
modern go program make extens use depend third-parti packages;
advent go modules, system place explicitli
identifi track dependencies.
applic writer add third-parti dependency, case author
interest dependency' code count toward
"percent line covered" metric applic (there definit
except rule, hold cases).
make sens leverag inform go modul system collect
code coverag data. within context modul system, given packag feed
build applic one three follow disposit (rel
main module):
* contained: packag part modul (not dependency)
* dependent: packag direct indirect depend modul (appear go.mod)
* stdlib: packag part go standard librari / runtim
mind, propos build applic coverag
instrument everi packag feed build, record
disposit packag (a above), allow user select
proper granular treatment depend view reporting.
example, consid delv debugg
(a go application). one entri delv v1.8 go.mod file is:
github.com/cosiner/argv v0.1.0
packag ("argv") 500 line go code coupl dozen go
functions; delv use singl export function. develop tri
gener coverag report delve, seem unlik would want
includ "argv" part coverag statist (percent lines/funct executed),
given secondari modest role depend plays.
hand, possibl imagin scenario specif
depend play integr import role given application, mean
develop might want includ packag applic coverag
statistics.
### merg coverag data output file
part work propos enhanc "go tool cover" command
provid profil merg facility, collect coverag data file
(emit multipl run instrument executable) merg
singl summari output file. exampl usage:
```
  $ go tool cover -merge -coveragedir=/tmp/mycovdata -o finalprofile.out
  $
```
merg tool capabl write file exist (legacy)
coverag output file format, request user.
addit "merge" facility, may also interest support
oper intersect subtract (more later).
### differenti coverag
fix bug application, common practic add new unit
test addit code chang compris actual fix.
use code coverage, user may want learn mani chang line
code actual cover new test runs.
assum set n coverag data output file (correspond
gener run exist set test package) new
coverag data file gener new testpoint, would use provid
tool "subtract" coverag inform first set
second file. would leav set new line / region new test caus
cover beyond alreadi there.
featur (profil subtraction) would make much easier write tool
would provid feedback develop whether newli written unit test
cover new code way develop intended.
## design detail
pleas see design document detail propos chang compiler, etc.
## implement timet
plan thanm@ implement go 1.19 time frame.
## prerequisit chang
n/a
## preliminari result
data avail yet.
chang mention issue: `proposal: design document redesign code coverage`
also like relev :)
past need merg coverag profil applic execut differ oss, therefor differ binaries, order report singl coverag metric os-agnost report.
see explicit refer use case design, would covered? (pun intended)
merg coverag profil produc differ goos/goarch environments: yes, absolut supported.
one interest (and imho slightli weird) aspect current coverag system definit "all sourc code package" limit what' pick build tag effect "go test" run.
possibl "go test -cover" see "100%" statement coverag linux, even may 500-line function file foo_windows.go packag (with build tag select goos=windows) effect invis coverag tooling.
sound great! can’t wait tri out! :)
(#31007 also somewhat related.)
realli like direct propos would take code coverag go. look like propos would lay foundat bring go' code coverag stori next level. developer' perspect realli like capabl emma tool java code coverag use use year ago. felt lost someth code coverag tool avail go becam main program languag roughli ten year ago. consid take look prior art already.
particular would like advoc "intra-lin coverage" featur mention "possibl extensions" section proposal. featur emma got lot valu use (emma call fraction line coverage).
also, abil measur code coverag whole applic gather coverag data integr test two use case current project work need solut for. discuss came last week, timeli propos amazing.
nice idea. would bring design coverag use go build tool blaze/bazel convergence. (the latter alreadi implement coverag build mode, support whole-program coverage.) move instrument step source-bas transform compil pass also simplifi go bazel, may permit finer-grain coverag short-circuit express `a || b && c` line granularity.
propos ad activ column propos project
review weekli propos review meetings.
— rsc propos review group
cc @robpik
understand weak current approach well anyone, move heavi lift compil seem like mistak me. advantag extant decoupling, eas mainten tool tweak build chain.
simpler flexibl keep source-to-sourc translat work go build? problem compil coverag kept separate, advantag simplic portabl result.
>wouldn't simpler flexibl keep source-to-sourc translat work go build?
fair question, someth think good bit lately.
initi instinct use entir compiler-bas approach seem offer control/freedom term implementation, also (to honest) compil + linker expertise, e.g. "comfort zone".
written cl thing compiler, approach seem work well overal definit headaches.
one headach move thing main gc compiler, also need someth work compil (gccgo, gollvm).
second problem compil moment captur sourc posit inform need. example, consid function:
```
func addStr(x, y string) string {	// line 19
	return x + y 			// line 20
}					// line 21
```
here' ast dump compil 'walk' phase:
```
before walk addStr
.   RETURN tc(1) # p.go:20:2
.   RETURN-Results
.   .   ADDSTR esc(h) string tc(1) # p.go:20:11
.   .   ADDSTR-List
.   .   .   NAME-p.x esc(no) Class:PPARAM Offset:0 string tc(1) # p.go:19:13
.   .   .   NAME-p.y esc(no) Class:PPARAM Offset:0 string tc(1) # p.go:19:16
```
compil captur sourc posit info open close bracket line 19 21 (whi bother, need debugging), look refer "x" "y" line 20, sourc posisit correspond definitions, uses.
creat issu report coverag basic metric (e.g. percent statement covered) real problem gener html reports, sinc want abl "paint" chunk code red green (depend whether execut not)-- can't paint correctli captur sourc posit info it.
course, could chang compil work mode captures/record info (if build "-cover"), risk might slow "fast path" compil even extra info collect turn off.
given alreadi written compiler-bas implementation, think go tri prototyp source-to-sourc base altern well (but move emit new output format). might better middl ground.
synergi propos new `go test -fuzz` feature? could fuzz test reus coverag tool propos benefit?
>i synergi propos new go test -fuzz feature? could fuzz test reus coverag tool propos benefit?
reason question (i might add also came previous intern design review).
although coverag test fuzz incorpor notion "coverag data", two thing suffici differ term use data mean probabl worth tri share implementations.
case compil (or tool) ad instrument code (counter increment modification) control flow edges, beyond thing diverg big way.
fuzz need captur sourc posit inform counter (there would point), valu coverag counter use intern / on-lin within test, never written stored. thing fuzzer want know whether coverag "changed" result mutat (aiui).
coverag test hand, sourc posit info critic (it' arguabl key piece), unlik fuzz want determin coverag changed, need abl write report it.
mind, guess go lot use overlap. think probabl ok -- exist fuzzer support coverag instrument pretti simple, e.g.

problem:
- let say codebas whole test suit take consider time run.
- need make chang particular section codebase(mayb one function).
- alway want know is; particular testcase/ cover function modify?
way, done modifi function: run particular testcase/ cover function without run whole test suite. cours whole test suit would still ran builders/ci, laptop want run subset test cover function work on.
situat alway find someth hope `go tool cover` would help with.
know propos make possibl answer question; `what testcase/ cover func bar?`,
share usecas case.
(edit) current workaround usually;
```
func Bar(){
+   debug.PrintStack()
}
```
run whole test suit `-v` figur testcas cover `bar` base stacktrace.
>which particular testcase/ cover function modify?
cover detail design document section:

agre tool answer sort queri would realli valuable.
rewrit go linker 1.15/1.16 time frame seem though run situat daili basi (the linker mani "dark corners" execut obscur input build modes, lead mani question form "what test need run order trigger execut function?").
discuss seem trail off. anyth left discuss? anyon object plan?
rob' point compil complexity/port valid, than' "middl ground"---retain source-to-sourc translat standard build runtim interfac coverage---sound like good compromise.
sure want end world two differ coverag mechan maintain, sure middl ground keep - would use old source-to-sourc translator, would maintain it?
llvm gccgo support cmd/cover right now; use coverag built compilers. (it might nice kind adapt gener file cmd/cover build nice html display though.)
anyth need know implement side order decid here? is, want wait cls?
understand than' "middl ground" approach intend proceed chang run-tim interfac (the go packag use within target process, contract packag build tool regard file written), back away compiler-bas instrument keep exist source-to-sourc translat algorithm.
@thanm, think statu propos is? detail flux still need work out?
confirm @adonovan' comment plan stick source-to-sourc compil instrumentation?
>what think statu propos is? detail flux still need work out?
hi, thank "ping".
term design, think thing mostli settl overall. coupl smallish item relat command line api need hash out; process ad detail area design doc, done post updat issue.
term implementation, "go build -cover" work all.bash pass new stuff turn (new design everyth old one did). actual land cl stack yet however.
test "origin" featur intra-lin coverag featurear yet implemented; think point (given releas freez four weeks) need postpon featur go 1.19.
>can confirm @adonovan' comment plan stick source-to-sourc compil instrumentation?
confirmed, still source-to-sourc rewriting, small amount addit "special sauce" done compil build rewritten source. thing way (imo) provid best overal solution.
thanks.
@thanm pleas make sure source-to-sourc translat still use compil suites.
> @thanm pleas make sure source-to-sourc translat still use compil suites.
yes, definit "in plan".
base discuss above, propos seem like **like accept**.
— rsc propos review group
chang mention issue: `proposal: updat code coverag revamp design document`
fyi: progress implement cl move along, point game (less 1 week go releas freeze) seem unlik featur includ 1.19-- want share folk follow along issue. slip go 1.20 probabl good thing long run; allow thorough review trickier part implementation.
also post updat detail design bring align current implement (thi primarili reflect fact new scheme use mix source-to-sourc rewrit compil support).
also tag implement cl issu (now stabil part).
chang mention issue: `cmd: support read coverag counter data files`
chang mention issue: `cmd/compile: add coverag fixup mode`
chang mention issue: `internal/coverage: add api reading/writ counter data`
