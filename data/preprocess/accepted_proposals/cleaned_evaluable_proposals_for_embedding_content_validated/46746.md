reflect: add value.equal, value.compar
go 1.17 introduc convers panic (#395). first case convers panic. mean code call `reflect.type.convertibleto` then, return `true`, call `reflect.value.convert`, see unexpect panic. (see #46730.)
separately, long time possibl comparison panic, compar two interfac valu dynam type dynam type comparable. therefore, long time code call `reflect.type.comparable` then, return true, use `==` oper see unexpect panic. (thi fairli uncommon case problem aris work indirectli access interfac types, pointer interfaces.)
propos ad two new method `reflect.value`.
```Go
// ConvertibleTo reports whether v can be converted to type t.
// If this reports true then v.Convert(t) will not panic.
func (v Value) ConvertibleTo(t Type) bool
// Comparable reports whether the type of v is comparable.
// If the type of v is an interface, this checks the dynamic type.
// If this reports true then v.Interface() == x will not panic for any x.
func (v Value) Comparable() bool
```
one minor observation:
> // report true v.interface() == x panic x.
sure quit right. `x` could interfac contain dynam type comparable. common case, compar two reflect.values, need call compar them. better word suggest.
think statement still true, dynam type `v.interface()` `x` different, comparison `false`, matter whether either dynam type comparable. words, dynam type `v.interface()` comparable, either `x` differ dynam type result `v.interface() == x` `false`, `x` dynam type comparison run without panicking.
ah, indeed. thanks. relev sentenc spec is:
> comparison two interfac valu ident dynam type caus run-tim panic valu type comparable.
have:
```
func (v Value) Addr() Value
func (v Value) CanAddr() bool
func (v Value) Interface() interface{}
func (v Value) CanInterface() bool
```
sound like want add second one these:
```
func (v Value) Convert(t Type) Value
func (v Value) CanConvert(t Type) bool
```
maybe:
```
func (v Value) Equal(u Value) bool
func (v Value) Comparable(u Value) bool
```
compar seem like better name canequ here, equal seem better compar (compar bytes.compare, bytes.equal).
probabl want canconvert least go 1.17.
propos ad activ column propos project
review weekli propos review meetings.
â€” rsc propos review group
base discuss above, propos seem like **like accept**.
â€” rsc propos review group
`value` `comparable`, mean return `interface()` use key map? think `reflect` current way answer question.
(thi clarifi question, comment proposal)
> probabl want canconvert least go 1.17.
still true? window pretti small now.
> valu comparable, mean return interface() use key map? think reflect current way answer question.
assum `map[interface{}]t` (for valu type `t`), yes: `v.comparable()` return `true`, use `v.interface()` key valu map, panic occur.
chang mention issue: `reflect: add value.canconvert`
sent case want 1.17.
chang consensus, **accepted**. ðŸŽ‰
