compress/lzw: add resett interfac allow encod reus
`compress/lzw` encod maintain rather larg tabl (64k) map uncompress byte compress bits. encod requir `close` per stream cannot reus multipl streams. mean lzw creat 64k garbag per use, especi appar encod anim `image/gif`.
can't easili chang api go1 support reuse, greatli reduc garbag pool `table` paramet encoders. prototyp behavior got follow benchmarks:
```
name           old time/op    new time/op    delta
Encoder/1e4-8     108Âµs Â± 1%     109Âµs Â± 2%   +1.25%  (p=0.008 n=9+10)
Encoder/1e5-8    1.06ms Â± 2%    1.11ms Â± 2%   +4.15%  (p=0.000 n=10+9)
Encoder/1e6-8    10.5ms Â± 2%    11.0ms Â± 2%   +4.37%  (p=0.000 n=10+9)
name           old speed      new speed      delta
Encoder/1e4-8  93.0MB/s Â± 1%  91.8MB/s Â± 2%   -1.23%  (p=0.008 n=9+10)
Encoder/1e5-8  94.1MB/s Â± 2%  90.4MB/s Â± 2%   -3.98%  (p=0.000 n=10+9)
Encoder/1e6-8  95.2MB/s Â± 2%  91.3MB/s Â± 2%   -4.18%  (p=0.000 n=10+9)
name           old alloc/op   new alloc/op   delta
Encoder/1e4-8    77.9kB Â± 0%     4.4kB Â± 0%  -94.35%  (p=0.000 n=10+9)
Encoder/1e5-8    77.9kB Â± 0%     4.4kB Â± 0%  -94.33%  (p=0.000 n=10+10)
Encoder/1e6-8    77.9kB Â± 0%     5.0kB Â± 0%  -93.60%  (p=0.000 n=10+10)
name           old allocs/op  new allocs/op  delta
Encoder/1e4-8      3.00 Â± 0%      4.00 Â± 0%  +33.33%  (p=0.000 n=10+10)
Encoder/1e5-8      3.00 Â± 0%      4.00 Â± 0%  +33.33%  (p=0.000 n=10+10)
Encoder/1e6-8      3.00 Â± 0%      4.00 Â± 0%  +33.33%  (p=0.000 n=10+10)
```
(note top exist cl improv time/op significantly)
see much use pool standard library, gener good approach? even is, memori overhead worth 4% perform increase?
pool subtl properti affect perform (see #23199 #22950). #23199 issu sinc object fix size, #22950 advers affect usag pool certain workloads.
said, say:
> can't easili chang api go1 support reus
api return `io.readcloser` `io.writecloser`? similar problem exist `compress/flate` resolv defin `flate.resetter` interface.
pool seem like poor fit use-case, sinc `lzw`' `readcloser` `writecloser` implement document safe concurr use anyway: pool would add contend cach line api otherwis need cross-cor synchronization.
`resetter` interfac seem preferable.
thank insight, `resetter` interfac definit seem like way go.
there' also question `compress/lzw`' main consumer, `image/gif`. intended, would reduc alloc multi-fram gif encod significantly. (with intern modif persist writer call `writeimageblock`. impact single-fram case, complet remov alloc `gif.encodeall`.
one option would `image/gif` `lzw` encod `pool`. sinc encod use intern interfac concern within `lzw`. sinc there' persist encod object seem good way implement `resetter` interfac like `lzw`.
mayb 64k garbag okay imag encoder, case `lzw` chang may enough. (person prefer `image/gif` near 0 quiescent alloc that' nich use case)
stumbl look heap profil gener use ad `resetter` interfac work gener use-cas library. look send cl.
chang mention issue: `compress/lzw: add reset method allow encod reused`
clearli bad job compress apis. return interfac constructors. exampl got zlib.newwrit correct - return \*zlib.writer. got zlib.read wrong - return io.readcloser. want add reset method underli reader, way expos it, ad zlib.resett interfac guarante result io.readclos _also_ implement zlib.resetter.
that' propos lzw, writer side, reader side. bother bit flate.resett zlib.resett read-sid resett would write-sid resetter. happen want reset lzw reader well?
altern defin new interfac would defin actual concret type struct - \*lzw.reader \*lzw.writer - document result lzw.newread lzw.newwrit guarante type-assert- actual concret types. new method need could ad without new interfaces, particular without differ interfac read write differ interfac new method.
thought altern (defin reader writer struct packag document interfac type-assert them, ad reset struct methods)?
/cc @nigeltao
propos ad activ column propos project
review weekli propos review meetings.
â€” rsc propos review group
completeness, imagin two (potenti poor) approaches:
- creat new constructor return concret struct directly. advantag implicit type guarante documented, though obviou downsid addit method.
- allow direct instanti concret struct (similar bytes.buffer). remov need addit method type cast, way allow set field construct without make mutable, could lead nonsens states.
true struct declar initi (bi reset method) would stand alone.
seem like probabl still defin function also return implementations.
propos would be:
```
// guarantee to return a *Reader
func NewReader(r io.Reader, order Order, litWidth int) io.ReadCloser
// guarantee to return a *Writer
func NewWriter(w io.Writer, order Order, litWidth int) io.WriteCloser
type Reader struct { ... unexported ... }
func (r *Reader) Reset(input io.Reader, order Order, litWidth int) 
func (r *Reader) Read([]byte) (int, error)
func (r *Reader) Close() error
type Writer struct { ... unexported ... }
func (w *Writer) Reset(output io.Writer, order Order, litWidth int) 
func (w *Writer) Write([]byte) (int, error)
func (w *Writer) Close() error
```
object approach?
asymmetri `compress/flate` unfortunate, better defin `writerrestter` `readerresetter` interfac types.
@rsc return *writer guarante alway fulfil writecloser? would compat usabl without type assertion?
@andig would technic violat compat guarantee, sinc function variable/argu type current signatur would longer accept new signature? e.g.:
`var f func(r io.reader, order lzw.order, litwidth int) io.readclos = lzw.newreader`
would break propos type signature.
guess would ðŸ˜£
base discuss above, propos seem like **like accept**.
â€” rsc propos review group
play around notic newreader/newwrit current return separ struct (`errwritecloser`) errors, return error later written/read. necessarili requir chang apis, separ struct need incorpor reader/writ struct `err` struct member similar, `reset` set error struct (sinc can't return pseudo-reader/writer).
@rsc - want clarifi small detail reset methods: want pass order litwidth `reset` let whatev reader/writ created?
seem like inconsist amongst variou reset api one.
- gzip.(*writer).reset take compress level.
- flate.(*writer).reset take compress level dictionary.
- flate.resett interfac _does_ take dictionary.
opinion, mistak `gzip` `flate` take options. time need reset differ set unabl to. think avoid mistak ad reset function `lzw`.
@dsnet' point, remov paramet `reset` would also prohibit direct instanti (then `reset`ing) struct (unless valu default value)
> object approach?
lgtm.
answer @agnivade' comment, sound like @dsnet @nigeltao agre includ option reset, comment above.
chang consensus, **accepted**. ðŸŽ‰
