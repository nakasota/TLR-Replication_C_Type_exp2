go/token: add fileset.removefil method
background: `token.fileset` hold collect non-overlap `token.file` provid map token.po integ posit inform (file/line/column/offset). analog way address space contain sever non-overlap file map defin mean numer pointer value. applic pars go file expect use singl fileset provid mean token.po valu asts; way, ast node includ pointer map information, implicitli suppli contextu fileset.
problem: design lead applic creat singl fileset effect ubiquit global variable. long-run applic may encount pars unbound stream files, call addfil one, caus set file grow without bound. fileset retain file indefinitely, even applic longer care it. memori footprint file approxim one int per line file. go sourc file standard librari averag 371 lines, lead 3kb wast space per file. applic (gopls) pars file least per keystrok go developer' editor.
think way memori usag fileset could reduced.
first approach move away concept singl central fileset application. instead one would creat new fileset everi parse, fileset file typic 1:1 correspondence. applic could, needed, creat transient fileset contain small subset exist file necessari given operation, invok type checker. however, would still requir file non-overlapping, requir central manag "next free address" variabl (like sbrk(2) mmap analogy) provid call `fileset.addfile(base)`. would also requir everi call pars go central management, might practic within applic seem feasibl librari publish api considered.
second approach would parser save token.fil everi node ast never need maintain consult extern fileset data structure: ast node' (*file, pos) inform would complete. approach howev requir everi place today use token.po refer file posit (rel impli fileset) would need chang (*file, pos) pair. example, error type checker, diagnost analysi framework. seem like major incompat chang exist libraries.
third, simplest, approach, add `(*fileset).removefile(*file)` method remov file set subsequ queri pos, file, iter return neg result---lik `munmap` mmap analogy. liber portion address space would re-used, file' memori could reclaimed. munmap, applic would respons rememb call removefil appropri time, soon. propos take approach. chang fileset simpl low-risk.
@findleyr @griesem
chang mention issue: `go/token: add (*fileset).removefile(*file) method`
fourth approach (a variant first): fileset.bas replac actual global variabl token package, share filesets; base valu provid fileset.addfil ignored. ensur token.fil inher non-overlapping, permit subset collect transient fileset. words, collect fileset would consist (successful) pos->posit mappings, even repres differ subset files. solv "central management" problem.
theory, downsid approach global counter would grow faster individu fileset.base, (a) practic today one fileset applic (see above!), (b) even case, would still danger overflow int---not 64-bit machin least.
anoth variant first could explicitli share base valu filesets. fileset could carri around. exist fileset api could start unshar base. essenti fourth option pass around [thread safe?] *int fileset creation instead use global. like fourth option realli safe way share base multipl compet parallel fileset pass neg base `addfile`.
sure either fourth option would okay 32-bit machin long run process like gopls.
> anoth variant first could explicitli share base valu filesets. fileset could carri around. exist fileset api could start unshar base. essenti fourth option pass around [thread safe?] *int fileset creation instead use global. like fourth option realli safe way share base multipl compet parallel fileset pass neg base addfile.
valu approach 4 solv "central management" problem without need updat everi caller parse, wherea explicit-shared-bas approach would still requir caller pars participate.
> sure either fourth option would okay 32-bit machin long run process like gopls.
32-bit machine, gopl would run memori long could even attempt pars 2gib worth go sourc files. ;-)
understand worri 1 long run process (gopls) creat file per keystrok exhaust avail po values. understand wrong, rest comment mean much.
back envelop estimate, came 16 hour work overflow global base 32-bit machine. 1<<31 posit * 1/(11074 positions/addfile)* 1 keystroke/addfil * 1/(200 keystroke/minute) roughli 16 hours. 11074 come averag file size go standard library. 1 keystroke/addfil come understand "pars file least per keystrok go developer' editor". 200 keystrokes/minut guess cpm type speed estim ( unless assumpt +1 order magnitud off, seem like enough time gopl process.
> understand worri ... exhaust avail po values.
analysi correct but, no, worri run address space. no-on ever work 200 keystrokes/minut 16 hour straight, pretti sure gopl would crash least tried. also need 2gb ram workloads, laptop 32-bit machine.
worri actual memori consum newlin index tables.
argument sake, keep mind _average_ file size matters, size file changing. sure could find real world exampl larg file otherwis small workspace, exhaust 32 bit address space hour (or perhap minutes!). alan suggests, develop scenario unlik varieti reasons, practic workflow would encount problems.
ad minutes. seem like mani mani part go/* packag assum batch mode stress near break interact use. wonder look togeth instead one api time.
propos ad activ column propos project
review weekli propos review meetings.
â€” rsc propos review group
> seem like mani mani part go/* packag assum batch mode stress near break interact use.
that' definit true, think decoupl propos larger changes. long time stop use token.fileset gopls, yet unavoid memori leak real consequ user today. (consid that, work larg file ~10k lines, gopl leak 100kb _per keystroke_).
base discuss above, propos seem like **like accept**.
â€” rsc propos review group
chang consensus, **accepted**. ðŸŽ‰
