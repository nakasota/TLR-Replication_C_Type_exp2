reflect: optim v.set(reflect.zero(v.type())) alloc
`value` api lack effici way zero value. currently, one `v.set(reflect.zero(v.type()))`. however, effici sinc `reflect.zero` may need alloc larg object, also `reflect.value.set` use `runtime.typedmemmove` hood instead effici `runtime.typedmemclr`.
propos ad `reflect.value.setzero` method effici way set valu zero value.
would also like see ad want give context big effect use case:
came across "inefficiency" also recent look code proto sanit log write wipe sensit field therefor need "unset"/"wipe" proto field zero value. use reflect structs. creat zero valu show profil non trivial amount time memori allocation. futur new proto api might provid better method might also abl need effici reflect method hood.
> futur new proto api might provid better method might also abl need effici reflect method hood.
heh. ironically, file issu tri optim intern protobuf implement figur effici this.
given `v.set(reflect.zero(v.type()))`, place ineffici happen v.type() valu larger singl word, reflect.valu contain pointer zero allocation.
think could chang represent reflect.valu defin pointer nil, interpret point appropri number zero bytes. idiom question start effici without chang client code, new api learn, on.
chang seem like could done complet invisibly. valu contain nil pointer could addressable, result reflect.zero address anyway, problem.
think invis optim instead new api?
tri simpl version optim save 75% time benchmark. idea seem worth pursuing. @dsnet plausibl benchmark kind code concern about?
(it' tini chang reflect package, diffstat report 159 insertions, 35 deletions.)
```Go
func BenchmarkZero(b *testing.B) {
	t := TypeOf(struct {a, b, c, d *byte}{})
	v := New(t)
	for i := 0; i < b.N; i++ {
		v.Elem().Set(Zero(t))
	}
}
```
cl experi take spin?
@dsnet
chang mention issue: `reflect: treat nil valu ptr zero valu type`
runtim alreadi 1k region zero use back store result reflect.zero.
chang would simpl as:
```
	if ifaceIndir(t) {
		var p unsafe.Pointer
		if t.size <= maxZero {
			p = unsafe.Pointer(&zeroVal[0])
		} else {
			p = unsafe_New(t)
		}
		return Value{t, p, fl | flagIndir}
	}
// Buffer of zeros. We could share this with runtime.zeroVal with linkname tricks, or keep it separate.
const maxZero = 1024
var zeroVal [maxZero]byte
```
could also detect particular buffer `set` use `typedmemclr` instead `typedmemmove`.
would requir alloc >1k case, think rare.
also big ineffici packag like encoding/json. pleas let know cl readi happi help review test.
done without new api, better :)
chang mention issue: `reflect: use zero buffer back valu return zero`
@dsnet want one chang go 1.14, pleas benchmark real code. thanks.
seem like propos stall decid whether possibl make `v.set(reflect.zero(v.type()))` effici (bi recogn library, compiler) propos `v.setzero()`, avoid new api surface.
@dsnet, either ian' keith' patch (both above) work well enough you?
use case origin need longer relevant. perhap one :+1:' could comment?
cl simpler perform discontinu depend size.
ian' invas handl sizes.
briefli mention `encoding/json` last year - particular, set reflect valu zero three places:
```
$ grep -nE 'Zero.*Type' *.go
decode.go:601:			z := reflect.Zero(v.Type().Elem())
decode.go:708:				mapElem.Set(reflect.Zero(elemType))
decode.go:917:			v.Set(reflect.Zero(v.Type()))
```
travel moment, can't spend time test cl current set decode/unmarsh benchmarks. look next week, noon beat it. quick look, seem be, respectively:
* zero remain array element (unlik path)
* zero map element valu reus decod (hot path decod maps)
* zero valu decod `null` (depend input)
hunch json often involv smaller types. one decod huge types, plenti piec decod would start get slow, think extra alloc would matter. default keith' simpler cl, perhap archiv ian' case anyon strong need future.
sound like ian' chang complet one signific perform problems, probabl go that.
base discuss lack api change, seem like **like accept**.
think good fill ian' chang choos keith' confirm meaning perform side-effect as-yet-unimpl runtim changes. chang prognosi proposal, possibl implement should.
chang consensu accepted.
(for clarity, there' api chang here, idea start optimization, would need propos process.)
chang mention issue: `[release-branch.go1.16] doc: describ zero optim might chang result incorrect reflect.valu comparison`
chang mention issue: `doc: describ zero optim might chang result incorrect reflect.valu comparison`
