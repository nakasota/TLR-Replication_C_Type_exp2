=== Fetching Proposal: MDU6SXNzdWUzNjMzNjQ2OTY= ===
Issue URL: https://github.com/golang/go/issues/27837

==== [Issue Title] ====
x/sync/errgroup: add TryGo and SetLimit to control concurrency

==== [Issue Body] ====
The errgroup package will currently spawn a new goroutine for each invocation of Group.Go.  This is usually fine, but extremely high cardinality fanout can exhaust memory or other resources.  It would be neat if the errgroup interface allowed users to specify the maximum number of concurrent goroutines they want the errgroup to spawn.

## Proposal

```go
type Group struct {
  N int
  // contains etc
}
```

N would be copied to an unexported on the first invocation of Go, so that subsequent modification has no effect.  This preserves the validity and the behavior of the empty Group.

When calling Go, if the number of functions running is > N then Go would block until the number was <= N.

The behavior of Go is not otherwise modified; if a subtask returns an error, then subsequent tasks will still be executed, and callers would rely on subtasks handling context cancellation to fall through to the Wait() call and then return, if WithContext was called.

## Alternatives considered

An alternative interface would be that Go never block, but enqueue instead.  This is an unbounded queue and I'm not a fan.

Another alternative is that the group is context-aware, and that Go return immediately if the group's context is cancelled.  This requires that Group retain a reference to the context, which it does not currently do.

==== [Comments] ====

--- Comment #1 by mdlayher ---
/cc @bcmills who recently was thinking about some changes to this package IIRC

--- Comment #2 by kevinburke ---
In the meantime I'd suggest using a buffered channel before calling group.Go() and releasing it when the function returns, or using a package like github.com/kevinburke/semaphore to acquire resources before starting a goroutine.

--- Comment #3 by bcmills ---
There is a draft API In slide 119 (in the backup slides) of my GopherCon 2018 talk, [Rethinking Classical Concurrency Patterns](https://drive.google.com/file/d/1nPdvhB0PutEJzdCq5ms6UI58dp50fcAN/view).

I agree that the `Go` method should block until it can begin executing the function, not enqueue: enqueuing tasks to a bounded executor is much too prone to deadlocks.

I propose a new `TryGo` method as a non-blocking alternative. (A non-blocking variant is mostly useful for â€œconcurrency-saturatingâ€ operations like tree or graph traversals, where you want to keep the number of concurrent workers as high as possible but can fall back to sequential operation when saturated.)

I would rather have a `SetLimit` method than an exported field: that way we can more easily enforce invariants like â€œthe limit must not be modified while goroutines are runningâ€.

--- Comment #4 by fatih ---
I also needed something similar and combined it with `golang.org/x/sync/semaphore`. Here is an example on how I'm using it. It limits the number of simultaneous execution based on the variable `maxWorkers`:

```go
func main() {
	const maxWorkers = 5
	sem := semaphore.NewWeighted(maxWorkers)

	g, ctx := errgroup.WithContext(context.Background())
	for i := 0; i < 50; i++ {
		i := i
		fmt.Printf("executing %d\n", i)

		g.Go(func() error {
			err := sem.Acquire(ctx, 1)
			if err != nil {
				return err
			}
			defer sem.Release(1)

			// do work
			time.Sleep(1 * time.Second)
			fmt.Printf("finished %+v\n", i)
			return nil
		})
	}

	if err := g.Wait(); err != nil {
		fmt.Printf("g.Wait() err = %+v\n", err)
	}

	fmt.Println("done!")
}
```

If  anything in this approach wrong please let me know. Seems like it works fine based on the debug statements.

--- Comment #5 by alexaandru ---
@fatih I would personally put the `Acquire()` outside/in front of the goroutine. The way you have it, it does NOT prevent the **launching** of 50 simultaneous goroutines, it only prevents them to actually do their work for more than `maxWorkers` at a time.

Look at it another way, if instead of 50, you had 1m, what your code does is launch 1m goroutines. Of them, `maxWorkers` goroutines will actuall do the work (well, in this case sleep), while `1m - maxWorkers` of them will ALL attempt to acquire the lock (that sits behind the semaphore abstraction).

All the best!

--- Comment #6 by fatih ---
@alexaandru thanks for the tip! You're right about that. I've fixed that actually on my end (https://twitter.com/fatih/status/1152991683870633985 and https://play.golang.org/p/h2yfBVC8IjB) but I forgot to update it here.

--- Comment #7 by alexaandru ---
You're most welcome @fatih ! Cheers! :) 

--- Comment #8 by tschaub ---
Another subtle issue that ideally would be solved by having an errgroup with a limit is that it is very easy to write code using `errgroup` and `semaphore` that swallows significant errors and instead returns only `context.Cancelled`.

For example, it might be non-obvious that the `work` function below returns `context.Cancelled` instead of `errors.New("important message here")`:
```go
const (
	maxWorkers = 10
	numTasks   = 1e6
)

func work() error {
	group, ctx := errgroup.WithContext(context.Background())
	sem := semaphore.NewWeighted(maxWorkers)

	for i := 0; i < numTasks; i++ {
		if err := sem.Acquire(ctx, 1); err != nil {
			return err
		}

		group.Go(func() error {
			defer sem.Release(1)

			time.Sleep(1 * time.Second)
			if rand.Float64() > 0.5 {
				return errors.New("important message here")
			}

			return nil
		})
	}

	return group.Wait()
}
```

The code can be fixed with something like this, but it is easy to forget
```diff
diff --git a/main.go b/main.go
index 7690b92..9f64dbc 100644
--- a/main.go
+++ b/main.go
@@ -21,6 +21,10 @@ func work() error {
        sem := semaphore.NewWeighted(maxWorkers)
 
        for i := 0; i < numTasks; i++ {
+               if ctx.Err() != nil {
+                       break
+               }
+
                if err := sem.Acquire(ctx, 1); err != nil {
                        return err
                }
```

--- Comment #9 by bcmills ---
@tschaub, note that in general anything that may produce an error _as a result of_ `errgroup` cancellation should be run within the `errgroup` itself.

So that example would probably be clearer as:

```diff
const (
	maxWorkers = 10
	numTasks   = 1e6
)

func work() error {
	group, ctx := errgroup.WithContext(context.Background())
+
+	group.Go(func() error {
		sem := semaphore.NewWeighted(maxWorkers)

		for i := 0; i < numTasks; i++ {
			if err := sem.Acquire(ctx, 1); err != nil {
				return err
			}

			group.Go(func() error {
				defer sem.Release(1)

				time.Sleep(1 * time.Second)
				if rand.Float64() > 0.5 {
					return errors.New("important message here")
				}

				return nil
			})
		}
+	})

	return group.Wait()
}
```

--- Comment #10 by smasher164 ---
We came across this use-case today, and used a semaphore channel instead of x/sync/semaphore. But since context is heavily threaded through, we'll probably switch to using x/sync/semaphore.

Regarding the proposed API, `SetLimit` makes sense with existing errgroup API, but `TryGo` always succeeds when there is no limit. Would there be a clearer separation with a `LimitGroup` type, which is instantiated with `WithContextLimit`?

--- Comment #11 by cbozen ---
> We came across this use-case today, and used a semaphore channel instead of x/sync/semaphore. But since context is heavily threaded through, we'll probably switch to using x/sync/semaphore.
> 
> Regarding the proposed API, `SetLimit` makes sense with existing errgroup API, but `TryGo` always succeeds when there is no limit. Would there be a clearer separation with a `LimitGroup` type, which is instantiated with `WithContextLimit`?

Hello, I just created a package for that : https://pkg.go.dev/github.com/cboudereau/errgroupsem in order to use it as quick as possible on our side but feel free to discuss in order to merge both versions :). The one with WaitGroup.Go does not offer the same error management in a fail fast way like the Wait() function actually does in errgroup.

--- Comment #12 by thepudds ---
Some related discussion here, including several people chiming in to comment that they felt the need to implement something similar:

https://mobile.twitter.com/fatih/status/1499722289625063427

--- Comment #13 by rsc ---
@bcmills do you think there is new API that should be added to errgroup along these lines? If so, what is it?


--- Comment #14 by rsc ---

This proposal has been added to the [active column](https://golang.org/s/proposal-status#active) of the proposals project
and will now be reviewed at the weekly proposal review meetings.
â€” rsc for the proposal review group


--- Comment #15 by bcmills ---
Taking the API I drafted for my GopherCon 2018 talk and adding documentation, I suggest:

```go
package errgroup

// SetLimit limits the number of active goroutines in this group to at most n.
// A negative value indicates no limit.
//
// Any subsequent call to the Go method will block until it can add an active
// goroutine without exceeding the configured limit.
//
// The limit must not be modified while any goroutines in the group are active.
func (*Group) SetLimit(n int)

// Go calls the given function in a new goroutine.
// It blocks until the new goroutine can be added without the number of
// active goroutines in the group exceeding the configured limit.
//
// The first call to return a non-nil error cancels the group; its error will be returned by Wait.
func (*Group) Go(f func() error)

// TryGo calls the given function in a new goroutine only if the number of
// active goroutines in the group is currently below the configured limit.
//
// The return value reports whether the goroutine was started.
func (*Group) TryGo(f func() error) bool
```

--- Comment #16 by bcmills ---
With the above API, I have one open question: if the group is already cancelled, should `TryGo` return `false` (and avoid starting the goroutine) if the group is already canceled due to an earlier error?

--- Comment #17 by seh ---
Should there be a variant of `(*Group).Go` that accepts a `context.Context` to limit the amount of time a caller is willing to wait? The proposal here introduces `(*Group).TryGo` to not wait at all, and `(*Group).Go` threatens to block for a long time. In between lies "try to start a goroutine but don't try for longer than this `Context` is incomplete (not done)."

--- Comment #18 by timothy-king ---
@bcmills What would `func (*Group) SetLimit(n int)` do for `n == 0`?

--- Comment #19 by bcmills ---
@timothy-king, I would say that `g.SetLimit(0)` should cause all calls to `Go` to hang and all calls to `TryGo` to return false.

(Perhaps that's an argument for allowing calls to `SetLimit` concurrent with `Go` and `TryGo`? ðŸ˜…)

--- Comment #20 by bcmills ---
@seh, I'm not sure what the use-case would be for a variant that accepts a `context.Context`. Could you give some examples?

It seems to me that the main use-case for `TryGo` is for parallel traversals of trees and graphs, where you might start a goroutine per child as long as you have the budget for it and then switch to something synchronous (depth-first or breadth-first) once the limit is saturated. (That in and of itself is fairly esoteric, though.)

--- Comment #21 by seh ---
> Could you give some examples?

Say that I'm in a function being called on with a supplied `Context` argument, and I generate some number of subtasks that I'd like to run concurrently. I start spawning these via `(*Group).Go`, but then I run up against the configured task limit, and now I'm blocked.

Then, my caller cancels the `Context`. Ideally the tasks that I spawned are also paying attention to the same or a child `Context` and can each then give up quickly, but I'd like to be able to unblock my own goroutine to return more promptly.

Another thing made possible by supplying a `Context` is to be able to express, "I'll wait up to _some duration_ to start a child task, but if I can't within that period, I'll just do it myself in my own goroutine." That is, it may not be worth waiting any longer. You'd lose out on the coordinated cancelation upon seeing the first error among the group's tasks if you decided not to bother waiting any longer, but it would allow more control for the caller.

--- Comment #22 by tschaub ---
@seh - I've found the same need and use https://pkg.go.dev/github.com/tschaub/limited.  The `Go` func conditionally returns an error (for example if the context is cancelled).  This is different behavior from packages like https://pkg.go.dev/golang.org/x/sync/semaphore where acquiring a semaphore may succeed even if the associated context is cancelled.  I imagine there is good reason for this, but I find myself always working around it, so wanted a way to more conveniently stop doing work on context cancellation.

--- Comment #23 by rsc ---
 >With the above API, I have one open question: if the group is already cancelled, should TryGo return false (and avoid starting the goroutine) if the group is already canceled due to an earlier error?

It seems like TryGo returning false should be an indication that Go would block. If Go would silently not run the function, it seems like TryGo should return true and silently not run the function too.

Other than this detail, are people happy with the API adding SetLimit and TryGo?

--- Comment #24 by kurin ---
Super bikeshed, but I don't suppose we could just call "TryGo" "Try"?

--- Comment #25 by bcmills ---
> If Go would silently not run the function, it seems like TryGo should return true and silently not run the function too.

The `Go` method currently always runs the function (unconditionally), and I would prefer not to change that.
If the group has already failed, the `Context` associated with the group (if any) is already canceled at the start of the invocation, so we expect the function call to complete quickly.

So there isn't really a consistency argument for the `TryGo` behavior, I don't think: there is no analogous situation for `Go` because that method _never_ has the option to avoid running the function.

--- Comment #26 by rsc ---
TryGo returning false should probably mean just "you're at the limit" and not "you're at the limit or else something has failed". So probably TryGo should do what Go does and run the function with the cancelled context.

It should be the case that if you have something using Go and then you do SetLimit(1e12) and change all the Go to TryGo, you don't get any changes in behavior, I would think.



--- Comment #27 by rsc ---
Re TryGo vs Try, I think keeping "Go" is clearer. What if we add TryWait later? And it lines up with TryLock etc.


--- Comment #28 by rsc ---

Based on the discussion above, this proposal seems like a **[likely accept](https://golang.org/s/proposal-status#likely-accept)**.
â€” rsc for the proposal review group


--- Comment #29 by changkun ---
I got an implementation concern that this proposal may have a behavior change and break some code. According to the document:

```
// ...
// A zero Group is valid and does not cancel on error.
type Group struct
```

Hence we can use `errgroup` as follows:

```
g := &errgroup.Group{}
```

What is the default maximum allowed concurrency? If we add a field to `Group` and use a negative value to indicate no limit:

```
type Group struct {
	max int64 // maximum allowed concurrency
	...
}
```

Using `WithContext` seems fine:

```
func WithContext(ctx context.Context) (*Group, context.Context) {
	ctx, cancel := context.WithCancel(ctx)
	return &Group{cancel: cancel, max: -1}, ctx
}
```

But according to https://github.com/golang/go/issues/27837#issuecomment-1087904260, and the proposed SetLimit behavior:

```
// SetLimit limits the number of active goroutines in this group to at most n.
// A negative value indicates no limit.
// ...
func (*Group) SetLimit(n int)
```

It seems for users who already have their usage like the following

```
g := &errgroup.Group{}
```

will block forever after implementing the concurrency control, because the default `max` will be 0, and `Go` will never run a given task. Did I miss anything?

--- Comment #30 by gopherbot ---
Change https://go.dev/cl/404515 mentions this issue: `x/sync/errgroup: add TryGo and SetLimit to control concurrency`
