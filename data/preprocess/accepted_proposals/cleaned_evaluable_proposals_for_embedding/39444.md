os: export errfinish errprocessdon
linux, kill() return possibl errors:
[einval]
valu sig argument invalid unsupport signal number.
[eperm]
process permiss send signal receiv process.
[esrch]
process process group found correspond specifi pid.
os.sign function work go:

```Go
func (p *Process) signal(sig Signal) error {
	if p.Pid == -1 {
		return errors.New("os: process already released")
	}
	if p.Pid == 0 {
		return errors.New("os: process not initialized")
	}
	p.sigMu.RLock()
	defer p.sigMu.RUnlock()
	if p.done() {
		return errFinished
	}
	s, ok := sig.(syscall.Signal)
	if !ok {
		return errors.New("os: unsupported signal type")
	}
	if e := syscall.Kill(p.Pid, s); e != nil {
		if e == syscall.ESRCH {
			return errFinished
		}
		return e
	}
	return nil
}
```
return privat errfinish instead public esrch ?
can't write custom logic like this:
```Go
err := process.Kill()
if err == syscall.ESRCH {
  // process already finished do something
}
```
okay error custom name, private? errfinished, errfinished?
return `errfinished` `esrch` realli seem right process alreadi exited. also see #7658.
realli need distinguish cases, mean alreadi unix-specif things, recommend use `syscall.kill(process.pid, syscall.sigkill)`.
> return `errfinished` `esrch` realli seem right process alreadi exited. also see #7658.
>
> realli need distinguish cases, mean alreadi unix-specif things, recommend use `syscall.kill(process.pid, syscall.sigkill)`.
thank answer, that' make point. wish use os.signal, alreadi lot' use logic like rw-lock pid checking. use raw ```syscall.kill(process.pid, syscall.sigkill)```, need implement logic own, application.
disadvantag make errfinish public?
ok, turn propos export `errfinished`.
littl hesit export errfinish name, sinc gener "someth finished". also hard time come better name. wait man page say "wait process termination" could use errprocesstermin that' keep name os (too long, also specific).
@ianlancetaylor point mayb could use errnotexist, perhap could keep use errfinish make errors.is(errfinished, errnotexist) true.
thoughts?
note last week, seem like least api surfac would make errfinish errors.is(..., errnotexist). retitl that. anyon object that?
mean `os.isnotexist(err) == true` os.errfinished? could surprising, sinc former filesystem errors. mani situations, `os.isnotexist(err)` normal condition.
expect signal process-rel api return error specif processes.
cc @alexbrainman @bcmill @aclement
think method call grammat terms, expect `os.errnotexist` indic “the direct object (of verb) exist”:
* `os.errnotexist` `stat(f)` indic “could `stat` [verb] `f` [direct object] `f` exist.”
* `os.errnotexist` `open(f)` indic “could `open` [verb] `f` [direct object] `f` exist.”
propos usag would consist that, requir reader treat name method verb (a should, may alway do).
* “could `signal` [verb] `p` [direct object] `sig` [object preposition] `p` exist.”
* “could send [verb] `signal` `sig` [direct object] `p` [indirect object] `sig` exist.”
hand, error text `os.errnotexist` specif document `file exist`, @networkimprov notes, file involv `signal` unless consid pid file. would expect user make association.
think gener standard error “[direct object] exist” could useful, agre that, specif text, `os.errnotexist` _quite_ error.
@bcmills, clear cut say. surpris f.stat() could return errnotexist certain case (those case includ "local file unix"). event, like clear caller signal exist.
hand, errnotexist.string() "file exist", that' show-stopper.
errprocessdone? (at least establish done context, shorter finished)
respons errprocessdone, seem like peopl gener ok export error.
given lack objections, sound like **like accept**.
chang consensus, accepted.
chang mention issue: `os: export errfinish errprocessdone`
chang mention issue: `doc/go1.16: document os packag changes`
