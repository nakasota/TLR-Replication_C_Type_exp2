math/big: add int.fillbyt
implement cryptography, need almost alway fix size buffer repres valu big endian. `math/big.int.bytes` provid variabl size buffer, place snippet code `make`, `bytes` `copy` `len` depend index. implement one day saw one x/crypto/acme.
will bet everi `bytes` invoc crypto packag someth similar. also learn random bug occur approxim everi 256 execut probabl due miss step, found bug wild least twice.
propos solv math/big api level, add `(*math/big.int).byteswithsize`.
```
// BytesWithSize returns the absolute value of x as a big-endian
// byte slice of length size. If x doesn't fit in such a buffer,
// BytesWithSize will panic.
func (x *Int) BytesWithSize(size int) []byte {
	b := x.Bytes()
	switch {
	case len(b) > size:
		panic("math/big: value won't fit requested size")
	case len(b) == size:
		return b
	default:
		buf := make([]byte, size)
		copy(buf[size-len(b):], b)
		return buf
	}
}
```
strong opinion `len(b) > size` behavior. use crypto packag alway know upper bound, cross might well panic someth went catastroph wrong. (and current code would either panic silent truncate, worse.)
/cc @griesem @katiehockman
would make sens provid byte slice avoid copy?
```Go
func (x *Int) AsBytes(buf []byte)
```
yes, like @griesemer' design. panic ok documented. nil argument could allocate, perhaps?
is, provid buffer must big enough; otherwis one allocated.
oh, like that!
nil argument behavior would make sens bytes, that' stay.
fan fact one can't realli tell base name (byte vs. asbytes) better suggestions. mayb `byteswithbuffer`? mouth hope clear? `writebytes`?
`tofixedbytes`? sinc differ `bytes` write fixed-s array (with left padding).
> `writebytes`?
usual name would read, write ðŸ˜‰
origin thought also `read`, name suggest there' result `(n int, err error)` well perhap overkill, especi never expect error care `n` sinc buffer 0-padded. also, given `read` method, one would expect client abl call `read` repeatedli get byte `int`, case.
mayb `fillbytes` like `asbytes`? former impli "action" (of fill bytes) rather function call (that return value) latter.
like `fillbytes`, thank you!
```
// FillBytes sets buf to the absolute value of x in big-endian, zero
// padded as necessary. If x doesn't fit in buf, FillBytes will panic.
func (x *Int) FillBytes(buf []byte)
```
```
// FillBytes sets buf to the absolute value of x, storing it as a zero-extended
// big-endian byte stream. If the encoded value doesn't fit in buf, FillBytes will panic.
func (x *Int) FillBytes(buf []byte)
```
littl unsettl absolut valu thing, that' byte does.
> littl unsettl absolut valu thing, that' byte does.
same, hand everi way encod neg number know went terribl wrong, see choic come from.
base discussion, sound like **like accept**.
leav open week final comments.
final comments, accepted.
chang mention issue: `math/big: add (*int).fillbytes`
implement cl 230397.
note made fillbyt return buffer, nicer use call site updated. let know object that.
fix c9d5f60eaa4450ccf1ce878d55b4c6a12843f2f3, reason close this.
sorri comment earlier, ask `append`-styl api use here? saw signature:
```go
func (*Int) FillBytes(buf []byte) []byte
```
would assum behav like `(hash.hash).sum` (and friends), i.e. `fillbytes(nil)` equival `bytes()`. given return slice, certainli expect panic.
think chang behavior now, unfortunately, mayb `appendbytes` warranted...?
@lukechampin api specif addressing, perform advantag save allocation, need fill fixed-s buffer possibl shorter big.int, big.int innat size. way append-lik api.
ah, big-endianness, right. thank clarification.
