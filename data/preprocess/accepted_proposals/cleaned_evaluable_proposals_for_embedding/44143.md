all: document use context.background api
# object
amend non-root `context.background()` use standard distribut `context.todo()`.
central purpos go sourc code serv prime exampl correct context usag newcom better teach user retrofit support after-the-fact.
# definit
classic programâ€™ root are: func main, test functions, func init. effect entrypoint user code begin outsid top-level variabl declarations.
# background
context api debut 2014 becam part standard distribut releas 1.7.
mani api context-cap predat api retrofit support introduct function name suffix â€œcontextâ€ indic â€œthi context-cap variantâ€. exampl `(*sql.db).queryrow` `(*sql.db).queryrowcontext`. larg due go 1 compat guarantee, meant backward compat could broken.
problem user alway respect guidanc associ `context.background`
> background return non-nil, empti context. never canceled, values, deadline. typic use main function, initialization, tests, top-level context incom requests.
instead use `context.background` deep call graph instead propag context outward proper scope valu required. infeasible, `context.todo` precis tool use. wit:
> todo return non-nil, empti context. code use context.todo unclear context use yet avail (becaus surround function yet extend accept context parameter).
amend standard distribution, effect provid solid affirm use `context.todo` help reifi design counsel. sever addit knock-on benefit encourag design production-correct -scalabl apis, requir system correctli predict handl load interrupt (e.g., avoid unbound memori usage).
# scale requir
replac default context introduc behavior delta exist users. further, regress performance. neither problem practic product code. would extrem unconvent end-us develop infrastructur develop care context identity.
```go
// This is almost entirely inconceivable.
if ctx == context.Background() {
```
approxim 53 non-test, non-vendor usag `context.background` `/usr/local/go` `go version go1.15.8 linux/amd64`:
```shell
$ grep -r 'context.Background()' | grep -v -E '(testdata|^vendor|_test\.go)' | wc -l
53
```
outsid request-scop context (no pun-intended) like `packag http` use initi client call handl extern requests, litmu test root context like fail standard distribution. eight `context.background` call probabl excusable.
# propos solut
audit call `context.background` swap `context.todo` clearli root oper could real rubric count one. litmu test:
transit function call made follow root cancelable, `context.todo` appropriate:
```go
type Server struct {
  db *sql.DB
}
func (s *Server) ServeHTTP(w http.ResponseWriter, r *http.Request) {
  ctx, cancel := context.WithCancel(r.Context())  // implied that middleware may deadline
  defer cancel()
  rows, err := s.DB.Query(q)  // extremely like the user would want this to be canceable
}
```
intern `(*sql.db).query` call `(*sql.db).querycontext` `context.background`. user want cancel would use `(*sql.db).querycontext`.
case grpc (with code supra):
```go
func (s *Server) Echo(ctx context.Context, req *echopb.EchoRequest) (*echopb.EchoResponse, error) {
  // store echo queries in an audit log to satisfy the auditors
  rows, err := s.DB.Query(q)  // extremely like the user would want this to be canceable
}
```
sure, `context.todo` code wonâ€™t miracul becom cancel (that' point). curiou gopher may compar two implement (e.g., `(*sql.db).query` `(*sql.db).querycontext`), see `context.todo`, prompt consid semant fit design. prevent deprec non-context-correct older public api variant standard distribut (though someth iâ€™v thought lot years).
# altern consid
defect report/propos motiv incorrect code user code, classic purview static analysi someth report, think would best go took medicin appli advic correctli itself. ;) appeal author happen, go sourc tree semi-canon statu mindset user base.
/cc: @jadekl (apropo text work on)
think make much sens stdlib approx 60 case `context.background()` appear non test code. almost use expos api take context
- ambigu context use, none avail user explicitli ask block function
- can't "not yet available" compat promis
cc @sajmani
> can't "not yet available" compat promis
maybe? mani case deprec old api provid parallel new api _does_ accept context. (consid `http.newrequest` vs. `http.newrequestwithcontext`.)
sens realli `todo` â€” either user need call someth els fill context (such `(*net/http.request).withcontext`), api need augment and/or deprecated.
fwiw seem like good way lead exampl wrt `context.todo` used, easi (if bit toilsome) change, downsides.
like idea, want know turn action guidanc user. example, suppos tool notic function context paramet transit call context.todo(). case, user like want "plumb" context context.todo(). @bcmill point out, probabl mean switch interven function call version take context parameter. seem like tractabl problem (and iirc peopl also tri creat automat refactor tool context plumbing), want avoid confus user read code get notic transitively-reach context.todo() without guidanc instead.
mull smaller propos add section godoc entri packag context explain retrofit techniques, `context.todo` mean context retrofitting, etc. high-level sketch, think would satisfi desir action guidance?
come (a sketch) document retrofitting:
```go
// TODO returns a non-nil, empty Context. Code should use context.TODO when
// it's unclear which Context to use or it is not yet available (because the
// surrounding function has not yet been extended to accept a Context
// parameter).
//
// Retrofitting Context Support onto APIs
//
// Retrofitting means adding a context to an API that otherwise did not
// originally have support for it. Suppose we want to retrofit a function
// called Load:
//
//      // Load reads data from the network.
//      func Load() ([]byte, error) {
//              // ...
//      }
//
// Updating a function usually requires updating its callers. This means a new
// API should be introduced that supports it. Conventionally it is the original
// name with the word "Context" appended to its end.
//
//      // LoadContext reads data from the network subject to context
//      // cancellation.
//      func LoadContext(ctx context.Context) ([]byte, error) {
//              // ... use ctx ...
//      }
//
// Afterwards the old Load function should be updated to call the new
// LoadContext function. When Load does, it should pass context.TODO()
// for the context argument.
//
//      // Load reads data from the network.
//      func Load() ([]byte, error) {
//              return LoadContext(context.TODO())
//      }
//
// Callers of Load can incrementally be upgraded to LoadContext. If the callers
// do not have access to a context already, they should use context.TODO(). The
// retrofitting process continues until the APIs reach a function with a
// suitably-scoped context not derived from context.TODO().
//
// Maintainers may optionally deprecate the old APIs that they have
// retrofitted.
//
//      // Load reads data from the network.
//      //
//      // Deprecated: Please use LoadContext instead and provide a context.
//      func Load() ([]byte, error) {
//              return LoadContext(context.TODO())
//      }
func TODO() Context {
        return todo
}
```
put modest work text particularli attach exact phrasing.
think worth ad explanatori text like
context.todo; suggestions*, direct correct.
sure whether text belong godoc separ refer doc
link there.
*the exampl function parameters, clear context
convent ad first parameter. also, make clear
foocontext variant name use retrofitting;
peopl includ context name function
take context parameter.
tue, feb 9, 2021 5:09 pm matt t. proud <notifications@github.com>
wrote:
> come (a sketch) document
> retrofitting:
>
> // todo return non-nil, empti context. code use context.todo when// unclear context use yet avail (becaus the// surround function yet extend accept context// parameter).//// retrofit context support onto apis//// retrofit mean ad context api otherwis not// origin support it. suppos want retrofit function// call load://// // load read data network.// func load() ([]byte, error) {// // ...// }//// updat function usual requir updat callers. mean new// api introduc support it. convent original// name word "context" append end.//// // loadcontext read data network subject context// // cancellation.// func loadcontext(ctx context.context) ([]byte, error) {// // ... use ctx ...// }//// afterward old load function updat call new// loadcontext function. load does, pass context.todo()// context argument.//// // load read data network.// func load() ([]byte, error) {// return loadcontext(context.todo())// }//// caller load increment upgrad loadcontext. callers// access context already, use context.todo(). the// retrofit process continu api reach function a// suitably-scop context deriv context.todo().//// maintain may option deprec old api have// retrofitted.//// // load read data network.// //// // deprecated: pleas use loadcontext instead provid context.// func load() ([]byte, error) {// return loadcontext(context.todo())// }func todo() context {
> return todo
> }
>
> put modest work text particularli attach
> exact phrasing.
>
> â€”
> receiv mentioned.
> repli email directly, view github
> <
> unsubscrib
> <
> .
>
> caller `load` increment upgrad `loadcontext`.
see also #32816.
mani use context.background could theori chang context.todo, never go "do" changes. make look like there' work can't. (for exampl dial vs dialcontext.) sure see benefit make code look like work isn't. believ routin document use background context.
mayb would make sens proceed clearer doc instead?
propos ad activ column propos project
review weekli propos review meetings.
â€” rsc propos review group
discuss @mattproud bit last week.
sound like main thing need document clearli routin standard librari use context.background intern (and alway that).
may room doc explain use todo migrat ad contexts, might separ doc rather long doc comment packag context.
point, what' left need go propos process. fine send cl comments.
kind comment imagin would be:
// dial use context.background internally; specifi context, use dialcontext.
chang consensus, **accepted**. ðŸŽ‰
