unicode/utf8: add appendrun
exist `utf8.encoderune` user friendly.
analyz usag modul proxy, usag fall approxim two patterns.
### pattern 1: encod increment total length
```go
var n int
b := make([]byte, ...) // make with a length that is hopefully large enough
for _, r := range ... {
    n += utf8.EncodeRune(b[n:], r)
}
return b[:n]
```
pattern start buffer larg enough call `utf8.encoderune` directli write buffer increment total known length.
pattern danger especi prone panicking. assum `b[n:]` alway larg enough (most code check make sure least 4b available). even worse, bug rare manifest unlik occur unless unit test write larg number multi-byt runes.
### pattern 2: append slice intermedi array
```go
b := make(]byte, 0, ...) // optionally provide some capacity 
for _, r := range ... {
    var arr [utf8.UTFMax]
    n := utf8.EncodeRune(arr[:], r)
    b = append(b, arr[:n]...)
}
```
pattern much safer pattern 1 never panics. however, 1) incur perform penalti encod intermedi array append primari buffer, 2) requir 3 line code instead 1.
### preval
two common patterns:
* least ~25% pattern 1,
* least ~15% pattern 2,
* remain ~60% seem mostli either pattern 1 pattern 2, unfortun simpl pattern matcher fail classifi them.
### propos
sinc pattern 1 2 ultim concern append slice, propos addit of:
```go
// AppendRune appends the UTF-8 encoding of r into p.
func AppendRune(p []byte, r rune) []byte
```
signatur match mani append-lik api standard librari (e.g., `strconv.appendfloat`).
/cc @robpik
propos ad activ column propos project
review weekli propos review meetings.
â€” rsc propos review group
seem reasonable. thank @dsnet scan libraries: make case.
base discuss above, propos seem like **like accept**.
â€” rsc propos review group
chang consensus, **accepted**. ðŸŽ‰
