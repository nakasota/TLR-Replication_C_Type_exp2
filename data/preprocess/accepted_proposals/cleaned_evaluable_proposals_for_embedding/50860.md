sync/atomic: add type atom valu
june 2021 post seri articl memori models, end articl chang thought make go memori model. see especi
open github discuss discuss changes; see #47141.
base discussion, propos add follow type sync/atomic: bool, int32, int64, uint32, uint64, uintptr, pointer[t any].
method appropri type. load, store, swap, compareandswap methods. integ also add method (bool pointer[t] not).
exact detail view pend cl 381317 prepar concreteness.
file separ proposal, #50859, document fix aris june discussion.
- - -
**generics?** natur question type someth like atomic.val[bool], atomic.val[int32], on. main answer api differ differ types, gener provid way accomplish that.
specifically, bool pointer[t] add method, integ should.
anoth reason way write singl constraint work set types. way write gener pointer constraint, atomic.val[\*byte], say [t ~\*e, e any], way add types.
type val[t interfac { ~*e | ~bool | ~int32 | ... }, e any] struct { ... }
use infer bool, int32, idea infer e, requir programm write
atomic.val[bool, doesnotmatter]
doesnotmatt type all. all, tri use gener pretti awkward here.
use awkward too: atomic.val[int32] nice plain atomic.int32.
could potenti introduc singl gener ints, atomic.int[int32], remov awkward implement cost introduc awkward (repetition) call sites. that' usual wrong tradeoff, includ here.
(final matter implement bodi would look like gener functions, preced concern prevent us even reach one.)
non-gener api simpler explain easier use.
chang mention issue: `sync/atomic: add type atom values`
[sorry, notic "do review" cl ad comment possibl remove]
absolutely. pointer particular make life much easier.
wonder might worth declar gener interfac cover new types:
```
type ValueOf[T any] interface {
	Load() T
	Store(T)
	Swap(T) T
	CompareAndSwap(T, T) bool
}
```
(i know prefer spell "of" type days).
unfortun type automat assign interfac (cf think type still use (and make clear conform pattern too).
one thought: propos _have_ use differ type valu that' atom accessed.
gener that' good thing, imagin scenario that' possibl (for example,
atom access element slice later expos public api). origin atom oper
still available, course, `loadpointer` `storepointer` suffici awkward (and error-prone)
use wonder might worth introduc gener helper function those. example:
```
func LoadPointerOf[T any](addr **T) *T
func StorePointerOf[T any](addr **T, val *T)
func CompareAndSwapPointerOf[T any](addr **T, old, new *T) (swapped bool)
```
loadpointerof, etc, rather take conserv rout wait significant, demonstr need. think differ type correct vast major uses, part goal new api get peopl think valu either alway atom never atomic. that' strictli required, help avoid bugs, want make easier backslid that.
me, one advantag propos defin atom type independ sidestep potenti align issu (#19057, #27577) surround atom access non-atom types. think that' strong benefit, would rather give up.
however, think would reason defin `unsafe.pointer` may use convert pointer atom type suitably-align non-atom type.
> one thought: propos _have_ use differ type valu that' atom accessed. gener that' good thing, imagin scenario that' possibl (for example, atom access element slice later expos public api). origin atom oper still available, course, `loadpointer` `storepointer` suffici awkward (and error-prone) use wonder might worth introduc gener helper function those.
assum code valid:
```go
func CompareAndSwapPointerOf[T any](addr **T, old, new *T) (swapped bool) {
	return atomic.CompareAndSwapPointer(
		(*unsafe.Pointer)(unsafe.Pointer(addr)),
		unsafe.Pointer(old),
		unsafe.Pointer(new),
	)
}
```
i.e., assum differ represent pointer concret type pointer type paramet type. then, implement function straightforward, easi packag defin need them.
intern implement reasons, runtim use separ atom packag `sync/atomic`. month ago ad type similar propos `runtime/internal/atomic` (biggest differ lack gener `atomic.pointer`).
provid concret exampl use take look relat chain
person experi thu far positive. atom type make difficult/imposs forget use atom access, easi before. additionally, least runtim nearli atom valu basic integr types, lack gener feel limit fact make simpler type.
+1 resolv atom align issu here, imo happen sooner rather later. think wait gener alignment-fix propos land (like #19057) fix it, mean user rewrit atom code actual work straight gate, think go take substanti time land kind gener fix align issues.
also, +1 gener `pointer[t]`.
complet agreement arranging, kind magic, atomic.int64/atomic.uint64 carri proper alignment.
@bcmill
> however, think would reason defin unsafe.point may use convert pointer atom type suitably-align non-atom type.
assum mean thing like convert \*int32 \*atomic.int32. sure realli want guarante condit safeti conversion, even though use test. (test allow assum thing package' internals!)
say anyth convers seem like take constraint littl benefit, point peopl gener bad direct rather go. peopl need mix atom non-atom access still use old api, go away.
propos ad activ column propos project
review weekli propos review meetings.
â€” rsc propos review group
@rsc pleas note prior work also suggest api
anyon object accept proposal?
base discuss above, propos seem like **like accept**.
â€” rsc propos review group
chang consensus, **accepted**. ðŸŽ‰
