strconv: add quotedprefix
exist `unquote` function unescap go string assum entireti input string escap string. however, mani pars applications, quot string follow amount unconsum input, presenc arbitrari charact quot string current break `unquote` function.
propos adding:
```go
// UnquoteLeading interprets the start of s as a single-quoted, double-quoted, or backquoted Go string literal.
// Any subsequent characters after the terminating quote are returned as rem.
func UnquoteLeading(s string) (out, rem string, error)
```
function may simplifi number standard packag implement logic determin end quot string pass correctli size string `strconv.unquote`:
* fmt/scan.go
* text/template/parse/lex.go
* reflect/type.go
think propos make sense; find end quot manual mean reimplement basic version unquote.
also wonder input `[]byte`; realis packag call strconv, use case precis read buffering, one almost alway byte slice. fmt reflect exampl show explicitli convert string call strconv, example. think result less important, possibl construct result strings.builder.
may oper expos "find end string" "also unquot it".
discuss recent austin ad similar oper regexp/parse, think would separ actual parsing. alway want pars it, alway need identifi boundary.
sound flexible, downsid one would end loop input byte twice. alreadi happen today, perhap cost signific enough matter.
given mani string escap characters, oper could report whether string escap characters. not, user could trivial truncat lead trail quot charact avoid second pass.
propos ad activ column propos project
review weekli propos review meetings.
â€” rsc propos review group
string-end-finder, guess api would be:
```
package strconv
// QuotedPrefix returns the quoted string (as defined by Quote and Unquote) at the prefix of s.
// If s does not start with a valid quoted string, QuotedPrefix returns an error.
func QuotedPrefix(s string) (string, error)
```
?
report presenc absenc escap charact seem like prematur optimization.
need know prefix quot string end caller start pars come afterwards?
> report presenc absenc escap charact seem like prematur optimization.
agree. use-cases, perform paramount. also, loop seem hard write extrem perform sensit cases.
> need know prefix quot string end caller start pars come afterwards?
call `len` function result.
ah yes, apologize. miss part "return **quoted** string".
feel like api simpli return length valid quot string (and entir length otherwise) simpler use.
suppos had:
```go
// QuotedPrefixLen returns the length of the quoted string (as defined by Unquote) at the prefix of s.
// If s does not start with a valid quoted string, QuotedPrefix returns len(s).
func QuotedPrefixLen(s string) int
```
example, want pars follow text:
```
"string1" "string2" "string3"
```
code would look like:
```go
in = strings.TrimSpace(in)
for len(in) > 0 {
    n := strconv.QuotedPrefixLen(in)
    s, err := strconv.Unquote(in[:n])
    if err != nil {
        ...
    }
    ... // make use of s
    in = strings.TrimSpace(in[n:])
}
```
alternatively, `quotedprefix` api, addit error check:
```go
in = strings.TrimLeft(in, " ")
for len(in) > 0 {
    s1, err := strconv.QuotedPrefix(in)
    if err != nil {
        ...
    }
    s2, err := strconv.Unquote(s1)
    if err != nil {
        ... // technically this will never happen, but it's not obvious to reviewers
    }
    ... // make use of s2
    in = strings.TrimLeft(in[len(s1):], " ")
}
```
said, still okay `quotedprefix` better nothing.
> feel like api simpli return length valid quot string (and entir length otherwise) simpler use.
>
> suppos had:
>
> ```go
> // quotedprefixlen return length quot string (a defin unquote) prefix s.
> // start valid quot string, quotedprefix return len(s).
> func quotedprefixlen( string) int
> ```
>
> example, want pars follow text:
>
> ```
> "string1" "string2" "string3"
> ```
>
> code would look like:
>
> ```go
> = strings.trimspace(in)
> len(in) > 0 {
> n := strconv.quotedprefixlen(in)
would `quotedprefixlen` return 0 there' escap error insid quot prefix?
guess that' case, could still call `unquote` full string produc expect error, work ok.
struggl return 0 len(s) error situations. advantag return len(s) naiv slice input would pass invalid string `strconv.unquote`, would produc good error message. downsid can't distinguish valid string happen full length invalid one.
return `(int, bool)`? could ignor boolean result need it.
alway wrap quotedprefix get single-result.
return error let get specif inform went wrong,
sentinel integ not.
base discuss above, propos seem like **like accept**.
â€” rsc propos review group
chang consensus, **accepted**. ðŸŽ‰
