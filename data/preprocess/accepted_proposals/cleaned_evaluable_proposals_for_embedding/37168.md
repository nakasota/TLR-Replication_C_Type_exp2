crypto: new assembl polici
crypto packag unfortun rich assembl implementations, especi hard review maintain due divers architectures, complex optimizations.
current assembl polici golang.org/wiki/assemblypolici fail make review manag resourc secur team current has.
result suboptim everyone: implement follow rules, review still can’t effect review cls, one happy.
propos new, much stricter policy. acknowledg realiti assembl review current move accept pace, shift load implementers, promis work won’t go wast review queue. also progress increas maintainability, reliabl secur assembl codebases, well surfac improv area compil assembl eventu removed.
polici would appli packag `crypto/...` `golang.org/x/crypto/...`. due use cryptograph packages, fact partial maintain secur team, polici would also extend `math/big`.
---
* prefer portabl go, assembly. code assembl mean (n packag * architectures) maintain, rather n packages.
* minim use assembly. rather small amount assembl 50% speedup rather twice much assembl 55% speedup. explain decis place assembly/go boundari commit message, support benchmarks.
* use higher level program gener assembly, either standalon go program `go get`-abl programs, like avo. output reproduc process (like formal verifi code generators) also considered. discuss implement strategi issu tracker advance.
* use small, testabl unit (25–75 lines) call higher-level logic written go. use small, testabl unit call logic written go slow, use small, testabl assembl function go-compat wrappers, go test still test individu units.
* assembl function need refer go implementation, that’ test fuzz side-by-sid assembly. follow golang.org/wiki/targetspecif structur test practices.
* document go code implement requir assembl (specif perform benefit, access instructions, etc), reevalu compil improves.
/cc number crypto assembl implementers: @mundaym @labog @mengzhuo @ceseo @crvv @tocarip @aead @vkrasnov @ncw @gtank @bmakam-qdt
gener polici seem good me, though feel contributor follow current assembl polici would alreadi meet bar new one. mayb need expand advic even more, sure.
one thing propos address fairli common practic take assembl anoth project (e.g. openssl) port go assembly. see review everi often. one concret thing think encourag peopl document repositori and, importantly, exact version control revis code base easier check upstream changes. said that, review code think better encourag keep code close origin easier updat upstream chang (assum anyon ever bother check them) modifi heavili fit policy? sometim contributor fulli understand implement algorithm port hard rework fit policy. may reluct chang code much. firm sort situation, assum otherwis well tested?
one point like make think mandat use code generation. use would increas maintainability. short hand-written assembl file prefer situations.
yes, agree, switch assembl go-ristretto use plain go go 1.13 `bits.mul64`. perform bit worse, accept trade-off increas maintainability. would nice "intrinsics" support go, like rust' `u32x4`, etc. otherwis see reach accept perform hashes.
@bwesterb pleas file issu encount specif intrins import elimin assembly. there’ uncertainti around vector intrins work, think there’ open new scalar intrinsics.
edit: realiz ask vector intrinsic. sorry. i’d person like those, too, one put togeth complet design yet. there’ prior discuss anoth issu can’t find moment.
seem rememb discuss wrote (onli 18 month ago). anyon know there' link somewher discussion?
> gener polici seem good me, though feel contributor follow current assembl polici would alreadi meet bar new one. mayb need expand advic even more, sure.
hmm, major differ stronger prefer code generation, requir go refer implement match small assembl function 1:1. example, gener implement 32-bit limb assembl 64-bit limbs, would accept anymore, assembl entri point scalarmult, would broken dozen functions.
> one thing propos address fairli common practic take assembl anoth project (e.g. openssl) port go assembly. see review everi often. one concret thing think encourag peopl document repositori and, importantly, exact version control revis code base easier check upstream changes. said that, review code think better encourag keep code close origin easier updat upstream chang (assum anyon ever bother check them) modifi heavili fit policy? sometim contributor fulli understand implement algorithm port hard rework fit policy. may reluct chang code much. firm sort situation, assum otherwis well tested?
mention default, ok license-wise. there' path bring assembl dual-licens part cryptogams, that' taken coupl times.
think tri "keep port close source" route, meet standard maintain like have, also sourc often perlasm someth like that, call convent different, go reserv registers, etc.
like us tri develop small curat set assembl implement rather bring larg amount project differ priorities.
> one point like make think mandat use code generation. use would increas maintainability. short hand-written assembl file prefer situations.
particularli experimental, will reconsid seen results, like tri out, think might lead much better readabl portability. mayb even forc creation tool like avo abstract useless manual work.
new assembl polici make statement assembl code eventu get remov unlik get merged?
probabl worth maintain asm implement "broken" cryptograph primitive. one example, remember, `crypto/rc4` package. see: #25417
similarly, may want maintain asm code "outdated" primit - i.e. sha-1.
(yeah, technic sha-1 broken well - still commonli use b/c legacy, git, ...). primit seem unlik **new** asm code worth mainten cost.
however, aspect quit specif cryptograph implementations. may specif gener assembl policy.
> use higher level program gener assembly, either standalon go program go get-abl programs, like avo.
clarifi "high level program gener assembly" make code secure? anything, would think requir scrutiny. author program call third-parti program gener assembl idea program gener way did. need understand implement high level languag well review understand low-level assembl gener third-parti program. mistak deleg trust third parti code gener gener assembl uniqu cryptograph primitive.
> output reproduc process (like formal verifi code generators) also considered.
processes? context statement? talk guarante instruct corrupt memori verifi implement right thing possibl inputs. latter seem impossible, intent formal verif clearli state propos reduc confusion.
hi @filosottile, fwiw like gener philosophi around activ experiment see new approach yield better results, sound like concept observ refin base experi goes.
question fuzz piece:
1. would make sens requir hook oss-fuzz similar on-go fuzzing?
2. would help includ somewher sampl templat fuzz functions, includ side-by-sid fuzzing, perhap instead includ pointer good concret examples? (mayb would part polici itself, perhap auxiliari wiki page similar).
3. would make sens recommend possibl requir fuzz > 1 engin (such nativ dvyukov/go-fuzz well libfuzzer) given differ engin often surfac differ bugs? words, polici necessarili need say must use engin x y, could say count engin use > 1. (or mayb set high bar).
> clarifi "high level program gener assembly" make code secure? anything, would think requir scrutiny. author program call third-parti program gener assembl idea program gener way did. need understand implement high level languag well review understand low-level assembl gener third-parti program. mistak deleg trust third parti code gener gener assembl uniqu cryptograph primitive.
firstli disclaimer: wrote avo. pleas see mention propos one mani tool avail help reduc complxeiti high perform crypto assembly. said, naiv enough think alway right tool job!
claim code gener make code easier write, review maintain, ultim make bug less likely. allow us assign meaning name variables, use control structur handl repetit block structur common cryptograph primit (avo sha-1 example). would claim concis code gener written way like review thousand line assembl (see p256 aes-gcm).
would also point novel idea, fact code gener _already_ use extens crypto assembly, specifi via preprocessor macros.
preprocessor use "regist allocation" aes-gcm:

here' poor-man' "function" defin preprocessor:

likewis p-256:


`blake2b`

could go on. point code gener alreadi use go crypto sense, pre-processor particularli aw form (in opinion). go alon here: openssl' `perlasm` someth like copy, evid code gener space. likewis `qhasm` supercop/nacl projects. think there' case made propos assembl polici say much new, encourag peopl use better tool go assembl preprocessor.
point also necessari review code gener complet fair correct. make point respons this, general, defend `avo` particular.
1. **you use third-parti packag all.** simpli `make_asm.go` program print assembl output. perhap someth like meow hash assembl generator. even simpler well. there' noth prescript policy, bring third-parti packag think warranted.
2. **`avo` complicated.** proud project, never claim rocket science. deliber avoid featur would drift "compiler" territory. contain go wrapper around everi x86 instruct well regist allocator. complex lie regist alloc (and associ passes), logic ultim much code. apart cleaner way print assembl isntructions, allow use go function control structur structur code generator.
3. **`avo` complex want be.** suspici regist alloc associ complexity, use it. `avo` support use physic regist directly.
4. **when done well, assembl review too.** claim alway possible, tool like `avo` produc assembl output (they assemblers). insert comment assembl output well, format nicely, like `asmfmt`. done carefully, output actual look quit nice. achiev strictli better situat before: still review raw assembl code gener alongsid too.
> processes? context statement? talk guarante instruct corrupt memori verifi implement right thing possibl inputs. latter seem impossible, intent formal verif clearli state propos reduc confusion.
can't speak @filosottile, base convers real world crypto context. seem hac workshop chanc fiat-crypto team add support go output. could great outcom go community, assum intent assembl polici encompass auto-gener code formal verifi tooling.
@filosottil appreci put togeth broad agreement. glad see emphasi experi -- learn go. wonder might good idea us concret specif cases, see might play out. perhap could pick one critic primit ask would implement propos polici (for exampl p-256, aes-gcm, curve/ed25519). way suggest write code, sketch policy-compli implement would look like.
> propos new, much stricter policy. acknowledg realiti assembl review current move accept pace, shift load implementers, promis work won’t go wast review queue.
contribut sever arm crypto implementations. work enjoy suit written 10 thousand line arm assembl past. howev spend week write assembl code merg realli sucks!
think excel initiative. requir restraint part assembl author natur want go fast possible.
like idea code generation. use preprocessor extens along regist name definit make life easier. preprocessor poor second good macro assembl though.
ala avo x86 moment it? sure arm tool moment (i'd love correct wrong).
code generation, exampl comparison.


code cl 51670 hand-written. code exact structur s390x implementation.
.s file 124 lines. think line line 71 trivial(they copi `$goroot/src/crypto/aes/asm_amd64.s`).
repetit first 70 lines. review read 50 line .s file, think code understood well.
code gener cl 136896 298 lines. clear need time read 298 line go 124 line assembly. besides, anoth 740 line assembl code review.
reviewer, need much time review cl 136896.
although code cl 51670 written me, still think point reason others.
code gener help situations, fit situations.
@crvv accord measur two cl substanti differ performance. see follow gist methodology, pleas let know got someth wrong.

here' `benchcmp` output two cls:
```
benchmark                   old ns/op     new ns/op     delta
BenchmarkAESGCMSeal1K-8     556           558           +0.36%
BenchmarkAESGCMOpen1K-8     530           534           +0.75%
BenchmarkAESGCMSign8K-8     2049          2045          -0.20%
BenchmarkAESGCMSeal8K-8     3366          3362          -0.12%
BenchmarkAESGCMOpen8K-8     3284          3289          +0.15%
BenchmarkAESCTR1K-8         671           376           -43.96%
BenchmarkAESCTR8K-8         4826          2294          -52.47%
benchmark                   old MB/s     new MB/s     speedup
BenchmarkAESGCMSeal1K-8     1840.43      1834.91      1.00x
BenchmarkAESGCMOpen1K-8     1929.99      1917.47      0.99x
BenchmarkAESGCMSign8K-8     3997.98      4005.84      1.00x
BenchmarkAESGCMSeal8K-8     2433.57      2436.21      1.00x
BenchmarkAESGCMOpen8K-8     2494.19      2490.21      1.00x
BenchmarkAESCTR1K-8         1516.47      2704.17      1.78x
BenchmarkAESCTR8K-8         1696.40      3568.81      2.10x
```
note includ aes-gcm benchmark partli show benchmark ran similar environments, also _should_ possibl write aes-ctr mode implement similar perform aes-gcm, better.
believ experi show cl 136896 approx 2x faster cl 51670. therefor classic trade-off. cl 136896 unquestion complic 51670, one could argu complex justifi speedup.
cl 136896 use techniqu employ gcm implementation, produc perform fairli close gcm 8k benchmark. would argu code gener use cl make easier understand `gcm_amd64.s` (1286 hand-written lines).
doubt complex one faster.
point code gener alway helpful.
write simpl algorithm cl 51670, doubt use code generator.
benefit small.
speed differ two cls, depend cpu architecture.
cl 136796 10%-100% faster cl 51670.
way, computers, openssl 1.1.1d 20%-80% faster cl 136896.
@crvv wrote:
> point code gener alway helpful.
agre case. think could everyth code gener preprocessor macro .s file would clear go rather work code gener work puzzl code gener match assembl code generated.
person think solut make macro system go assembl **more** power mandat assembl code written that, rather third parti ad-hoc code gener tools.
> doubt complex one faster.
> point code gener alway helpful.
> write simpl algorithm cl 51670, doubt use code generator.
> benefit small.
@crvv yes, fair point probabl agre cl 51670 benefit code generation.
react previou comment seem compar two cl differ one use code gener doesn't. one 2x faster other, need mention comparison.
> way, computers, openssl 1.1.1d 20%-80% faster cl 136896.
yes, cl 136796 optim either.
clarify, goal present assembl simplest, review form. sometim small that' direct .s file. sometim not, gener better. yes, one write difficult-to-understand gener - that. strive find simplest way express need express. that' true code.
think everyon basic agre cl 51670 need generator, although think close upper limit category. think basic everyon agre cl 136896' gener much better 700 line assembl generates. question whether particular optim worth ad complex almost alway go context-dependent. (in specif case, factor two deem worthwhile. second-guess that.)
read discussion, sound like peopl gener favor polici @filosottil put comment atop issue. right? anyon _opposed_ policy?
(there discuss tradeoff specif aes-ctr case, polici settl everi possibl tradeoff.)
> anyon _opposed_ policy?
far tell discussion, pushback phrase "use higher level program gener assembly", appear suggest code gener _required_. say seem consensu small enough program code gener may counterproductive.
perhap slight soften languag would good? would nice could specif code gener required, seem quit difficult strictli define.
agre what' written principle. use asm way. write clear possible, document well, test well. good rule follow asm crypto.
would like point much polici written amd64 mind. avo others. perform gener code go like wors asm amd64. write small function could result call overhead function can't inlined.
thank everyon input discussion.
re: code generation, definit experiment, agre russ less complex generators, weight complex save. simpl go function name specif oper (say, field addition) take parametr registri print assembly, reus looped. follow language? think "discuss implement strategi issu tracker advance." give us space assess case case go forward.
* use higher level program gener non-trivi amount assembly, either standalon go program go get-abl programs, like avo. output reproduc process (like formal verifi code generators) also considered. discuss implement strategi issu tracker advance.
> would like point much polici written amd64 mind. avo others. perform gener code go like wors asm amd64. write small function could result call overhead function can't inlined.
that' definit intention, would solv fraction mainten problem, would love hear more.
asm go faster compiler-gener amd64 well, even gap might smaller. requir highlight compil need replac asm meant fight gap time.
say small function mean asm go? requir specif asm functions, realiz sometim use go abi expensive, ok make simpl jumpabl unit test adapters.
inlin small assembl function probabl fall
@filosottile, could pleas post new comment exact polici discuss accept rejecting. see edit comment back want make sure everyon agre applies.
@dgryski, note inlin arbitrari small assembl function time soon. much subtleti compil take on. path chose instead good intrinsifi apis.
hello, polici passed, golang commun need reconstruct exist assembl implement 100 lines? split smaller assembl golang functions. compar current assembl implementation, way may lead perform degradation. accept golang community?
> hello, polici passed, golang commun need reconstruct exist assembl implement 100 lines?
yes, eventu want adapt current code policy, although that' lower prioriti drain current review queue. like new code, perform ultim goal, like think gain experi policy, degrad small null.
> @filosottile, could pleas post new comment exact polici discuss accept rejecting. see edit comment back want make sure everyon agre applies.
here' full current text. also clarifi function vs units.
* prefer portabl go, assembly. code assembl mean (n packag * architectures) maintain, rather n packages.
* minim use assembly. rather small amount assembl 50% speedup rather twice much assembl 55% speedup. explain decis place assembly/go boundari commit message, support benchmarks.
* use higher level program gener non-trivi amount assembly, either standalon go program `go get`-abl programs, like avo. output reproduc process (like formal verifi code generators) also considered. discuss implement strategi issu tracker advance.
* use small, testabl unit (25–75 lines) call higher-level logic written go. use small, testabl function call logic written go slow, use small, testabl assembl unit go-compat wrappers, go test still test individu units.
* assembl function need refer go implementation, that’ test fuzz side-by-sid assembly. follow golang.org/wiki/targetspecif structur test practices.
* document go code implement requir assembl (specif perform benefit, access instructions, etc), reevalu compil improves.
anyon _object_ polici preced comment @filosottile?
think polici look good.
might worth mention output assembl gener need check comment start like `// code gener programname. edit`
> * use higher level program gener non-trivi amount assembly, either standalon go program `go get`-abl programs, like avo. output reproduc process (like formal verifi code generators) also considered. discuss implement strategi issu tracker advance.
> use higher level program gener non-trivi amount assembly, either standalon go program go get-abl programs, like avo. output reproduc process (like formal verifi code generators) also considered. discuss implement strategi issu tracker advance.
much assembl quantifi non-trivi amount?
worth note @ncw' comment `go help generate` output would good repeat policy.
@as, non-trivi alway eye reviewer. time easi decide. discuss issu tracker advanc help.
base discuss above, seem like **like accept**.
