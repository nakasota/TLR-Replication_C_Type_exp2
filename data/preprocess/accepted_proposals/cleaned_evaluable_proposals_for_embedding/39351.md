sync/atomic: add (*value).swap (*value).compareandswap
recent use case, previou ticket (#11260, #20164, #26728), renew interest implement `swap` `compareandswap` `sync/atomic.value`.
new interfac serv ergonomic, eschew use `unsafe`, make `atomic.value` pariti `atomic.xxxpointer` methods. key differ `atomic.value.xxxswap` `atomic.xxxswappointer` work, e.g. panic inconsist type nil, fundament `atomic.value` works, thu accept complexity.
interfac definit follows:
```go
package atomic
// Swap stores new into Value and returns the previous value. It returns nil if
// the Value is empty.
//
// All calls to Swap for a given Value must use values of the same concrete
// type. Swap of an inconsistent type panics, as does Swap(nil).
func (v *Value) Swap(new interface{}) (old interface{})
// CompareAndSwapPointer executes the compare-and-swap operation for the Value.
//
// All calls to CompareAndSwap for a given Value must use values of the same
// concrete type. CompareAndSwap of an inconsistent type panics, as does
// CompareAndSwap(nil, old).
func (v *Value) CompareAndSwap(new, old interface{}) (swapped bool)
```
see also #11260, #20164 #26728.
> see also #11260, #20164 #26728.
thank pointers; look, appear search hard wrong keywords.
one thing call link ticket warn `unsafe` package. use case work `atomic.swappointer`, unwil accept risk present unsaf package:
```
Packages that import unsafe may be non-portable and are not protected by the
Go 1 compatibility guidelines.
```
case, need atomic.swap variabl collect batch statist (mani go routin write it), one go routin respons replac batch new empti batch atom export old one. use atomic.swappoint swap atomic.loadpoint get writer mutex much lock contention.
> note: could also call `atomic.value.swap`. would implementation, name close align `atomic.swappointer`.
understand comment. `swap` oper `loadorstore` — `loadorstore` like special case `compareandswap`, valu compar “no valu stored”.
think might valu `(*atomic.value).loadorstore`, though — cases, think could help user avoid panic result “same concret type” restriction, particularli valu store concret implement `error` interface.
> one thing call link ticket warn `unsafe` package.
note #20164 specif call avoid `unsafe` one main motiv factors.
also note #20164 #26728 withdrawn lack compel concret use-cases, would help see concret exampl propos method would used.
> understand comment. `swap` oper `loadorstore` — `loadorstore` like special case `compareandswap`, valu compar “no valu stored”.
fair may gotten carri away compat `sync.map` company. open either `loadorstore`, `swap`, `compareandswap`, meet needs.
> note #20164 specif call avoid `unsafe` one main motiv factors.
> > `atomic.value` seem prefer replac `atomic.*pointer` method code avoid packag `unsafe`.
> >
> > accord @bradfitz cl 41930, `unsafe.pointer` strongli discourag outsid `sync`, `runtime`, `reflect` packages.
call out, felt like prefer mention non-port compat implications. apolog obviou subtext #20164.
> also note #20164 #26728 withdrawn lack compel concret use-cases, would help see concret exampl propos method would used.
submit behalf @oguzyildiz1991' use case. let know detail would beneficial. resolut ticket `unsafe.pointer` good enough?
resolut #26728 said:
> mani environ reject unsaf anymore, contort librari those.
>
> would fine someon compel use creat new issu propos add swap compareandswap (or reopen one, permission). now, given lack real-world use case them, err side leav out.
new real-world use case value.swap helpful?
one describ above? @rsc
> mani environ reject unsaf anymore, contort librari those.
concern less inabl use `unsafe`, unwillingness. `import "unsafe"`, loos go 1 compat guarantee. think unten say need use `sync/atomic` package.
@carnott-snap, worri formal compat polici conjunct `sync/atomic`, might also take look #5045. (`sync/atomic` well-describ behavior yet, although fairli clear pictur definit behavior be.)
also concern exact detail `sync/atomic` package, still cover go 1 compat guarantee. seem like `sync/atomic`' use `unsafe.pointer` stable, could cover guarantee, sinc `pointer` symbol `unsafe` package, take risk.
clear, argu use `atomic.compareandswappointer` (or `loadpointer`, `storepointer`, `swappointer`) unsafe, thu argument made previou tickets, `atomic.value.swap` required, untenable. exist solutions, like expos safe `atomic.pointer` accept `interface{}`, think `atomic.value.something` straightforward.
@carnott-snap want clarifi noth go go wrong convert `unsafe.pointer`. go languag toler tool tri trick users. mayb import unsaf riski formal sense, realiti not.
packag document states. updated, fine, state uncertain terms:
```
Package unsafe contains operations that step around the type safety of Go programs. 
Packages that import unsafe may be non-portable and are not protected by the Go 1 compatibility guidelines. 
```
agre unsaf riski formal sense. even tri say that.
say _in practice_ noth go go wrong convert `unsafe.pointer`. promise. hard write kind rule formally, and, frankly, worth time. languag formalism; also practice.
accept formal policy, presum continu avoid unsafe. i"m sure strong enough reason us add new method `atomic.value`. especi oppos new method, past struggl see reason one.
thank full context. lost me, still think room improv packag document word indic this, respect flavour may lost readers. worth tri improv wording, everybodi agre best messag send potenti unsaf consumers?
@ianlancetaylor true, limit peopl way, exampl complet move app engin multipl project refus app unsaf (or syscall) outsid stdlib.
ad `loadorstore` `compareandswap` `value` would make life lot easier
also stdlib would allow compil intrins later make optim support platform allow unsafe.
-
understand app engin longer constraint.
tri years, least offici faq link above.
confirm document woefulli date: `unsafe`, `syscall`, cgo, assembl work >=1.11. also know direct network access works, think write disk too.
fulli understand writer coordin look sync/atom api, seem odd load, store, swap, compareandswap integ type unsafe.pointer, load store value.
tri rememb whether implement reason leav out. dynam constraint underli concret type store interfac can't change, plain single-word swap/cas. unless there' implement subtleti missing, sound like mayb add them.
thoughts?
api bit cumbersome. order swap/compareandswap, alloc `atomic.value`, `store` valu (of correct type), `swap/compareandswap` new valu value.
- happen compareandswap someth differ dynam type? (panic, presumably?)
- happen compareandswap new valu nil?
- compar two valu contain integ `2`, separ alloc (so interfac data pointer different)? need call type' equal function?
@randall77
> happen compareandswap someth differ dynam type? (panic, presumably?)
- assum thing `store`, panic type match.
> happen compareandswap new valu nil?
- panic type pointer, otherwis work expected, also `store` modifi sinc panic follow `store` impl allow type nil. (
> compar two valu contain integ 2, separ alloc (so interfac data pointer different)? need call type' equal function?
- sinc can't store mismatch type (maybe?) trivial call type' equal fn.
@randall77, expect
func (v *value) swap(new interface{}) interface{}

func (v *value) compareandswap(old, new interface{}) (swap bool)
preserv constraint value.stor (underli type can't change, new cannot nil).
preserv constraint value.store, implement difficulti swap compareandswap?
think doable. swap straightforward use `atomic.swappointer`.
compareandswap quit bit complicated.
```
func (v *Value) CompareAndSwap(old, new interface{}) (swapped bool) {
    if old.Type != new.Type { panic }
    if old.Type != v.Type { panic }
    p := v.Data
    if t.direct {
        if p != old.Data { return false }
    } else {
        if !old.Type.Equal(p, old.Data) { return false } // using type's equality function
    }
    return CompareAndSwapPointer(&v.Data, p, new.Data)
}
```
@randall77: onboard modif initi propos fixup descript match.
base discuss above, seem like **like accept**.
chang consensus, accepted.
thought might worth mention if/when gener come along, easi make atomic.*point function type-safe, although need new names:
example:
```
func SafeCompareAndSwapPointer(type T)(addr **T, old, new *T) (swapped bool) {
	return CompareAndSwapPointer(
		(*unsafe.Pointer)(unsafe.Pointer(addr)),
		unsafe.Pointer(old),
		unsafe.Pointer(new),
	)
}
```
chang mention issue: `sync/atomic: add (*value).swap (*value).compareandswap`
