sync: add mutex.trylock
### version go use (`go version`)?

$ go version
go version go1.16.3 darwin/amd64

### issu reproduc latest release?
ye
### oper system processor architectur use (`go env`)?
<details><summary><code>go env</code> output</summary><br>
$ go env
go111module=""
goarch="amd64"
gobin=""
gocache="/users/tyem/library/caches/go-build"
goenv="/users/tyem/library/appl support/go/env"
goexe=""
goflags=""
gohostarch="amd64"
gohostos="darwin"
goinsecure=""
gomodcache="/users/tyem/go/pkg/mod"
gonoproxy=""
gonosumdb=""
goos="darwin"
gopath="/users/tyem/go"
goprivate=""
goproxy="
goroot="/usr/local/go"
gosumdb="sum.golang.org"
gotmpdir=""
gotooldir="/usr/local/go/pkg/tool/darwin_amd64"
govcs=""
goversion="go1.16.3"
gccgo="gccgo"
ar="ar"
cc="clang"
cxx="clang++"
cgo_enabled="1"
gomod="/dev/null"
cgo_cflags="-g -o2"
cgo_cppflags=""
cgo_cxxflags="-g -o2"
cgo_fflags="-g -o2"
cgo_ldflags="-g -o2"
pkg_config="pkg-config"
gogccflags="-fp -arch x86_64 -m64 -pthread -fno-caret-diagnost -qunused-argu -fmessage-length=0 -fdebug-prefix-map=/var/folders/4w/l3sttpnj00xctgf981g1t2cr0000gq/t/go-build590339154=/tmp/go-build -gno-record-gcc-switch -fno-common"
</details>
### do?
tri fix sever bug lock content net/http/h2_bundle.go.
### expect see?
non-block way test mutex locked.
### see instead?
years-old propos eventu close due nobodi lay convinc enough case provid feature, unabl find way re-open old, lock issu rais fresh believ make convinc case need feature.
think fix sever years-old seriou lock-up problem h2 provid good justif functionality. believ quit small simpl fix follow open issues:
x/net/http2: client hang forev headers' size exce connection' buffer size server hang past request time

x/net/http2: pool deadlock

net/http: "bad" http connect use header.set could potenti block http request 15 min product environ

x/net/http2: block write singl connect caus futur call block indefinit

lay justif reader familiar bugs...
pool network connections.
sync.mutex prevent race access pool struct.
network connect also sync.mutex prevent race access connect struct.
sever oper pool need queri state one connections.
particular, consid function make new connect need see exist connect reused.
function must:
lock pool mutex.
look exist connect endpoint.
ask connect state use new connection.
last question requir look insid connect struct would requir lock connection' mutex.
despit great deal effort years, complex network connect still possibl connect mutex lock oper usual fast done oper take long time, leav connect mutex lock non-trivi duration. desir prevent situat mani case sever could elimin years. risk alway go present.
problem impact singl connect object often much problem, make imposs new network connect made seriou problem prevent that. problem seriou h2_bundl disabl import situat avoid this.
hold lock pool' mutex need ask question, "i particular connect avail take request?", then, believe, connection' mutex lock mean abl immedi answer "no, connect avail take new request, busi someth requir mutex locked. hope situat progress quickli state mutex longer lock point could ask question again, but, no, right now, connect readi available."
sync.mutex current allow code that, think complet reason allow such. easili done via simpl addit of:
// lockifnowait either lock immedi use, return
// true, or, lock alreadi held, immedi return false.
func (m *mutex) lockifnowait() bool {
atomic.compareandswapint32(&m.state, 0, mutexlocked) {
race.en {
race.acquire(unsafe.pointer(m))
}
return true
}
return fals
}
addit allow fix h2_bundle.go also simple.
now, even great deal complic work elimin place connect mutex held call rare chanc take bit time even convinc ever let bug ever creep again, would still prefer "i connect available?" answer immedi "no" question ask connection' mutex held. "open new connection" function potenti wait number connect mutex unlock sound like good strategi make pool provid high perform ton connect managed.
one place happen hold connect mutex connect close()d. complet reason connect struct remain lock oper noth use done connect process closing... except, course, need ask connect question context wait answer would tie progress anybodi want deal network connections.
case caus happen often sudden, ungrac loss network connect service. case, matter much mutex connect server lock abl make use connect servic anyway (better tri new connect get done way hold new connection' mutex locked). one servic fail slowli block network connect terrible.
anoth approach would two layer connect object 2 mutexes. simpl state inform would handl one mutex complex inform would handl another. care alway lock slow mutex lock fast one. care thing protect mutex. trade-off approach? cons: great increas complexity, lot way easili make mistak fast vs slow, pool oper may wait number fast connect mutex unlocked, fix long-liv seriou bug take peopl spend long time work (vs. alreadi simpl fix). pros: add basic featur mutex provid implement request sever peopl seen lot reason use for. (i would pile request time issu alreadi lock disrupt design chang work around basic lack.)
hope case convinc make progress fix bugs.
thanks!
see also #27544.
person think `trylock` better name `lockifnowait`.
trylock appear pretti common name this. object name endeavor pick name keep go traditions. picki name.
suspect want net/http depend 3rd-parti module, solut offer though suppos altern mutex implement (use channel?) could bundl h2_bundle.go (and exported). would better fix h2 anyway.
> pool network connections.
> sync.mutex prevent race access pool struct.
#27544, replac `sync.mutex` 1-buffer channel?
could even store pool channel' buffer, pool even scope locked.
lock pool, receiv channel.
unlock pool, send back channel.
`trylock`, receiv `select` `default` case.
(i examin pattern much detail start around slide 52 talk rethink classic concurr patterns. see particular queue implement around slide 61.)
> #27544, replac sync.mutex 1-buffer channel?
argument, replac `sync.mutex` channels?
> argument, replac `sync.mutexes` channels?
honestly? think that' great idea. ðŸ˜
(but can't remov `sync.mutex` go 1 compatibility, would gratuit break change. start go scratch, would certainli argu omission.)
avoid lot thrash h2 code, bundl replac implement mutex use 1-buffer channel replac sync.mutex member use trylock()...
includ implement sync differ name mutex? mutex implement use channel sound like someth desirable. replac gut mutex channel-bas implementation?
@tyemcqueen, would love see gener channel-bas `mutex` implementation. could even imagin one use type callbacks, base `sync.once` signature:
```
package sync
type TypedMutex[T any] â€¦
func (mu *TypedMutex[T]) Do(func(T) T)
func (mu *TypedMutex[T]) Try(context.Context, func(T) (T, error)) error
```
lock protect invariants. lock held someon else, _nothing_ say invariant.
trylock encourag imprecis think locks; encourag make assumpt invari may may true. end sourc races.
definit lock issu http2. ad trylock would let us paper extent, even would real fix. would like better 4-wheel-driv farther get stuck.
believ http2 make compel case trylock.
propos ad activ column propos project
review weekli propos review meetings.
â€” rsc propos review group
question "i readi use anoth connection?" locked, precis answer actual "no, ready".
believ better approach even elimin case lock individu connect held around block operations. theory, could achiev that. practice, happen year see happen year more, achieved, expect success short-liv (due complex h2 connection).
build system minor mistak lead seriou lock-up good design. way may purer; better.
least mani case "lock problems" h2 connect realli problem deal singl connect (see late original, long propos this) convinc elimin worthwhile, least worth effort required.
experience, prevent use techniqu believ coder less skill, care, experience, judgement may misus often lead even wors approach chosen work around lack. prefer document better approach reason featur use way, rather prohibit it. lead learning, less frustration.
shift gears...
spent time think sever way could get trylock() avail h2, think sever approach reasonable. think would cool creat channel-bas mutex implement prevent even access object obtain lock allow use context even wait "for while" tri obtain lock. and, prove valuabl enough, would cool includ standard go librari (perhap use thing standard go library). also think would need time prove deserv inclusion. probabl replac sync.mutex implementation. simpler (and probabl effici version) probabl worth need more.
realli believ even altern libraries, specific, simpl addit sync.mutex realli someth added. (in beginning, less convinc that, want fix seriou problem h2.)
quit easi start use sync.mutex perfect fit situat come place "i want x, can't right now, want anything, wait would terribl choice". sign respect user languag give option use trylock() get work done file "technic debt" ticket rework lock done design shift point simpl mutex best fit longer. lead technic debt never get fixed? sure sometim will. better way encourag design improv documentation, prohibition.
person run situat twice alreadi remember. forc signific redesign get past hurdl help me. even alway lead better design, one need trylock().
realli situat lock, unlock, trylock exactli need. situat also satisfi channel semaphor complex power things. need ask "are still busy?", that' perfectli reason question abl ask. thing need ask one thing also need mutex around mutex alreadi perfectli captur "yes, busy", let peopl that.
trylock() enough warrant whole separ abstraction. reinforc easi implement sync.mutex.
like lock, unlock, trylock one set featur lock+unlock one object lock+unlock+trylock another. like simpl thing, all-singing, all-danc thing also use mutex.
easi build trylock- mutex mutex atom word. probabl worth http2 see solv problem.
ad trylock http2 seem worthwhile. would need compel case.
@rsc seen variat across sever commerci project involv in. agre `trylock` exampl "good code" mayb ad sake prevent peopl use hacks. although
> easi build trylock- mutex mutex atom word
mayb would good idea implement refer implement insid `x/sync`?
think this, one import benefit build trylock mutex compar wrapper:
fail trylock call creat spuriou happens-befor edg confus race detector.
still convinc this, put togeth cl see would look like
/cc @dvyukov thought
chang mention issue: `sync: add mutex.trylock, rwmutex.trylock, rwmutex.tryrlock`
fwiw, gvisor project use modifi sync packag `trylock` came implement almost 100% ident @rsc's:
think `trylock` almost alway indic sloppi think invariants, convinc *always* mistake. rather see singl `trylock` implement reason rather mani custom ones.
channel-bas implement @bcmill suggest possible, perform poorli comparison. there' reason `sync.mutex` rather use channel locking.
much add. yes, trylock may need cases; yes, need rare go; yes, part current use paper sub-optim design; yes, implement std lib cooper race detector, starvat prevent logic mutex, content profiler; yes, ad trylock std lib increas number unjustifi uses.
search intern code base "trylock() bool" found:
- gvisor
-
-
- one intern implement build channel
much, frankli expect find more. look how/wher used.
need tryrlock() mnm client app. explain use case asked.
trivial implement wrapper.
ok, retract objections. everyon agre unfortun sometim necessary.
anyon els object ad it?
base discuss above, propos seem like **like accept**.
â€” rsc propos review group
chang consensus, **accepted**. ðŸŽ‰
