go/types: addit support type paramet
propos formal introduc chang made support parameter function type `go/types`. see full write-up here:

also see correspond propos `go/ast` `go/token`: #47781.
feedback appreciated. recognit propos contain larg new api surface, start evalu whether discuss resolv least weeks. appear consensu chang requir origin proposal, updat document add note here.
cc @griesem
**changelog:** (chang initi proposal)
- `tparamlist` renam `typeparamlist`
- `tparams` field renam `typeparams`
- `targs` renam `typeargs`
- `rparams` renam `recvtypeparams`
- `orig` renam `origin`
- `info.inferred` renam `info.instances`, chang use `*ast.ident` key, updat captur type signatur instantiation.
- `argumenterror` tweak idiomatic.
- `environment` renam `context`
- setter `*signature` type replac new constructor: `newsignaturetype`
- `typeparams.index` accessor added.
- `interface.isconstraint` replac `interface.ismethodset`.
_note_: caveats/discrep current implementation. keep updat resolv coincid proposal.
- `instantiate` panic pass anyth `*named` `*signature` type, incorrect length `targs`. propos decid instead make return error, yet done.
thank sharing.
initi surfac reactions:
*interface.isconstraint could renam *interface.isconstraintonli *interface.hastypelist, would find find clear, distinguish whether "isconstraint" mean *interface.isconstraint actual use constraint.
question:
```
func (*TypeParam) Constraint() *Interface
func (*TypeParam) SetConstraint(Type)
```
*interfac get type set? exactli type?
high level, think everyth provid interfac instanti coupl actual use case (eg discuss plan treat x/tools/go/ssa, mayb would use there). think also section describ one navig alreadi instanti types.
settparams/setrparam method necessary? feel charact go/typ api, data type immutable. setfoo method (e.g., named.setunderlying, typeparams.setconstraint) exist break cycles, least signatur can't cycles. think name either; e.g., `type i[t i[int]] interface{}` accept go/types.
--
suggest follow chang info.inferred:
1. key map base `*ast.ident` use gener function, use key `info.uses` map.
2. alway `info.inferred` entri `*ast.ident` use gener function, omit source. (perhap renam field too.)
3. get rid `sig`; gener function access without instantiation, set `types` instanti type, user use `uses` get `func`' origin type. (similar untyp constant work: `types` record context-appropri implicit convers type, wherea use `uses` want know `const`' origin untyp type.)
think would consider simplifi task decompos use gener function `func` `typelist` components.
--
probabl want extend `importer` api allow pass `environment` use `instantiate`. (the compil avoid use import manag cyclic depend import checker itself.)
suggest time, instead ad interfac argument (a la `importerfrom`) defin interfac method take struct type (e.g., `importconfig`) argument. extend struct addit field necessari future.
@mdempski
> settparams/setrparam method necessary? feel charact go/typ api, data type immutable.
inde character, fact origin (internal) draft api new constructor (i think call e.g. `newgenericnamed`, use name convent due avoid word 'generic'). rational use setter avoid multipl constructor deprec `newnamed` `newsignature`. preced use multipl step set type, though point preced restrict case necessari break cycles.
> suggest follow chang info.inferred:
thanks, think need someth simplifi `info.inferred`, perhap suggest it. suggestions, subtl case document reduc lookup. origin addit implicit piec data "at expr infer occur" (becaus sometim use constraint type infer index express alon function argument infer necessary), actual defer infer consid full call expression.
see reason take suggestions.
> alway info.inf entri *ast.id use gener function
> get rid sig
clear, suppos `f...`, want know (1) instanti function type, (2) type argument use instantiate, (3) origin function type. suggest `info.types[f]` instanti type, `info.inferred[f]` contain type arguments, use `info.uses[f]` find gener function type, right? seem clean (also, fwiw think storag strictli necessari want abl access inform identifi `f` alone). bit strang `info.types[f]` non-generic, differ report impli type untyp constants.
perhap `func (*info) instanceof(*ast.ident) (*signature, *typelist, *signature)` helper consolid logic.
@scott-cotton
> exactli type?
thank much, right: `constraint` return `type` (which may `*named` `*interface`), `*interface`. match current implementation, error write-up. fixed.
> think everyth provid interfac instanti coupl actual use case
could say mean? think mean "all new api relat type function instanc examples"? case, right would good provid exampl use `tparams`, `targs`, `inferred`, etc. interrog instances.
> > think everyth provid interfac instanti coupl actual use case
>
> could say mean? think mean "all new api relat type function instanc examples"? case, right would good provid exampl use `tparams`, `targs`, `inferred`, etc. interrog instances.
exampl good think would suffice, given time constraint 1.18. tri bring encourag gener consid use cases. point view everyth depend stdlib go/*, great serious consid backward compat alreadi (for input type params), thing tend need extend handl type parameters, yet clear extended. encourag consid end-to-end use cases.
(the compiler/intern implement problem, "the" implementation)
thought one exampl might interest consid (also pull ast token changes): printf vetter. exampl work
```
type Intish interface { ~int, ~int64, ~uint64, ... }
func F[Int Intish](v Int, names ...string) string {
   buf := bytes.NewBuffer() 
   for _, name := range names {
       fmt.Fprintf(buf, "%s %d", name, v) // what if we use %s in stead of %d?
    }
    return buf.String()
}
```
generally, introduct typeparam give lot use case go/ast go/typ read-only. exampl above, instanti f type intish could one thing printf checker could do.
feedback process content: intuit keep tab run end-to-end exampl use case help confirm, possibl guide, design std go/* type parameters. (or we) got cycl kind thing, great, think help. specif content feedback point address, pleas take object kind address.
(on side note develop typeparam base compil intern packag make curiou possibl expos them, like ir)
thought
```
Notably, as *Signature does not have the equivalent of Named.TArgs, and there may not be explicit type arguments in the syntax, the existing content of the Info struct does not provide a way to look up the type arguments used for instantiation. For this we need a new construct, the Inferred type, which holds both the inferred type arguments and resulting non-parameterized signature. This may be looked up in a new Inferred map on the Info struct, which contains an entry for each expression where type inference occurred.
```
discuss infer above.
me, type function call site may infer (ie differ syntax) affect represent type associ function express call site. think would natur info.typ function method valu call site alway instanti (alway instanti named, func lit cannot generic, mayb ok). simpl mechan types.nam use retriev gener type arguments, uniform.
thoughts? miss something?
follow-up, guess tri say last remark inferred, seem like would much easier use signatur name targ targs() orig(), call sites, info.typ caller express would alway instanti type.
@scott-cotton, quick follow-up below. follow-up detail next week (i'm current traveling).
> thing tend need extend handl type parameters, yet clear extended.
coupl relat point here:
- need consid exist api behav respect new constructs. propos write-up tri call `types.info` `types.identical` specifically; other (such assignableto) follow spec. fair bit tool / analyz behavior determin new construct behav exist apis.
- import consid "what addit tools/analyzers" need gener code, ask whether api propos suffic implement addit functionality.
exampl inform two point valuable.
printf analyz suggest good example, implement verifi properti underli type variable. could updat handl type paramet access constraints, consid embed unions, walk type set expression. however, unexport method type parameters: `func (t *typeparam) underis(func (type) bool) bool` would like make updat printf analyz trivial. wonder expos it.
> generally, introduct typeparam give lot use case go/ast go/typ read-only. exampl above, instanti f type intish could one thing printf checker could do.
current api provid high-level mechan "instantiating" function bodies. however, one good thing keep `go/types` `cmd/compile/internal/types2` sync know api must suffici purpose, sinc suffic compiler.
> seem like would much easier use signatur name targ targs() orig()
need think bit more.
> current api provid high-level mechan "instantiating" function bodies. however...
write this, occur might help provid gener 'substitution' api, independ `instantiate`, case like this:
```
func _[T any](...) {
  tests := []struct { t T }{ ... }
  ...
```
say, api substitut type paramet arbitrari types, type associ parameter declarations.
> clear, suppos `f...`, want know (1) instanti function type, (2) type argument use instantiate, (3) origin function type.
there' explicit (even partial) instanti like `f...`, would suggest `types["f"]` gener type (the `uses["f"].type()`), `types["f[...]"]` instanti type. case (fully) implicit instanti like `f(...)` `types["f"]` would instanti type thu differ `uses["f"].type()`.
`f(...)` forc decid whether `types["f"]` instanti type match callexpr gener type match `uses["f"].type()`. sinc there' alreadi good way get latter, seem sensibl `types["f"]` provid former instead. (and mentioned, think consist untyp constant work.)
`f...` there' conflict. would seem littl inconsist case `types["f"]` instanti type.
> perhap func (*info) instanceof(*ast.ident) (*signature, *typelist, *signature) helper consolid logic.
principle, like idea api like (but replac first `signature` `func`). note practice, almost never use `info.typeof`.
propos ad activ column propos project
review weekli propos review meetings.
â€” rsc propos review group
> > clear, suppos `f...`, want know (1) instanti function type, (2) type argument use instantiate, (3) origin function type.
>
> there' explicit (even partial) instanti like `f...`, would suggest `types["f"]` gener type (the `uses["f"].type()`), `types["f[...]"]` instanti type. case (fully) implicit instanti like `f(...)` `types["f"]` would instanti type thu differ `uses["f"].type()`.
>
> `f(...)` forc decid whether `types["f"]` instanti type match callexpr gener type match `uses["f"].type()`. sinc there' alreadi good way get latter, seem sensibl `types["f"]` provid former instead. (and mentioned, think consist untyp constant work.)
>
> `f...` there' conflict. would seem littl inconsist case `types["f"]` instanti type.
>
think reason consist w.r.t. gener treated. would guess common use case (such call graph construction) would tend want treat call site uniformli -- whether instanti type parameters. types["f"] gener f calsit form f(...) instanti type, guess would easier analys consid function call uniformly.
although case, call might scope make refer type parameter, type instanti type, analyz need think type paramet bound. seem easier analyz need treat call sites.
one thing becom clear: golang.org/x/tools/go long way go support type parameters. even sure call graph go librari type parameters... unless call graph type paramet mayb type switch make rather hairi comprehend (all top differ algo static/dynam distinct place now...)
@timothy-k perhap track issu order golang.org/x/tools/go/....?
> would guess common use case (such call graph construction) would tend want treat call site uniformli -- whether instanti type parameters.
ack, use case mind work integr types2 cmd/compile. uniform propos alway strip away explicit instanti packag qualification.
e.g., unifi ir, there' logic:


suggest would simplifi first code `w.expr(expr.fun)` second to:
```go
func lookupObj(info *types2.Info, expr syntax.Expr) (obj types2.Object, targs *types2.TypeList) {
	// Strip explicit instantiation, if present.
	if index, ok := expr.(*syntax.IndexExpr); ok {
		if args := unpackListExpr(index.Index); len(args) == 1 {
			tv, ok := info.Types[args[0]]
			assert(ok)
			if tv.IsValue() {
				return // normal index expression
			}
		}
		expr = index.X
	}
	// Strip package qualifier, if present.
	if sel, ok := expr.(*syntax.SelectorExpr); ok {
		if !isPkgQual(info, sel) {
			return // normal selector expression
		}
		expr = sel.Sel
	}
	if name, ok := expr.(*syntax.Name); ok {
		obj = info.Uses[name]
		targs = info.Inferred[name]
	}
	return
}
```
> even sure call graph go librari type paramet
expect analysi ignor type parameters. sophist analysi probabl want treat similarli regular parameters.
@mdempski thank clarification.
still wonder whether exist code suppos that, call 'f.(args)', types[f].(*types.signature).param(i) assign types[args[i]].
hard say behaviour impact w.r.t. compatibility.
> still wonder whether exist code suppos that, call 'f.(args)', types[f].(*types.signature).param(i) assign types[args[i]].
sorry, sure follow concern here. think suggest *does* ensur would work. particular, ast.callexpr, recommend `types[call.fun]` alway instanti `signature` type, compat correspond `types[call.args[i]]`.
unless point backwards, question whether actual need guarante that? so, offer mdempsky/unconvert exist proof go/typ applic expect work:
@mdempski sorri misunderstood, think say thing awar :)
thank link unconvert; good see work suggestion.
(i still think worth consid .orig() .targ extend work call.fun well named)
(not sure report this, goes)
seem there' typo `type paramet type argument lists` section where:
```
type TParamList struct { /* ... */ }
func (*TypeList) Len() int
func (*TypeList) At(i int) *TypeParam
```
actual read:
```
type TParamList struct { /* ... */ }
func (*TParamList) Len() int
func (*TParamList) At(i int) *TypeParam
```
@sbinet ye right, thank point out.
fix
lot discuss far x/tools/go already. one packag somewhat worri `x/tools/go/analysis/passes/buildssa`. need confirm build ssa current packag need gener function/method bodi `gcimporter`. think clearer implement bit along.
brief summari current statu propos (some contain comment above, discussions):
discuss coupl **superficial** chang proposal.
- discuss #47781, go move spell 'type' everywhere, `typeargs` `typeparams` rather `targs` `tparams`.
- avoid confus concept type environment, consid new name propos `environment` type. one lead contend actual `context`, though tri avoid initially. consideration, probabl unlik `types.context` would confus `context.context`.
additionally, still need work follow **non-superficial** changes:
- whether provid api like `typeparam.underis`, check condit type set type parameter.
- whether gener substitut api need librari like `go/ssa`.
- whether cleanli support type paramet alias (#46477) _without_ move type paramet `typename`.
- whether issu chang `types.inferred` propos @mdempski above. (it look good, want tri out).
least point need resolved. updat propos doc top comment issu reflect (like tomorrow today holiday us).
regard name `types.context`: given mention 'type context' altern name 'type environment', sure whether renam `environment` `context` clear improvement. `context` seem suffer confus 'type context', `context.context`.
think explor altern names.
chang mention issue: `go/types: spell 'type' type paramet apis`
> avoid confus concept type environment, consid new name propos environ type. one lead contend actual context, though tri avoid initially. consideration, probabl unlik types.context would confus context.context.
worth, build.context go/build think terribl confusing. also somewhat analog types.context would be.
think need better term environment.
> worth, build.context go/build think terribl confusing. also somewhat analog types.context would be.
that' good precedent. `types.context` better `types.environment`. however, seem fair number academ refer 'type context' ( worri conceptu overload `environment`, think worri overload `context` well.
fwiw, prefer types.context, types.env, types.environment, close tie first 2.
chang mention issue: `go/types: renam environ context`
chang mention issue: `go/types, types2: renam rparam -> recvtypeparams`
chang mention issue: `47916-parameterized-go-types.md: updat name reflect discussion`
> follow-up, guess tri say last remark inferred, seem like would much easier use signatur name targ targs() orig(), call sites, info.typ caller express would alway instanti type.
want point suggest @scott-cotton still need resolv -- forgot includ above. intuit _could_ done, though implement may bit awkward. need experimentation.
> lot discuss far x/tools/go already. one packag somewhat worri `x/tools/go/analysis/passes/buildssa`. need confirm build ssa current packag need gener function/method bodi `gcimporter`. think clearer implement bit along.
@timothy-k propos share? ssa?
