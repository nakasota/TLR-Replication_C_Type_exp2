log: add func default() *logger
current mani packag contain global var default implement use packag functions, e.g. `http.defaultclient` `http.get`. internally, `log` packag structur call like `log.print` forward `log.std`, `var std = new(...)`.
export `log.std` symbol? could use global configur custom logger, simpli pass around default logger without need call `new(os.stderr, "", lstdflags)` hope still match stdlib implementation.
<details><summary>propos implementation</summary>
```diff
diff --git a/src/log/log.go b/src/log/log.go
--- a/src/log/log.go
+++ b/src/log/log.go
@@ -73,7 +73,8 @@ func (l *Logger) SetOutput(w io.Writer) {
 	l.out = w
 }
-var std = New(os.Stderr, "", LstdFlags)
+// Default is the Logger used by package functions like Fatal, Panic, Print, etc.
+var Default = New(os.Stderr, "", LstdFlags)
 // Cheap integer to fixed-width decimal ASCII. Give a negative width to avoid zero-padding.
 func itoa(buf *[]byte, i int, wid int) {
@@ -274,36 +275,36 @@ func (l *Logger) Writer() io.Writer {
 // SetOutput sets the output destination for the standard logger.
 func SetOutput(w io.Writer) {
-	std.mu.Lock()
-	defer std.mu.Unlock()
-	std.out = w
+	Default.mu.Lock()
+	defer Default.mu.Unlock()
+	Default.out = w
 }
 // Flags returns the output flags for the standard logger.
 // The flag bits are Ldate, Ltime, and so on.
 func Flags() int {
-	return std.Flags()
+	return Default.Flags()
 }
 // SetFlags sets the output flags for the standard logger.
 // The flag bits are Ldate, Ltime, and so on.
 func SetFlags(flag int) {
-	std.SetFlags(flag)
+	Default.SetFlags(flag)
 }
 // Prefix returns the output prefix for the standard logger.
 func Prefix() string {
-	return std.Prefix()
+	return Default.Prefix()
 }
 // SetPrefix sets the output prefix for the standard logger.
 func SetPrefix(prefix string) {
-	std.SetPrefix(prefix)
+	Default.SetPrefix(prefix)
 }
 // Writer returns the output destination for the standard logger.
 func Writer() io.Writer {
-	return std.Writer()
+	return Default.Writer()
 }
 // These functions write to the standard logger.
@@ -311,57 +312,57 @@ func Writer() io.Writer {
 // Print calls Output to print to the standard logger.
 // Arguments are handled in the manner of fmt.Print.
 func Print(v ...interface{}) {
-	std.Output(2, fmt.Sprint(v...))
+	Default.Output(2, fmt.Sprint(v...))
 }
 // Printf calls Output to print to the standard logger.
 // Arguments are handled in the manner of fmt.Printf.
 func Printf(format string, v ...interface{}) {
-	std.Output(2, fmt.Sprintf(format, v...))
+	Default.Output(2, fmt.Sprintf(format, v...))
 }
 // Println calls Output to print to the standard logger.
 // Arguments are handled in the manner of fmt.Println.
 func Println(v ...interface{}) {
-	std.Output(2, fmt.Sprintln(v...))
+	Default.Output(2, fmt.Sprintln(v...))
 }
 // Fatal is equivalent to Print() followed by a call to os.Exit(1).
 func Fatal(v ...interface{}) {
-	std.Output(2, fmt.Sprint(v...))
+	Default.Output(2, fmt.Sprint(v...))
 	os.Exit(1)
 }
 // Fatalf is equivalent to Printf() followed by a call to os.Exit(1).
 func Fatalf(format string, v ...interface{}) {
-	std.Output(2, fmt.Sprintf(format, v...))
+	Default.Output(2, fmt.Sprintf(format, v...))
 	os.Exit(1)
 }
 // Fatalln is equivalent to Println() followed by a call to os.Exit(1).
 func Fatalln(v ...interface{}) {
-	std.Output(2, fmt.Sprintln(v...))
+	Default.Output(2, fmt.Sprintln(v...))
 	os.Exit(1)
 }
 // Panic is equivalent to Print() followed by a call to panic().
 func Panic(v ...interface{}) {
 	s := fmt.Sprint(v...)
-	std.Output(2, s)
+	Default.Output(2, s)
 	panic(s)
 }
 // Panicf is equivalent to Printf() followed by a call to panic().
 func Panicf(format string, v ...interface{}) {
 	s := fmt.Sprintf(format, v...)
-	std.Output(2, s)
+	Default.Output(2, s)
 	panic(s)
 }
 // Panicln is equivalent to Println() followed by a call to panic().
 func Panicln(v ...interface{}) {
 	s := fmt.Sprintln(v...)
-	std.Output(2, s)
+	Default.Output(2, s)
 	panic(s)
 }
@@ -373,5 +374,5 @@ func Panicln(v ...interface{}) {
 // if Llongfile or Lshortfile is set; a value of 1 will print the details
 // for the caller of Output.
 func Output(calldepth int, s string) error {
-	return std.Output(calldepth+1, s) // +1 for this frame.
+	return Default.Output(calldepth+1, s) // +1 for this frame.
 }
```
</details>
get lot downvotes, tri explain mine. alreadi configur global logger via setflags, setoutput, setprefix. also queri func like like flags, writer, prefix.
alreadi cover pretti much reason use case modifi global logger. export variabl would multipl downsides:
* duplic features; example, `log.setoutput` would equival `log.default.setoutput`
* pitfalls; `log.default = nil`?
* invit data races. replac `log.default` safe log messag could alreadi happening.
impli global default implementations, sorri misread you, differ `net/http.defaultclient`, `flag.defaultusage`, `net.defaultresolver`, `go/build.default`? pretti common pattern stdlib, commun think reasonable, deprec symbols.
primari reason interest featur abil (readonly) pass around default log.logg implement modularity/testing. get open unsaftey, due lack `const var`s.
```go
// in prod
t := thing.New(log.Default)
t.Do()
// in test
l := &mockLogger{}
t := thing.New(l)
t.Do()
l.Assert()
```
today would make dummi implement forward calls:
```go
type StdLogger struct{}
func (l StdLogger) Fatal(v ...interface{}) { log.Fatal(v) }
func (l StdLogger) Fatalf(format string, v ...interface{}) { log.Fatalf(format, v) }
// ...
```
---
speak concern specifically:
> * duplic features; example, `log.setoutput` would equival `log.default.setoutput`
yes, `http.get` equival `http.defaultclient.get` nobodi complain existence?
> * pitfalls; `log.default = nil`?
not. also modifi `os.stdout`, mean should. document var assist.
> * invit data races. replac `log.default` safe log messag could alreadi happening.
problem global mutability, see issu `http.defaultclient`.
mayb would safer
```go
package log
func Default() *Logger { return std }
```
packag use pattern seem fine.
open option well, agre consist probabl important. also, especi testing, case want nop actual default logger. muck around `os.stdout` know edg case need sledgehammer.
much understand desir pass *log.logger; use instead call default log directly. example, option log package. caller want use default log. best pass new log object paramet default, ie:
`log.new(log.writer(), log.prefix(), log.flags())`. unfortun share privat `mu sync.mutex`.
> primari reason interest featur abil (readonly) pass around default log.logg implement modularity/testing.
agre pass around `*log.logger` around good modularity. requir packag adher logger implementation, go appli vast major go softwar wild.
think right solut interface, thread think focu discuss suggest thread; would make littl sens accept propos independ earlier one.
regard api similar packag - yes, packag similar pitfalls, mean ok inherit :) rememb lot packag standard librari design ten year ago, might still carri bad design decis due go1 compat guarantee. would definit say `net/http` good exampl take idea from, general.
> agre pass around `*log.logger` around good modularity. requir packag adher logger implementation, go appli vast major go softwar wild.
necessarili case: could wrap default `log.logger` custom interface. goal chang expos reference, current methods, note `sync.mutex` limitation.
> think right solut interface, thread #13182. think focu discuss suggest thread; would make littl sens accept propos independ earlier one.
open ad interfac too, seem orthogonal. still make interfac get modular want default `var`, two symbol seem play togeth nicely, mayb good: (or #13182 first)
```go
var Default Interface = New(os.Stderr, "", LstdFlags)
type Interface interface { // or what ever name #13182 decides
        Fatal(...interface{})
        Fatalf(string, ...interface{})
        Fatalln(...interface{})
        Flags() int
        Output(int, string) error
        Panic(...interface{})
        Panicf(string, ...interface{})
        Panicln(...interface{})
        Prefix() string
        Print(...interface{})
        Printf(string, ...interface{})
        Println(...interface{})
        SetFlags(int) 
        SetOutput(io.Writer)
        SetPrefix(string)
        Writer() io.Writer
}
```
skeptic packag log defin interface, especi one comment mine. packag want logger probabl defin one-method interfac expects. interfac differ use log.logg directly.
thank clarifi thing @rsc, seem like #13182 `interface` discuss covered. interesting, orthogon propos change, tri conflat thing further.
restate, propos add
packag log
// default return default logger use top-level function like print, setoutput, on.
func default() *logger
see much enthusiasm comment reaction above, let' put minut see peopl chime in.
certainli code could simpler someth like that.
@jimmyfrasch would code simpler? use case? still need specif exampl evalu whether worth ad complexity.
inject logger program, overridden test flag, need reconstruct default logger. someth like propos could
```go
func main() {
  realMain(log.Default())
}
```
seem bit redund also consist done elsewher (importer.default, build.default, net.defaultresolver) expos default function use top-level functions.
anyon object ad `func default() *logger` packag log?
base discuss above, seem like **like accept**
place declar logger struct pass around. available, would call `log.default()` instead.
chang consensus, accepted.
chang mention issue: `log: expos std via new default function`
