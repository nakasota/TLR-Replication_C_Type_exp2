encoding/json: memoiz string decod
part motiv #32593 observ json-iterator/go#376 json decode, mani string appear json get copi reconstruct result well.
_not_ want make json coalesc alloc string one giant buffer, hold one hold onto entir thing.
might make sens add decod state simpl map[[]byte]str rememb specif byte slice alreadi convert string reus alloc string instead convers particular decod unmarsh operation.
unclear whether map decod persist decod operations. probably? affect user put decod pool someth like that, though. (solution: put decod pools.)
ago wrote code test exact thing json decoder, could detect signific differ memori usag decod memoiz string regular json decoder, made think mayb alreadi done somewhere? appar not. tri find test code...
here' link test code decod json interface{}:

initi comment wrong, make differ store string map. test code store field key map string like repeat.
json/ packag copi stdlib encoding/json packag modifi includ map[string]str decod state.
nit: assum propos meant use `map[string]string` `map[string([]byte)]` lookup `map[[]byte]string` support map type.
also cc @josharian, similar idea ago. briefli discuss #5160.
thought, probabl want reus strings. example, map key probabl tend repeat much often values.
also, want make configurable? someon write program like know whether read somewhat static/rep data not.
chang mention issue: `encoding/json: memoiz key decode`
@mvdan, concern overhead map lookup jun 26 comment? outsid possibl downsid reus string constructed.
cl mention implement json decoder. introduc overhead decod interface{}, that' case key read decod kept decod done.
however, think better way this. propos write encoding/literalstor type (a map[string]string) contain get(string) string method retriev share instanc string. use decod encoding/xml encoding/json. use literalstore, caller assign instanc json/xml decoder. way, caller option use liter store larg input make difference, use store multipl docs, avoid completely.
think?
one convent use-cas weak refer gc'd languages.
ideally, reus string remain reachabl last `decode` invocation, let collector clean string sinc becom complet unreachable. way, frequently-us string remain map, infrequ string still collect (so map grow without bound decod use mani differ input time).
altern requir weak refer include:
* make intern behavior explicit opt-in use `decoder` method (perhap `func (*decoder) internstrings(func([]byte)bool)`).
* make intern behavior explicit annot struct field tag.
* get awkward describ behavior map key vs. map values.
@bcmills, propos make intern behavior explicit opt-in use `decoder` field instead method. read #32593, believ one way make accept term perform usag this:
* add strings/literalstor type (a map[string]string), add(string) string method return share copi string
* add `decoder.keyliterals` field type literalstor json xml decoders.
* use `keyliterals` non-nil decod store key
implement chang exist behavior make use liter store explicit opt-in.
liter store like use larger json/xml input, manual decoded, unmarsh interface{}. input unmarshaled/decod struct, need keep key lost.
re: weak references, afaik way implement use finalizers, wrong?
@bserdar think way final exist user use `string` values, pointers, noth hang final on. matter weak refer work either: would chang user use weak refer type rather `string`.
gener final weak refer equival power, anyth one other. abl control type peopl use.
@ianlancetaylor thank clarification.
interest this, modifi implement this. alreadi wrapper code around json/xml decod reus key string make lot differ larg docs.
cc @mvdan
> matter weak refer work either: would chang user use weak refer type rather `string`.
no? would need sort language-support “weak string” type, `json.decoder` would hold weak refer — decod messag would use regular `string` data disappear beneath them.
(but assum languag chang seem pretti unlik ever happen.)
> gener final weak refer equival power, anyth one other. abl control type peopl use.
ah, think see saying. could control type use, could add pointer indirection, requir user keep pointer aliv order retain `string` valu decoder' cache.
can't use pointer way ordinari strings: can't map keys, work normal built-in `string` operations, can't pass `strings` packag without fall back manual memori manag (via `runtime.keepalive`).
may true _technically_ equival power, equival usable.
@bserdar, `strings.literalstore` seem unfortun given also discuss ad gener language, much gener “intern table” api use type support hash equality.
gener form could api like:
```go
package intern
type Table(type T HashEqualer) […]
func (t Table(T)) Get(x T) (canonicalX T) {
	[…]
}
```
api also use build thing like abstract syntax trees, use compress tree coalesc occurr common subexpress canon instance.
(a long time ago maintain server evalu larg number boolean express ad targeting, use similar approach — great effect — compress target expressions, includ wire protocol.)
@bcmills, intern tabl would nice, avail time soon. becom available, keep intern intern decoder, expos internkeys(bool) method explicit opt-in. or, implement strings.literalstore, chang use intern packag gener done.
xml.decod benefit intern string well. opinion that? decoder.internkeys() would explicit opt-in intern key decode. someth similar this:
there' lot discuss seen object simpli put map suggest decod tri reus that.
seen rational ad new api. time. miss something?
small perform hit use time. measur here:
codedecoder-8 9.87m ± 2%
codedecodetointerfacenointern-8 10.9m ± 3%
codedecodetointerfaceintern-8 11.6m ± 4%
interest this, fix cl
gladli take perform hit new api. json mani repeat string long show lower memori usag think that' clear win.
use less memori interning. unit test (codedecode*), explicit call gc:
interning:
alloc:10708232 totalalloc:26603840 sys:71762168 lookups:0 mallocs:364454 frees:196341 heapalloc:10708232 heapsys:66519040 heapidle:54239232 heapinuse:12279808 heapreleased:49496064 heapobjects:168113
interning:
alloc:10487800 totalalloc:38961736 sys:71762168 lookups:0 mallocs:635980 frees:481644 heapalloc:10487800 heapsys:66617344 heapidle:52895744 heapinuse:13721600 heapreleased:44720128 heapobjects:154336
seem worth doing, seem like minor optimization, visibl api change.
unclear realli need propos process all,
sinc here, base discuss littl affected,
seem like **like accept**.
say memori comment way around?
@mvrhov, sorry, quit understand mean.
well number intern string larger... total alloc 30%, number mallco 50%, free 60%. number allco smaller 2%
alloc smaller mean there' less memori alloc end. totalalloc higher interning. free larger, intern string copi would'v unmarsh object collected. overall, intern everyth said done, there' less memori allocated.
> @mvdan, concern overhead map lookup jun 26 comment? outsid possibl downsid reus string constructed.
@rsc sorri miss comment long. could sworn replied.
concern keep string aliv longer needed. that' much relat one origin points:
> unclear whether map decod persist decod operations. probably?
example, imagin server receiv json object via network stream, unmarsh them, write database, discard them. right now, would write program way "incom objects" goroutin keep singl decod aliv forever.
decod start memoiz string forev (sinc decod persist forever), memori usag could increas time keep see new/uniqu strings. example, seem pretti common repres uuid hash string json, bit worri user could easili run kind "memori leak".
@mvdan, still concern json key memoized? key repetitive. memori number past ago memoiz json keys, field values.
also, memoiz key meaning decod map.
unclear current propos memoiz strings, key decod `map[string]t`. imagin case unique/chang string happen map keys, still find possibl scenario. example, map key uniqu id hash seem pretti reasonable, one want quick lookup unmarshaling.
so, concern probabl smaller memoiz map keys, even then, still bit concerned.
propos memoiz singl json.decoder, globally.
want avoid memoization, could use multipl json.decoders.
note call json.unmarsh use decoder, would independent.
(if decod object list []map[string]int, map key one decod could shared, across decodings.)
anoth possibl memoiz default allow hook decod (a method `setsavestring(func([]byte) string)` someth like that) would let overrid polici global pool, pool small strings.
seem like there' win-win take win default.
anyon object mark accept assum win-win?
obvious benchmark say win take cl.
