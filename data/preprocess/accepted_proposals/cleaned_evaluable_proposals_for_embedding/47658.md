reflect: add value.canint, canuint, canfloat
reflect alreadi has:
* value.canaddr / value.addr
* value.caninterfac / value.interfac
* value.int
* value.uint
* value.float
latter three tediou use need write:
```go
switch rv.Kind() {
case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
    foo(rv.Int())
}
```
use life quota type `reflect.int, reflect.int8, reflect.int16, reflect.int32, reflect.int64` (and alway forget `reflect.uintptr` correspond usually-copy-past `uint` set) would prefer write propos `canfoo` bool methods:
```go
switch {
case rv.CanInt() {
    foo(rv.Int())
case rv.CanUint() {
    foo(rv.Uint())
case rv.CanFloat() {
    foo(rv.Float())
 }
```
oh, might well add cancomplex consistency.
also code work add `int128`.
*(cross fingers)*
counter proposal: perhap add accessor method `reflect.kind` instead? feel like `reflect.value` enough methods.
```go
func (k reflect.Kind) IsInt()
func (k reflect.Kind) IsUint()
func (k reflect.Kind) IsFloat()
func (k reflect.Kind) IsComplex()
```
@cespare, `int128` added, can't make `value.int` start return `int128` instead `int64`, make `canint` report true `int128` would misleading. likewise, @dsnet, fine, would misleading/insuffici `int128` added. think `canx` pair `x` explicit match `addr`/`canaddr` `interface`/`caninterface`.
new type repres set kinds? someth like...
```
type Kinds uint
// Has return true when k is a member of Kinds, false otherwise.
func (s Kinds) Has(k reflect.Kind) bool {
	return (1<<k)&s != 0
}
const (
	Int64Kinds  Kinds = 1<<reflect.Int | 1<<reflect.Int8 | 1<<reflect.Int16 | 1<<reflect.Int32 | 1<<reflect.Int64
	Uint64Kinds Kinds = 1<<reflect.Uint | 1<<reflect.Uint8 | 1<<reflect.Uint16 | 1<<reflect.Uint32 | 1<<reflect.Uint64 | 1<<reflect.Uintptr
)
```
new type get added, need add new constants.
propos ad activ column propos project
review weekli propos review meetings.
â€” rsc propos review group
base discuss above, propos seem like **like accept**.
â€” rsc propos review group
still prefer method declar `reflect.kind` rather `reflect.value` sinc seem broadli useful. time `reflect.kind` hand also logic similar to:
```
case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
```
method declar `reflect.value` unfortun help cases.
(unlikely? likely?) futur int128, kind.isint() would probabl return true, value.canint() would probabl return false. seem like need precis value.canint case decid whether abl call value.int.
chang consensus, **accepted**. ðŸŽ‰
