os/exec: add field manag termin signal pipe
### background
#23019 (accept yet implemented; cc @ianlancetaylor @bradfitz) propos chang `exec.cmd.wait` stop goroutin copi i/o complet `exec.cmd`; see propos background problem aim address. however, note feasibl implement propos requir use arbitrari timeout, propos includ mechan adjust timeout. (given histori go project' builders, extrem skeptic particular hard-cod timeout strike appropri balanc robust latency.)
#31774, #22757, #21135 propos allow user `exec.commandcontext` custom signal sent command context canceled. declin due lack concret demand featur ( sinc accru number copi function work around feature' absence. go project alone, have:
*
* (ad #37405)
*
*
attempt add yet anoth variat (in cl 373005) order help diagnos #50014. however, variat (prompt discuss @aclement @prattmic) tri make variat minimally-invas chang top `exec.cmd` api.
believ achiev goal: api requir addit 2â€“3 new field new method top-level functions. view (and tri out) prototyp `github.com/bcmills/more/os/moreexec`, provid drop-in replac subset `exec.cmd` api.
### propos
propos addit follow field `exec.cmd` struct, along correspond implementation:
```go
	// Context is the context that controls the lifetime of the command
	// (typically the one passed to CommandContext).
	Context context.Context
	// If Interrupt is non-nil, Context must also be non-nil and Interrupt will be
	// sent to the child process when Context is done.
	//
	// If the command exits with a success code after the Interrupt signal has
	// been sent, Wait and similar methods will return Context.Err()
	// instead of nil.
	//
	// If the Interrupt signal is not supported on the current platform
	// (for example, if it is os.Interrupt on Windows), Start may fail
	// (and return a non-nil error).
	Interrupt os.Signal
	// If WaitDelay is non-zero, the command's I/O pipes will be closed after
	// WaitDelay has elapsed after either the command's process has exited or
	// (if Context is non-nil) Context is done, whichever occurs first.
	// If the command's process is still running after WaitDelay has elapsed,
	// it will be terminated with os.Kill before the pipes are closed.
	//
	// If the command exits with a success code after pipes are closed due to
	// WaitDelay and no Interrupt signal has been sent, Wait and similar methods
	// will return ErrWaitDelay instead of nil.
	//
	// If WaitDelay is zero (the default), I/O pipes will be read until EOF,
	// which might not occur until orphaned subprocesses of the command have
	// also closed their descriptors for the pipes.
	WaitDelay time.Duration
```
new `context` field export order simplifi document `interrupt` `waitdelay` fields. (it request reject #46699, object â€” due concern interact api <em>this</em> proposal. could excis propos without damag anyth document clarity.)
new `interrupt` field set signal sent `context` done. `exec.commandcontext` explicitli set `os.kill` order maintain exist behavior `exec.commandcontext`, expect mani user unix platform want set `os.interrupt` `syscall.sigquit` instead.
new `waitdelay` field set interv wait input output process termin interrupt signal. interv turn import mani test applic (such go playground implement `cmd/go` test suite). also gener nice use-cas #23019: set `waitdelay` without `context` provid bound i/o wait time without send preced signal.
### compat
believ propos entir backward-compat (in contrast #23019). zero-valu new field provid exactli behavior `cmd` return `exec.command` `exec.commandcontext` today.
### caveat
propos address grace shutdown window ( cc @mvdan). however, may possibl extend provid special-cas window behavior `interrupt` field set `os.interrupt`, ad `interruptfunc func(*cmd)` callback would also invok `context` done.
propos api also provid mechan send `interrupt` signal follow `os.kill` delay <em>but still wait subprocesses</em> close i/o pipes. believ use-cas scenario suffici nich provid third-parti libraries: send `sigkill` parent process make like subprocess know shut down, vast major case user either send `sigkill` (`waitdelay` == 0), forcibl termin pipe tri kill subprocess `sigpipe` (`waitdelay` > 0), someth platform-specif tri forcibl shut entir process group (outsid scope proposal).
### altern consid
@bradfitz suggest field `kill func(*os.process)`, would presum ad instead `interrupt` field proposal. however, believ field would simultan complex power enough:
* `kill` field would complex unix applications, overwhelmingli need send one `sigterm`, `sigint`, `sigquit`, `sigkill` â€” pass whole callback realli want say signal need?
* `*os.process` callback would still power enough window applications. understand discuss #6720 correctli (cc @alexbrainman), `ctrl_break_event` sent entir process group, singl `*os.process`, window user would also need mechan creat (or determining) group, complet separ out-of-band way request process termin (such send particular input ipc message).
given above, `interrupt` field seem ergonomic: give right behavior unix users, window user want someth complex set `interrupt` `nil` start separ goroutin call `(*cmd).start` `(*cmd).wait` implement whatev custom logic want.
chang mention issue: `internal/moreexec: add util packag manipul os/exec.cmd`
> // command' process still run waitdelay elapsed,
> // termin os.kil pipe closed.
think may innat race-pron theoretically, process termin replac new process pid check kill. vagu recollect someon told there' fanci new featur linux could bypass this, admittedli small window larg amount stuff happen.
bit unclear mean export fields. requir set prior launch command, chang lifespan command? happen chang c.interrupt start process? happen write new valu c.context process running, close previou context? etc.
sure answer be, pretti sure reason plausibl answer fine, think explicit. think favor "context read-onli field command started, interrupt waitdelay writeable".
> process termin replac new process pid check kill.
#13987, seem orthogonal.
> bit unclear mean export fields. requir set prior launch command, chang lifespan command?
like (existing) export field `exec.cmd`: must set prior `start` (or equilavent) modifi `wait` (or equivalent) returns.
issu 13987, new circumst hit might non-obvi user, assum kill "the" process, pick right one.
that' true, appli equal (numerous) workaround build behavior top `os/exec.cmd` today. (i think propos make race _worse_ anybodi alreadi is.)
> theoretically, process termin replac new process pid check kill. vagu recollect someon told there' fanci new featur linux could bypass this, admittedli small window larg amount stuff happen.
go standard librari alreadi use featur (the `waitid` `wait6` system call option `wnowait`) linux, dragonfly, freebsd. (for use `waitid` maco stop due #19314.)
> however, note #23019 (comment) #23019 (comment), feasibl implement propos requir use arbitrari timeout, propos includ mechan adjust timeout. (given histori go project' builders, extrem skeptic particular hard-cod timeout strike appropri balanc robust latency.)
share concern enthusiastically. depend program executing, environ context, may need differ timeouts. also agre let user decide. much would love go "do right thing" without extend api, think without introduc footguns.
> believ propos entir backward-compat (in contrast #23019). zero-valu new field provid exactli behavior `cmd` return `exec.command` `exec.commandcontext` today.
origin given thumb up, move thumb instead :) even think #23019 might qualifi break change, given may break unlucki program timeout may lead lose output.
think more, one interest caveat: error behavior.
stop read program' output eof, may use caller know that. stop output eof seem orthogon exit statu program, `wait` similar method current report.
set `waitdelay` caus `wait` similar method return differ error end forcibl close i/o pipes?
interrupt field seem super use me.
however, imho ad context field simplifi document might end hurt help understand two way pass context. especi read this:
> // interrupt non-nil, context must also non-nil interrupt
> // sent child process context done.
someon might ask themselves: pass context field also use commandcontext?
> imho ad context field simplifi document might end hurt help understand two way pass context.
note without context field, would still explain `interrupt` use (or effect) `cmd` instanc return `commandcontext`. sure remov would help confus much. ðŸ˜…
> someon might ask themselves: pass context field also use commandcontext?
probabl could updat `commandcontext` doc comment explicitli state set `context` `interrupt` fields?
> set `waitdelay` caus `wait` similar method return differ error end forcibl close i/o pipes?
gave thought arriv at:
* set `waitdelay` chang exit code command fails. fact command fail almost alway enough caller know output may suspecct.
* however, command exit success statu (that is, `wait` would otherwis return `nil`) forcibl close pipes, return distinguish error (perhap new `exec.errwaitdelay`?) caller know input and/or output may truncated.
thought appropri window behaviors. ad â€œaltern consideredâ€ section remov futur option `ctrl_break_event`, sinc per #6720 seem feasible.
instead, window `start` method fail error wrap `syscall.ewindows` specifi `interrupt` signal support (that is, either `nil` `os.kill`).
propos ad activ column propos project
review weekli propos review meetings.
â€” rsc propos review group
seem like doc need distinguish call cmd.stdin cmd.stdout/cmd.stderr. cmd.stdin alreadi close finish write whatev standard input, independ exiting/waiting/cancellation.
also confus waitdelay descript mix cancel ordinari exits.
mayb would help see diff would implement this? look cl 373005 whole package, diff.
> seem like doc need distinguish call cmd.stdin cmd.stdout/cmd.stderr. cmd.stdin alreadi close finish write whatev standard input, independ exiting/waiting/cancellation.
hang due `stdin` copi analog one involv `stdout` `stderr` occur command spawn subprocess `cmd.stdin = os.stdin` exit without either process read `stdin` completion. (the copi goroutin start `(*cmd).stdin`, close pipe copi complet â€” may arbitrarili long write fit whatev buffer kernel provides.)
so, least case, realli need treat i/o pipe symmetrically.
thank clarif stdin.
still feel like would help see diff package, oppos fork cl 373005. still 100% sure understand proposal.
found anoth â€œrun killâ€ function main go repo, one even bother use appropri signal (it skip straight `sigkill`):

manifest less-than-us failur mode #50973.
still littl confus implic here. like see concret cl understand better. leav open week, let know rather put hold now.
hold concret cl.
**place hold**.
â€” rsc propos review group
chang mention issue: `os/exec: implement interrupt waitdelay`
chang mention issue: `os/exec: clean pipe-clos logic`
chang mention issue: `os/exec: export context field`
chang mention issue: `os/exec: split local pipe whether pump user code intern goroutines`
chang mention issue: `os/exec: make bodi wait eager`
chang mention issue: `os/exec: make skipstdincopyerror function instead variable`
> like see concret cl understand better.
draft implement (on top bunch refactor help clarifi specif changes) contain
(i believ refactor portion stack improv codebas independ proposal, portion effect export api.)
