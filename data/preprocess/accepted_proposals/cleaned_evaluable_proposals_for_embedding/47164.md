log: optim setoutput(io.discard)
**_edit_**: discuss comments, propos anymor use `nil` receiver. still make cheaper call disabl (muted) logger.
##
make `nil` pointer variabl
```
var nilLogger *log.Logger
```
valid logger, call `nillogger.print`, etc. valid (do crash), produc actual logs.
would serv adequ replac of, almost equival to:
```
var discardLogger = log.New(io.Discard, "", 0)
```
##
performance.
import concern log often expensive, reason expect becom free (or cheap) log turn off. currently, `discardlogger` come quit expens overhead:
1. `discardlogger.print` variad argument evaluated, even realli needed;
2. non-inlin function call `(*logger).print`i execut
3. `fmt.sprint` called, incur memori allocation, work use variad argument order produc string `s`;
4. mutex `discardlogger.mu` `lock`ed, later `unlock`ed;
5. `s` copi intern buffer `discardlogger.buf`;
6. dynam function dispatch execut `discardlogger.out.write`, resolv `io.discard.write`.
propos implement consist check nil receiv insid export method return immediately, thu avoid step 3, 4, 5, 6.
propos implementation, step 1, 2 still happen, argument still evaluated. theori could mitig side-effect-fre cases, advanc escap analysi inlining. mitig reach current inlin system, scope current proposal.
## benefit
sampl benchmark, `nillogger.printf` **35x faster** `int` arg, **320x faster** `map` arg, `discardlogger.printf`.
speedup would higher arguments, complex arguments.
side effect, zero valu pointer type `*log.logger` becom use safe, without initialization.
## backward compat
- chang non-`nil` *log.logg instances.
- `log.new(io.discard, "", 0)` still works.
- `nillogger.print` would panic anymore. program reli panic behavior would break. howev promis (no guarantee) log packag `nillogger.print` panic.
- `nillogger.print` would call `fmt.sprint` anymore, result custom `string` method called. program reli side effect custom string method would break. howev promis (no guarantee) log packag valid logger alway call `fmt.sprint`.
- program may expect `l.setoutput(w)` alway succe valid logger `l`. program would break.
- program may expect `l.setprefix(prefix)` forc subsequ valu return `l.prefix()`, valid logger `l`. program would break.
- program may expect `l.setflags(flag)` forc subsequ valu return `l.flags()`, valid logger `l`. program would break.
## concurr
understand propos implement introduc new risk data races.
`nil` receiver, `print` method thread-safe, requir mutex.
## detail behavior method
receiv `l` `nil`:
- **`(l *logger).fatal(v ...interface{})`**
- **`(l *logger).fatalf(format string, v ...interface{})`**
- **`(l *logger).fatalln(v ...interface{})`**:
- log anything. call `os.exit(1)`.
- **`(l *logger).flags() int`**:
- return `0`.
- **`(l *logger).output(calldepth int, string) error`**:
- nothing. return `nil`.
- **`(l *logger).panic(v ...interface{})`**
- **`(l *logger).panicf(format string, v ...interface{})`**
- **`(l *logger).panicln(v ...interface{})`**:
- log anything. build string `s` call `panic(s)`.
- **`(l *logger).prefix() string`**:
- return `""`.
- **`(l *logger).print(v ...interface{})`**
- **`(l *logger).printf(format string, v ...interface{})`**
- **`(l *logger).println(v ...interface{})`**:
- nothing.
- **`(l *logger).setflags(flag int)`**:
- nothing.
- **`(l *logger).setoutput(w io.writer)`**:
- panic. caller would expect `w` subsequ used, possible.
- **`(l *logger).setprefix(prefix string)`**:
- nothing.
- **`(l *logger).writer() io.writer`**:
- return `nil`.
github ~10k occurr `log.new(ioutil.discard, ..., ...)` occurr `log.new(io.discard, ..., ...)`.
consid sentinel valu `log.noplogger` type `*log.logger`, non-nil.
think offer much benefits, compar `nil` proposal.
cc @robpik
feel like peopl usual threshold-bas logger (i.e., debug, info, warn, error, etc.) surround actual log.logg method calls, case entir log call skip threshold test event log disabled. cases, use nil log.logg mean "discard" increas performance.
also, call method nil technic permissible, think would lead subtl bug exampl someon forget assign struct field, unless go check log notic noth happening, wherea code panic (the current behavior), pretti clear what' wrong.
anoth possibl solut problem would make interfac around log.logg (or least subset method care about), defin anoth implement no-op methods. would still overhead method dispatch, might still enough perform gain you.
possibl surround call log.logg method `if logger != nil` check.
think better option would `log.logger` detect output set `io.discard` short circuit necessary. break anyth would speed exist programs.
@seankhliao unfortun current design, check `(*logger).out==io.discard` would requir first `(*logger).mu.lock`ing, `(*logger).mu.unlock` call export method `(*logger).output`.
would still bear expens synchron cost (the mutex) discard case, would actual make exist program slower gener non-discard case, extra mutex cost.
one substanti advantag `nil` can't hold state, thu unlik caus data races, requir mutex overhead.
> would still bear expens synchron cost (the mutex) discard case, would actual make exist program slower gener non-discard case, extra mutex cost.
wonder perform would compar `log.logger` use sync/atom field instead mutex?
@deleplac tri build `debug` flag compil elid "deadcode".
log.go
```go
package main
func main() {
        Debug("it's expensive")
	if Dev {
		log.Println("we are in develop mode")
	}
}
```
log_debug.go
```go
//+build debug
package main
import (
        "log"
)
const Dev = true
func Debug(a ...interface{}) {
        log.Println(a...)
}
```
log_release.go
```go
//+build !debug
package main
const Dev = false
func Debug(a ...interface{}) {}
```
want debug code `go build -tag "debug"`.
ref (chinese):
@mengzhuo unfortunately, disabl debug log compile-tim pretti much make imposs quickli enabl debug log verbos troubleshoot product problem. gener rule, quicker chang flag deploy build new binary, packag release, get running.
interest consider scope current proposal:
- compile-tim flip off/on log (or level value)
- achiev wrap (*log).logg valu type interfac type
proposal, `mylogg = nil` would equival `mylogg = log.new(io.discard, "", 0)`.
possibl gotcha, data race hazard, realiz
```
myLogger = nil
```
would **not** equival
```
myLogger.SetOutput(io.Discard)
```
* sever copi `mylogger` pointer pass around, latter (setoutput) disabl all, former disabl one them;
* latter (setoutput) alway thread-saf (protect `mylogger.mu`), former need extra extern synchron sever goroutin use `mylogger`;
* latter (setoutput) keep flag prefix intact, former "forgets" (which easi fix needed)
propos ad activ column propos project
review weekli propos review meetings.
â€” rsc propos review group
base discuss above, propos seem like **like accept**.
â€” rsc propos review group
@rsc like suggest boolean field `logger` rather allow receiv `nil`.
```go
type Logger struct {
    isDiscard bool
    ...
}
var Discard = &Logger{isDiscard: true}
func (l *Logger) Output(calldepth int, s string) error {
    if l.isDiscard {
        return nil
    }
    ...
}
```
give perform benefit allow receiv `nil`, without concern someon unintent left struct field `nil`. sinc field immutable, worri thread-safeti read it.
also lead to, think, clearer code client side. otherwis peopl know `nil` logger valid (which, valid go, fairli unusual).
could also invert bool want struct' zero valu no-op logger.
like idea, @rittneje. made avail interface, construct time, one could disabl log dynamically, could handi debug program use librari log much problem.
one small point: prefer posit name neg true. suggest call enable, default true. work logger use zero value. (however, discard known name, advantag well.)
import note happen `(*logger).output`: okay check condit bodi output (a export method, least consid it). perform concern, output call alreadi late (3) `fmt.sprint` alreadi called, alreadi alloc memory, possibl call custom expens `string` method arguments.
crucial check condit earli insid `(*logger).printf`, `(*logger).print`, `(*logger).println`.
strong candid here, exact cost perform gain burden client code:
a) valid `nil` pointer
b) sentinel valu `log.noplogger` type `*log.logger`
c) bool field `logger.isdiscard`, immut
d) bool field `logger.isdiscard`, mutable, `(*logger).setdiscard(bool)` thread-saf call `(*logger).mu.lock`
e) bool field `logger.isdiscard`, mutable, `(*logger).setdiscard(bool)` thread-saf
import abl disabl log dynamically, howev (d) would incur perform penalti requir **_all call (*logger).print_** also call `(*logger).mu.lock`. point propos avoid much unnecessari work sync possibl disabl case.
(e) would caus burden user extern synchronization, unexpect method thread-saf via `(*locker).mu`.
(a), (b), (c) perform obviou user need proper synchron `(*logger)` pointer variabl itself. e.g.:
**turn logger off**
`mylogg = log.discard`
**turn logger on, creation**
`mylogg = log.new(w, prefix, flag)`
**turn logger on, reuse**
`mylogg = savedlogger`
@deleplac want point (d), could also `uint32` flag access via `atomic.loaduint32` `atomic.storeuint32`, similar `sync.once` works.
seem like reus nil would help catch mistakes. @rittnej point out, flag atom boolean, overhead print path (and discard path) singl atom word read. seem like probabl cheap enough.
abl toggl whole logger benefit find differ place might pass logger overwrit all.
wonder setoutput(io.discard) discard signal?
(instead separ new api call. would work old version too, fast, would safe use newer code without break older code.)
retitled, leav week seem head like accept new scoping.
summari perform delta "initi scoping" vs "new scoping"
### origin proposal:
- save expens call `fmt.sprint` `fmt.sprintf`
- save expens synchron cost call `(*logger).mu.lock` `(*logger).mu.unlock`
### new scoping:
- save expens call `fmt.sprint` `fmt.sprintf`
- replac expens synchron cost `(*logger).mu.lock` `(*logger).mu.unlock` cheaper call `atomic.loaduint32` `atomic.storeuint32`
familiar atomics, could pleas agre list concern new scoping?
1. new scope would automag bring perform benefit thousand project alreadi use ioutil.discard/io.discard mute *logger (that would fantastic!)
2. atom cheaper use case general-purpos sync.mutex alreadi contain log.logg
3. zero chang need export api `log` packag
4. reason confid abil mix 2 synchron devic (mutex + atomics) log packag implement without introduc new data race hazard
5. usual **non-muted** case, introduc much overhead (mayb 1 extra call `atomic.loaduint32`?)
6. advantag new scope overweight cost still pay synchron cost mute case. target goal shift "call mute logger essenti free" "call mute logger cheap".
7. "i muted" check would implement `l.out == io.discard` `l.isdiscard` (to determined)
happi "like accept" prospect form proposal. thank support.
@deleplace, 7, setoutput call would check == io.discard set atom boolean (in int32), 'i muted' check would use call like log.printf.
base discuss above, propos seem like **like accept**.
â€” rsc propos review group
> 2. atom cheaper use case general-purpos sync.mutex alreadi contain log.logg
yes. way cheaper, number cpu core use grows: acquir `sync.mutex` invalid cach line contain mutex, wherea atom load (that modifi value) invalid anyth steadi state.
> 4. reason confid abil mix 2 synchron devic (mutex + atomics) log packag implement without introduc new data race hazard
`sync.map` alreadi aggress mix synchron primitives. fine. ðŸ˜…
chang consensus, **accepted**. ðŸŽ‰
