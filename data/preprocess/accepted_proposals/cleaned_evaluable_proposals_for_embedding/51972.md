sync: add new map method compareandswap, compareanddelete, swap
propos ad new method `sync.map` similar `atomic.value`' `swap()` method. think either name `loadandstore()` match exist loadorstor `swap()` match `atomic.value` would make sense. function signatur would look someth like
```go
func (m *Map) LoadAndStore(key, newValue any) (previous any, loaded bool)
```
think fact alreadi exist `atomic.value` good argument use case it. thing could achiev creat `sync.map` `atomic.value`s, lot type-assertion, stare pretti hard make sure free race conditions. specif use case basic de-bounc abus reports. worker detect abus client would
```go
lastReport, hasReportHistory := lastReportTimes.LoadAndStore(clientIP, time.Now())
if hasReportHistory && time.Since(lastReport.(time.Time)) < time.Hour {
    log("not re-sending abuse report")
    return
}
sendAbuseReport(clientIP)
```
cc @bcmill
propos ad activ column propos project
review weekli propos review meetings.
â€” rsc propos review group
@bcmills, think?
`func (m *map) swap(key, valu any) (previou any, load bool)` seem like reason addit me.
right granular fit `map` method (onli synchron access specif key, similar atom properti `loadorstore`), enabl code pattern otherwis complic inefficient.
may also want consid `compareandswap` `compareanddelete` time parallel `(*atomic.value).compareandswap`, ad along `swap` propos #39351. might look like:
```go
// CompareAndSwap swaps the old and new values for key
// if the value stored in the map is equal to old.
// The old value must be of a comparable type.
//
// If old is the nil interface value, the swap will occur if either there
// is no existing value for the key or the existing value is also the
// nil interface.
func (m *Map) CompareAndSwap(key, old, new any) (swapped bool)
// CompareAndDelete deletes the entry for key if its value is equal to old.
// The old value must be of a comparable type.
//
// If there is no current value for key in the map, CompareAndDelete
// returns false (even if the old value is the nil interface value).
func (m *Map) CompareAndDelete(key, old any) (deleted bool)
```
chang mention issue: `sync: add new map method swap`
anyon object ad swap, compareandswap, compareanddelete?
prototyp compareanddelete, got thinking: realli make sens `compareanddelete`?
`sync.map` two map insid optim read-most context.
sinc atom compar delet primitive. read map compar old value, delet atomically? could yet make sens implementation:
```go
func (m *Map) CompareAndDelete(key, old any) (deleted bool) {
	read, _ := m.read.Load().(readOnly)
	if e, ok := read.m[key]; ok {
		if e.tryCompareAndSwap(&old, nil) {
			// Here is clearly(?) non-atomic
			// what if something happens between the above CAS and below delete?
			// Is it possible?
			delete(read.m, key)
			deleted = true
			return
		}
	}
	m.mu.Lock()
	...
}
```
someth go right direct implementation? look like lock entir map proceed? overthink here? fast path case?
@changkun, use case `compareanddelete` delete, say, stale entri cach (which otherwis could right properties).
key hit read-onli map, entri still remain mark deleted.
base discuss above, propos seem like **like accept**.
â€” rsc propos review group
chang consensus, **accepted**. ðŸŽ‰
