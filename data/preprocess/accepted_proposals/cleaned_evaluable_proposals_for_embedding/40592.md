reflect: add func (value) unsafepointer() unsafe.point
split separ [mi comment #40481, per @rsc' suggestion.]
propos add method
```
func (v Value) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(v.Pointer()) }
```
would allow caller migrat `value.addr` `value.pointer` later could deprec (fulfil todo [\[1\]]( [\[2\]]( elimin class possibl misus `unsafe.pointer`.
optionally, also `go fix` rewrite:
1. `unsafe.pointer(v.pointer())` -> `v.unsafepointer()`
2. `unsafe.pointer(v.unsafeaddr())` -> `v.addr().unsafepointer()`
3. `v.pointer()` -> `uintptr(v.unsafepointer())`
4. `v.unsafeaddr()` -> `uintptr(v.addr().unsafepointer())`
replac `v.unsafeaddr()` `v.addr().unsafepointer()` slight ad cost `v.unsafeaddr()` abl simpli directli return address pointer, `addr()` potenti comput result pointer' type. however, `(*rtype).ptrto` alreadi use caching, compil also alreadi eagerli gener `*t` type types, expect practic neglig overhead.
--
tangentially, `interfacedata` method also todo deprecate. think there' anyth prevent deprec today. caller probabl use `elem()` get `value` repres concret value, someth base `kind()`.
within google' intern go code base, two use `reflect.value.interfacedata` appear be:
1. look like dead code anyway: `reflect.valueof(...).kind()` never return `reflect.interface`.
2. need fix anyway sinc use `reflect.sliceheader` incorrectli too.
recollect one reason `value.pointer` return `uintptr` want prevent code like
p := v.pointer()
give `p` type `unsafe.pointer` packag import unsafe. cours alreadi use packages, want encourag standard library.
(thi also get us discuss type base alia analysis. ordinari go code pointer `*byte` pointer `*int` must alway point differ locations, chang memori one pointer can't affect memori chang pointer. statement longer true either valu set via convers `unsafe.pointer`. mean compil never assum point differ locations, say assumpt chang base whether packag import unsafe?)
type-bas alia analysis: even packag import `unsafe` assum variabl alia alloc within package. (a caller alway suppli pre-pun pointer arguments.)
think want deep reason alias would gener need whole-program analysi either way.
> recollect one reason value.point return uintptr want prevent code like `p := v.pointer()` give p type unsafe.point packag import unsafe.
yes, reason justifi back go support "safe" mode, remov back 2018. mani better way run untrust go program today (e.g., within process sandbox like gvisor compil wasm).
> also get us discuss type base alia analysis.
seem like orthogon concern me. way safe use `reflect.value.pointer` `reflect.value.unsafeaddr` pointer valu today immedi convert `unsafe.pointer` anyway.
somewhat orthogon perhap entir negligible: see #26070.
see mention type-bas alia analysi #26070. elabor related?
connect see happen peopl write `p := v.unsafepointer()` packag import unsafe, adopt #26070. confus use `:=` get `unsafe.pointer` can't use?
perhap concern important.
see. wrote "thi seem like orthogon concern me," "this" refer type-bas alia analysis. wrote "it' somewhat orthogonal," thought still talk type-bas alia analysi too.
assum #26070 propos accepted, expect user would adapt write `import _ "unsafe" // unsafe.point conversion` analog write `import _ "unsafe" // go:linkname` today. (though comment #26070, disagre proposal.)
#26070 retracted.
rememb it, picki import "unsafe" get unsafe.point (and provid way get one otherwise) two reasons:
1. good practic call unsaf part code clearly, import that.
2. app engin need kept use unsafe.
(2) longer concern, (1) seem well enough handl name v.unsafepointer, seem clearli "unsafe" `import "unsafe"`.
overal seem like fine change. might worth think go 1.17 along unsafe/point cleanup.
base discuss above, seem like **like accept** (for go 1.17).
chang consensus, accepted.
> replac v.unsafeaddr() v.addr().unsafepointer() slight ad cost v.unsafeaddr() abl simpli directli return address pointer, addr() potenti comput result pointer' type. however, (*rtype).ptrto alreadi use caching, compil also alreadi eagerli gener *t type types, expect practic neglig overhead.
sure this. spent time optimis reflect base encoder. start per-field loop
```
for _, f := range fields {
    f.codec.encode(writer, v.Field(f.index)) 
}
```
end 22% cpu time moder simpl benchmark spent `value.field`
decid tri optim use (a first pass) `value.unsafeaddr()` `reflect.newat(t, p)`
```
p := unsafe.Pointer(v.UnsafeAddr())
for _, f := range fields {
    f.codec.encode(writer, reflect.NewAt(f.ty, unsafe.Pointer(uintptr(p) + f.offset)).Elem()) 
}
```
result was... 33% cpu time spent `reflect.newat` (and anoth 11% `value.elem()`). cpu time spent `ptrto`/`typeoff` (and get wors case fall path `sync.map` cache)
probabl big deal grand scheme things; overhead realli notabl spent bunch effort optim aspect (and way work around gener case), there' still optim done avoid reflect overhead mani cases, make kind optim bit trickier (in like bump situat accident made thing slower)
make coupl requests, be:
1. equival unsafeaddr,
2. inverse, i.e. function equival `reflect.newat(t, p).elem()` (fail that: variant `reflect.newat` type paramet alreadi pointer?)
chang mention issue: `reflect: add value.unsafepointer`
chang mention issue: `reflect: add test method valu code pointers`
chang mention issue: `doc: document new reflect.unsafepoint function`
chang mention issue: `encoding/json: use reflect.value.unsafepoint pointer`
