net: add context-awar dialer method dialtcp, dialudp, dialip, dialunix
accept propos add new method `new.dialer`:
--
like given below:
```golang
func DialTCP(network string, laddr, raddr *TCPAddr) (*TCPConn, error) {
	return DialTCPContext(context.Background(), network, laddr, raddr)
}
func DialTCPContext(ctx context.Context, network string, laddr, raddr *TCPAddr) (*TCPConn, error) {
	switch network {
	case "tcp", "tcp4", "tcp6":
	default:
		return nil, &OpError{Op: "dial", Net: network, Source: laddr.opAddr(), Addr: raddr.opAddr(), Err: UnknownNetworkError(network)}
	}
	if raddr == nil {
		return nil, &OpError{Op: "dial", Net: network, Source: laddr.opAddr(), Addr: nil, Err: errMissingAddress}
	}
	sd := &sysDialer{network: network, address: raddr.String()}
	c, err := sd.dialTCP(ctx, laddr, raddr)
	if err != nil {
		return nil, &OpError{Op: "dial", Net: network, Source: laddr.opAddr(), Addr: raddr.opAddr(), Err: err}
	}
	return c, nil
}
func DialUDP(network string, laddr, raddr *UDPAddr) (*UDPConn, error) {
	return DialUDPContext(context.Background(), network, laddr, raddr)
}
func DialUDPContext(ctx context.Context, network string, laddr, raddr *UDPAddr) (*UDPConn, error) {
	switch network {
	case "udp", "udp4", "udp6":
	default:
		return nil, &OpError{Op: "dial", Net: network, Source: laddr.opAddr(), Addr: raddr.opAddr(), Err: UnknownNetworkError(network)}
	}
	if raddr == nil {
		return nil, &OpError{Op: "dial", Net: network, Source: laddr.opAddr(), Addr: nil, Err: errMissingAddress}
	}
	sd := &sysDialer{network: network, address: raddr.String()}
	c, err := sd.dialUDP(ctx, laddr, raddr)
	if err != nil {
		return nil, &OpError{Op: "dial", Net: network, Source: laddr.opAddr(), Addr: raddr.opAddr(), Err: err}
	}
	return c, nil
}
func DialIP(network string, laddr, raddr *IPAddr) (*IPConn, error) {
	return DialIPContext(context.Background(), network, laddr, raddr)
}
func DialIPContext(ctx context.Context, network string, laddr, raddr *IPAddr) (*IPConn, error) {
	if raddr == nil {
		return nil, &OpError{Op: "dial", Net: network, Source: laddr.opAddr(), Addr: nil, Err: errMissingAddress}
	}
	sd := &sysDialer{network: network, address: raddr.String()}
	c, err := sd.dialIP(ctx, laddr, raddr)
	if err != nil {
		return nil, &OpError{Op: "dial", Net: network, Source: laddr.opAddr(), Addr: raddr.opAddr(), Err: err}
	}
	return c, nil
}
```
could give inform reason want add used? thanks.
as:
```golang
ctx, cancel := context.WithTimeout(context.Background(), 30000*time.Millisecond)
defer cancel()
taddr := &net.TCPAddr{}
c, err := net.DialTCPContext(ctx, "tcp", nil, taddr)
...
```
realiz timeout process dialtcp.
dialudp dialip similari like this.
> hi @nkeonkeo - does? would propos allow possibl today? thanks!
`dialer.dialcontext` resolv address time, may caus error like:
`lookup xxxx.com 223.x.x.x:53: read udp 180.x.x.x:7792->223.x.x.x:53: i/o timeout`
use `net.dialtcp` dial `net.tcpaddr` avoid problems.
hope use `net.dialtcp` `context` deal timeout problems.
could add net.dialer, use instead ad new context-awar version top-level functions. specif method need add would be:
dialtcp(context.context, string, *tcpaddr, *tcpaddr) (*tcpconn, error)
dialudp
dialip
dialunix
note take context say "context" name.
thoughts?
propos ad activ column propos project
review weekli propos review meetings.
â€” rsc propos review group
object ?
introduct net/netip, probabl make new method use type (netip.addrport) instead tcpaddr, udpaddr.
sound like ad method net.dialer:
dialtcp(context.context, string, netip.addrport, netip.addrport) (*tcpconn, error)
dialudp(context.context, string, netip.addrport, netip.addrport) (*tcpconn, error)
dialip(context.context, string, netip.addr, netip.addr) (*tcpconn, error)
dialunix(context.context, string, *unixaddr, *unixaddr) (*unixconn, error)
anyon object these?
base discuss above, propos seem like **like accept**.
â€” rsc propos review group
chang consensus, **accepted**. ðŸŽ‰
