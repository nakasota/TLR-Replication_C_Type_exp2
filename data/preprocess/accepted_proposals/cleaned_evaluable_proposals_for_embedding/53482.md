net: add flagrun flag struct interface, exactli reflect state interfac nic
hi, team,
### version go use (`go version`)?

$ go version
go version go1.18.3 linux/amd64

### issu reproduc latest release?
yes, is.
### oper system processor architectur use (`go env`)?
ubuntu 20.04
### do?
inspect flag interfac object check nic run state.
```
	intfs, _ := net.Interfaces()
	for _, intf := range intfs {
		log.Printf("NIC name: %s, flags: %s\n", intf.Name, intf.Flags)
		if intf.Flags & net.FlagUp != 0 {
			// I expect this interface 'intf' is up and in running state, but it is not.
		}
	}
```
but, althought nic(s) flagup flag, check `ip addr | grep state`, found **down** state actually.
**the situat is:** fiber twisted-pair cabl plug nic, run `ip link set xxx up` set administr manually.
#### environment:
>1. manual set nics(ens1f0/eno1/ens1f1/eno2/eno3) administr purpose, leav nics(ens2f0,ens2f1) without operation. and, cable/fib plug them.
>2. nic(eno4) plugged, automat up.
output `ip addr | grep state`, pleas pay attent `state down` words:
```
XXX@XXX:~# ip addr | grep state
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
2: ens1f0: <NO-CARRIER,BROADCAST,MULTICAST,UP> mtu 1500 qdisc mq state DOWN group default qlen 1000
3: eno1: <NO-CARRIER,BROADCAST,MULTICAST,UP> mtu 1500 qdisc mq state DOWN group default qlen 1000
4: ens1f1: <NO-CARRIER,BROADCAST,MULTICAST,UP> mtu 1500 qdisc mq state DOWN group default qlen 1000
5: eno2: <NO-CARRIER,BROADCAST,MULTICAST,UP> mtu 1500 qdisc mq state DOWN group default qlen 1000
6: eno3: <NO-CARRIER,BROADCAST,MULTICAST,UP> mtu 1500 qdisc mq state DOWN group default qlen 1000
7: eno4: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq state UP group default qlen 1000
8: ens2f0: <BROADCAST,MULTICAST> mtu 1500 qdisc mq state DOWN group default qlen 1000
9: ens2f1: <BROADCAST,MULTICAST> mtu 1500 qdisc mq state DOWN group default qlen 1000
10: docker0: <NO-CARRIER,BROADCAST,MULTICAST,UP> mtu 1500 qdisc noqueue state DOWN group default
```
### expect see?
expect see **nics(ens1f0/eno1/ens1f1/eno2/eno3)** **nics(ens2f0,ens2f1)** down, **nic(eno4)** up.
### see instead?
actual see **nics(ens1f0/eno1/ens1f1/eno2/eno3)** **nic(eno4)** up, **nics(ens2f0,ens2f1)** down, output snippet program follow:
pleas pay attent `flags: up` words.
```
2022/06/21 20:56:49 NIC name: lo, flags: up|loopback
2022/06/21 20:56:49 NIC name: ens1f0, flags: up|broadcast|multicast
2022/06/21 20:56:49 NIC name: eno1, flags: up|broadcast|multicast
2022/06/21 20:56:49 NIC name: ens1f1, flags: up|broadcast|multicast
2022/06/21 20:56:49 NIC name: eno2, flags: up|broadcast|multicast
2022/06/21 20:56:49 NIC name: eno3, flags: up|broadcast|multicast
2022/06/21 20:56:49 NIC name: eno4, flags: up|broadcast|multicast
2022/06/21 20:56:49 NIC name: ens2f0, flags: broadcast|multicast
2022/06/21 20:56:49 NIC name: ens2f1, flags: broadcast|multicast
2022/06/21 20:56:49 NIC name: docker0, flags: up|broadcast|multicast
```
## conclus
can't distinguish state nic flagup flag follow situations:
>1. interfac plugged, automat up, running(up) state
>2. interfac plugged, administr manual set up, state
## fix bug, send pull request soon :)
add new flag exactli reflect state interfac nic, titl says.
get right exact report follow output, see **nic(lo/eno4)** report **running** state:
pleas pay attent tail `running` word.
```
2022/06/21 21:01:52 NIC name: lo, flags: up|loopback|running
2022/06/21 21:01:52 NIC name: ens1f0, flags: up|broadcast|multicast
2022/06/21 21:01:52 NIC name: eno1, flags: up|broadcast|multicast
2022/06/21 21:01:52 NIC name: ens1f1, flags: up|broadcast|multicast
2022/06/21 21:01:52 NIC name: eno2, flags: up|broadcast|multicast
2022/06/21 21:01:52 NIC name: eno3, flags: up|broadcast|multicast
2022/06/21 21:01:52 NIC name: eno4, flags: up|broadcast|multicast|running
2022/06/21 21:01:52 NIC name: ens2f0, flags: broadcast|multicast
2022/06/21 21:01:52 NIC name: ens2f1, flags: broadcast|multicast
2022/06/21 21:01:52 NIC name: docker0, flags: up|broadcast|multicast
```
anoth words, nic(s) **up** flag **running** flag, set **up** administr manually.
thanks,
mao
chang mention issue: `net: add flagrun flag struct interface, exactli reflect state interfac nic.`
turn issu proposal.
see mark issu proposal, thank @ianlancetaylor .
need do, need wait weekli propos review meet pick activ proposal? :)
littl confus invent new flag appear `ip addr` output. specifically:
6: eno3: <no-carrier,broadcast,multicast,up> mtu 1500 qdisc mq state group default qlen 1000
7: eno4: <broadcast,multicast,up,lower_up> mtu 1500 qdisc mq state group default qlen 1000
problem seem want distinguish eno3 eno4, flag set one 'state down' 'state up'. suggest add new flag run mean 'state up'.
'running' right name that? run bit system might collid with?
hi, @rsc ,
get core problem correctly, thank :)
three reason choos 'running' name:
1. flag interfac real up/down state pars syscal result, correspond `$go/src/net/interface_linux.go: linkflags()` function `$go/src/syscall/zerrors_linux_amd64.go: const iff_running` flag. words, exist constant flag name 'iff_running', inherit 'running' name proposal.
2. flag interfac administr alreadi name 'flagup', order distinguish it, choos 'flagrunning' name.
3. **linkflags()** function **'iff_running'** flag adopt system architectures, linux/amd64, follow:
**linkflags()** function:
```
$go/src/net/interface_linux.go
$go/src/net/interface_aix.go
$go/src/net/interface_bsd.go
$go/src/net/interface_solaris.go
```
**'iff_running' flag**, constant:
```
$go/src/syscall/zerrors_linux_amd64.go
$go/src/syscall/zerrors_openbsd_arm64.go
$go/src/syscall/zerrors_linux_riscv64.go
$go/src/syscall/zerrors_linux_s390x.go
$go/src/syscall/zerrors_netbsd_386.go
$go/src/syscall/zerrors_aix_ppc64.go
... ...
This flag is defined in more than 30+ *.go files.
We can easily check out this situation by double-press shift
in the Goland IDE and search it.
```
**'iff_drv_running' flag**, mean 'iff_running':
```
$go/src/syscall/zerrors_freebsd_amd64.go
$go/src/syscall/zerrors_freebsd_arm64.go
$go/src/syscall/zerrors_freebsd_arm.go
$go/src/syscall/zerrors_freebsd_386.go
```
so, opinion, good choos `running` `flagrunning` name propos :)
thanks,
mao
confirm: sound like `ip addr` program report kernel iff_run bit print 'state up' (bit set) 'state down' (bit clear). correct? (certainli weird so.)
bit report say 'state unknown' like first comment's:
1: lo: <loopback,up,lower_up> mtu 65536 qdisc noqueu state unknown group default qlen 1000
?
also, look pr #53484, window ever distinguish running? need someth precis there?
hi, @rsc
yes, correct reasonable.
```
Just to confirm:
it sounds like the ip addr program is reporting the kernel IFF_RUNNING bit when it prints 'state UP' (bit is set) or 'state DOWN' (bit is clear).
Is that correct? (Certainly weird if so.)
```
lo(loopback) interface, report `state unknown` `iff_run bit set`, loopback alway running.
```
What bit is it reporting when it says 'state UNKNOWN' like in the very first comment's:
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
```
window distinguish running, need things, ok sync & run state.
```
does Windows ever distinguish UP from RUNNING? Do we need to do something more precise there?
```
thanks,
mao
propos ad activ column propos project
review weekli propos review meetings.
â€” rsc propos review group
sound like bit exist call running, ad uncontroversial.
base discuss above, propos seem like **like accept**.
â€” rsc propos review group
> sound like bit exist call running, ad uncontroversial.
yes, bit right here, want provid everyon use :)
thanks,
mao
chang consensus, **accepted**. ðŸŽ‰
