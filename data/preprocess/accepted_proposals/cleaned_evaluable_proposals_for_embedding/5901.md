encoding/json: allow per-encoder/per-decod registr marshal/unmarsh function
example, user want marshal net.ip custom code, provid way
that, probabl method *encoder. similarli *decoder.
encoding/xml.
comment 1:
_label changed: remov **go1.3**._
comment 2:
_label changed: ad **go1.3maybe**._
comment 3:
_label changed: ad **release-none**, remov **go1.3maybe**._
comment 4:
_label changed: ad **repo-main**._
work sometim back october, cl get convers started.
perhap work go1.9.
introduc encoder.registerencod
```go
func (enc *Encoder) RegisterEncoder(t reflect.Type, fn func(interface{}) ([]byte, error))
```
decoder.registerdecod
```go
func (dec *Decoder) RegisterDecoder(t reflect.Type, fn func([]byte) (interface{}, error))
```
similar requir custom serialization. specif use case are:
1) data anonymization. example, omit ip address json output.
2) data masking. example, omit specif field depend user privileges.
3) omit empti valu (e.g. empti strings). use gener compact documents.
three cases, decis omit field done runtim contextu information.
use case, client interfac implement simpl lookup map, need regist hundr custom marshal (we lot structs).
could use techniqu similar
@rsc still interest featur end? use-cas would happi implement it.
[edit 1] spell
[edit 2]
wonder function signatur
```go
func (enc *Encoder) RegisterMarshaller(t reflect.Type, f func(reflect.Value) ([]byte, error))
```
standard encod expos user leverag them. exampl redactor:
```go
package main
import (
	"bytes"
	"encoding/json"
	"os"
	"reflect"
	"strings"
	"unicode/utf8"
)
func main() {
	enc := json.NewEncoder(os.Stdout)
	text := "My password, foo, is totally secure"
	enc.RegisterMarshaller(reflect.TypeOf(""), StringMarshaller)
	enc.Encode(text)
	// Output
	// "My password, foo, is totally secure"
	enc.RegisterMarshaller(reflect.TypeOf(""), func(value reflect.Value) ([]byte, error) {
		return StringMarshaller(reflect.ValueOf(strings.Replace(value.String(), "foo", "[REDACTED]", -1)))
	})
	enc.Encode(text)
	// Output
	// "My password, [REDACTED], is totally secure"
}
// Largely taken from `func (e *encodeState) `string(s string, escapeHTML bool)` in `encoding/json/encode.go`
// This would exist in encoding/json.
func StringMarshaller(value reflect.Value) ([]byte, error) {
	e := bytes.Buffer{}
	s := value.String()
	escapeHTML := false // TODO: Refactor StringEncoder into a 'htmlEscaping' one and a non 'htmlEscaping' one.
	e.WriteByte('"')
	start := 0
	for i := 0; i < len(s); {
		if b := s[i]; b < utf8.RuneSelf {
			if json.HTMLSafeSet[b] || (!escapeHTML && json.SafeSet[b]) {
				i++
				continue
			}
			if start < i {
				e.WriteString(s[start:i])
			}
			e.WriteByte('\\')
			switch b {
			case '\\', '"':
				e.WriteByte(b)
			case '\n':
				e.WriteByte('n')
			case '\r':
				e.WriteByte('r')
			case '\t':
				e.WriteByte('t')
			default:
				// This encodes bytes < 0x20 except for \t, \n and \r.
				// If escapeHTML is set, it also escapes <, >, and &
				// because they can lead to security holes when
				// user-controlled strings are rendered into JSON
				// and served to some browsers.
				e.WriteString(`u00`)
				e.WriteByte(json.Hex[b>>4])
				e.WriteByte(json.Hex[b&0xF])
			}
			i++
			start = i
			continue
		}
		c, size := utf8.DecodeRuneInString(s[i:])
		if c == utf8.RuneError && size == 1 {
			if start < i {
				e.WriteString(s[start:i])
			}
			e.WriteString(`\ufffd`)
			i += size
			start = i
			continue
		}
		// U+2028 is LINE SEPARATOR.
		// U+2029 is PARAGRAPH SEPARATOR.
		// They are both technically valid characters in JSON strings,
		// but don't work in JSONP, which has to be evaluated as JavaScript,
		// and can lead to security holes there. It is valid JSON to
		// escape them, so we do so unconditionally.
		// See http://timelessrepo.com/json-isnt-a-javascript-subset for discussion.
		if c == '\u2028' || c == '\u2029' {
			if start < i {
				e.WriteString(s[start:i])
			}
			e.WriteString(`\u202`)
			e.WriteByte(json.Hex[c&0xF])
			i += size
			start = i
			continue
		}
		i += size
	}
	if start < len(s) {
		e.WriteString(s[start:])
	}
	e.WriteByte('"')
	return e.Bytes(), nil
}
```
use-cas well, bit specialized. essentially:
1. type (a librari author) use mani user pass `encoding/json` shouldn't.
2. would like make chang type, break users. intent support use type `encoding/json`, can't break user sinc suffici number them.
3. would like use featur propos migrat user implement marshal/unmarsh preserv exact behavior exist today (even buggi wrong).
4. free make chang want make.
prior art, `cmp` packag `comparer` option allow caller overrid comparison specif type tree. abil user specifi custom comparison proven immens power flexible.
even though like someth like this, concerns:
* alreadi case user often complain `encoding/json` slow. addit featur may make thing slower. `cmp`, need check whether given valu node match custom compar signific sourc slow down.
* decis need made whether type overrid support concret type interfaces. concret type easier implement efficiently. however, support interfac provid signific flexibility, also bring signific implement perform costs.
* what' expect behavior `json.marshal` encount type `t`, type overrid custom marshal specifi `*t`? valu addressable, make sens address valu call overrid function. valu addressable?
thank response! comment below:
> alreadi case user often complain encoding/json slow. addit featur may make thing slower. cmp, need check whether given valu node match custom compar signific sourc slow down.
run benchmark would expect map lookup fairli quick. perhap other concern differ scale "slow" i.
> decis need made whether type overrid support concret type interfaces. concret type easier implement efficiently. however, support interfac provid signific flexibility, also bring signific implement perform costs.
interesting. consid support interfaces. moment need concret type overrid user would benefit interfac check will least prototyp it.
[edit] perhap could renam `registermarshaller` `registerconcretemarshaller` introduc `registerinterfacemarshaller` later user need it?
> what' expect behavior json.marsh encount type t, type overrid custom marshal specifi *t? valu addressable, make sens address valu call overrid function. valu addressable?
actual came discuss colleague. prefer would requir user want custom marshal *t declar marshal overrides. could use singl custom marshal would requir overrides.
```
...
var foo = ""
enc.RegisterMarshaller(reflect.TypeOf(foo), StringMarshaller)
enc.RegisterMarshaller(reflect.TypeOf(&foo), StringMarshaller)
...
func StringMarshaller(value reflect.Value) ([]byte, error) {
    ... check if value is a *String, if so deref ...
    ...
}
```
altern perhap modifi signitur `registermarshaller` someth like:
```
func (enc *Encoder) RegisterMarshaller(reflect.Type, bool, func(reflect.Value) ([]byte, error))
```
where, `bool` "true" would match *t fals would match *t, depend pass type. look bit yucki though could made look better use option pattern.
@dsnet imagin might busi holiday want give friendli ping this. thought response?
chang mention issue: `encoding/json: implement type overrid serialization`
logic certainli use `reflect` hood, sure expos public api. propos follow api instead:
```go
// RegisterFunc registers a custom encoder to use for specialized types.
// The input f must be a function of the type func(T) ([]byte, error).
//
// When marshaling a value of type R, the function f is called
// if R is identical to T for concrete types or
// if R implements T for interface types.
// Precedence is given to registered encoders that operate on concrete types,
// then registered encoders that operate on interface types
// in the order that they are registered, then the MarshalJSON method, and
// lastly the default behavior of Encode.
//
// It panics if T is already registered or if interface{} is assignable to T.
func (e *Encoder) RegisterFunc(f interface{})
// RegisterFunc registers a custom decoder to use for specialized types.
// The input f must be a function of the type func([]byte, T) error.
//
// When unmarshaling a value of type R, the function f is called
// if R is identical to T for concrete types or
// if R implements T for interface types.
// Precedence is given to registered decoders that operate on concrete types,
// then registered decoders that operate on interface types
// in the order that they are registered, then the UnmarshalJSON method, and
// lastly the default behavior of Decode.
//
// It panics if T is already registered or if interface{} is assignable to T.
func (d *Decoder) RegisterFunc(f interface{})
```
argument api:
* user api probabl want deal `reflect.type` `reflect.value`, rather want deal concret types. reason, `json.unmarshal` take `interface{}` rather `reflect.value`.
* use `interface{}` loos type safety, propos signatur also type safeti issues. signatur like: `func (enc *encoder) registermarshaller(t reflect.type, f func(reflect.value) ([]byte, error))`, still can't static guarante `t` type type function `f` expect input.
* match what' done api also type-safeti issues. example, `sort.slices` take `interface{}` requir slice kind, rather `reflect.value`.
propos api combin abil handl interfaces, allow someth like:
```go
e := json.NewEncoder(w)
e.RegisterFunc(protojson.Marshal)
e.Encode(v)
```
`protojson.marshal` function match expect function signature. enabl standard `encoding/json` packag abl properli serial `proto.message` type without forc expect everi concret `proto.message` type implement `json.marshaler` interface.
sinc someth need work, upload cl prototyp implement test actual code.
addit thoughts:
* one concern `json.decoder.disallowunknownfields` specifi top-level option theori affect result unmarsh oper recursively. alreadi problem today custom `json.unmarshaler` implement properli respect option (and actual real problem). unfortun ad anoth way option properli propag downward. however, sever problem bad custom `json.unmarshaler` implement sinc locat option specifi like also place custom encod function registered, option properli replic top-level.
* implement check custom function handl current valu type first, valu addressable, also tri check pointer valu type. match behavior `encoding/json` handl check `json.marshaler` `json.unmarshaler` implementations.
* implement call decod function receiv type pointer/interfac input json `null`. also call encod function receiv type pointer/interfac nil. match behavior `encoding/json` handl `json.marshaler` `json.unmarshaler` implementations.
* benchmark yet, expect decod take minim perform hit encod take perform hit custom encoders/decoders.
* gener _might_ enabl greater type safeti propos api, current propos gener allow type parameter granular individu methods.
ad `proposal` label least two propos api issu propos ad api `encoding/json`.
propos use give user abil address follow issu own:
* #10275: encoding: make stdlib type implement textmarshaler/binarymarshal consist
* #21990: encoding/json: support struct tag time.format json marshaller/unmarshal
* #29678: net: add marshaltext/unmarshaltext hardwareaddr
* #33564: crypto/ecdsa: make publickey implement json.unmarshal json.marshal
overall, concern prolifer magic method type `marshaljson`, `unmarshaljson`, `marshaltext`, `unmarshaltext` method attached. maintain number wide use libraries, push back user ask method added. type overrid give user flexibl want, rather forc librari author respons maintain methods.
registerfunc register?
overal seem reason me. would push back littl needing, say, marshaltext types. good type creat good represent default make sense. would hope per-encod registr would necessari exceptions, common cases.
exampl even registr would still seem good accept propos like #33564.
> registerfunc register?
could either. feel strong name.
let' use json.regist like gob.regist (differ kind argument idea).
otherwis seem like **like accept**.
clarify, suggest type-overrid registr top-level `register` *function* mere suggest `decoder` `encoder` *methods* name `register` consist `gob.register`?
@dsnet, method decoder/encod call register.
clear call site func passed; add much call registerfunc.
chang consensus, accepting.
@dsnet end send cl week self-assign it; see sure bot pick up.
good news, though, seem like proof concept implement could 1.16. note eye help review it.
start review change, got surpris support interfaces. @dsnet wrote:
> decis need made whether type overrid support concret type interfaces. concret type easier implement efficiently. however, support interfac provid signific flexibility, also bring signific implement perform costs.
decis made? look `decodestate.indirect` cl, fan nest loop rather hot function. godoc warn map lookup vs linear search penalti cost. imagin regist ten custom interfac marshal could surprisingli slower regist ten concret type marshalers, api give impression.
use case mention thread: `net.ip` type `[]byte`, `time.time` type `struct`, `ecdsa.publickey` type `struct`, `net.hardwareaddr` type `[]byte`. @dsnet also talk type "they own", @harrisonhjon also mention need concret type matching. anyon compel use case "assign to" interfac matching?
type can't known build time, otherwis can't match concret way, suggest support *a single* `func([]byte, interface{})` fallback use none concret type func match. powerful, also remov expens linear search `go/types.type.assignableto`.
case, suggest first implement featur *without* support interfac types. one go releas support concret types, user tell us realli power enough.
google, import separ fork adventur user alreadi using. abil specifi type-overrid base interfac wide used. cases, typic use captur type implement `proto.message` interface, also use case type natur json support, interfac match allow captur type base public api (a specifi interface) provid custom serial type (base method interface).
> func([]byte, interface{}) fallback use none concret type func match. powerful, also remov expens linear search go/types.type.assignableto.
way implement linear search o(1) type caches, implement seem like prematur optim case mani type-overrid given interfac (expect rare).
also, `func([]byte, interface{})` fallback 1) less perform sinc need call everi node tree, rather name type match interface, 2) compos well disjoint set interfac types, 3) need also provid api saying; "thank call me, actual know serial specif type; pleas tri someth else".
> abil specifi type-overrid base interfac wide used.
would use concret type big problem two use case mention? perhap use protobuf "googl scale", imagin regist dozen concret type enough major programs.
> implement seem like pre-matur case mani type-overrid given interfaces.
elabor bit? quit see cach would work constant time. confid made perform future, worri ad featur once.
> also, `func([]byte, interface{})` fallback [...]
realis singl fallback less powerful, perhap less intuit too. brought seem like current design bound fairli expens linear search design.
also think ship support concret type alon 1.16 would still useful. googler told think features, said, tri use concret type alone. easi way develop outsid googl kind test (and peopl go troubl unless ship release), fear feedback repres go use case outsid google.
> googler told think features, said, tri use concret type alon
concret overrid use to. mention sinc question respond interfac overrides.
> easi way develop outsid googl kind test (and peopl go troubl unless ship release), fear feedback repres go use case outsid google.
someth specif proposing? user featur would great. user care concret type overrides, exist interfac type overrid affect use it. miss something?
> someth specif proposing?
yes; perhap clear. releas 1.16 *just* support concret types, interfac types. smaller less power feature, also simpler faster. tri measur mani peopl find use versu mani peopl still want support interfac types.
avail once, like user jump straight interfac type without think whether use concret type would enough. also perform differ worri me.
(apolog respond out-of-order; reason browser render earlier comment)
> would use concret type big problem two use case mention?
yes. cases, would requir regist dozen (if hundreds) concret types. even worse, requir user manual keep code declar type constantli sync type use json serialization.
> elabor bit? quit see cach would work constant time. confid made perform future, worri ad featur once.
imagin `sync.map` function `map[reflect.type]bool`. cach answer "will type implement set regist interfac type overrides?" cache, queri o(1), not, perform linear lookup regist interfac type overrid (which contend usual close 0).
challeng implement specif cach want use depend set possibl interfac type may want match against. sinc see mani interfac type overrid common pattern, want implement now.
> avail once, like user jump straight interfac type without think whether use concret type would enough. also perform differ worri me.
explain would case? concret type want provid overrid for, seem natur would regist concret type override. seem odd reach interfac overrid unnecessarili case.
example, let' say user want provid type overrid `time.time`, interfac would use match type? seem natur would regist `func(t time.time) ([]byte, error)`. also, would easier implement sinc work concret type easier interfac type (where limit method interface).
