time: make timer/tick channel receiv old valu stop reset return
@rsc said:
> argument make
>
> ```go
> tr := time.newtimer(0)
> tr.stop()
> // may may valu channel now. definit
> // one ad receiv it.
> select {
> case <-tr.c:
> default:
> }
> ```
> work, today, certainli go go 1.7. mayb earli go 1.8 someon want file _different_ bug.
far tell, differ bug filed: document `(*timer).stop` still says:

behavior still result subtl bug (#27169). (note @rsc assum `select` work way
think tighten invari `(*timer).stop` elimin subtlety.
cc @empijei @matttproud @the80srobot @ianlancetaylor
exampl program illustr user might reason expect (and attempt make use of) behavior, see
thank file this.
also found behavior puzzl appar got wrong expect valu sent `t.stop()` returned.
if, understand now, valu might sent call `stop` returned, way correctli re-us timer?
> if, understand now, valu might sent call `stop` returned, way correctli re-us timer?
know goroutin receiv `c` channel, receiv uncondit call `stop` return `false`, actual matter whether valu deliv call `stop` returned.
(the `select`-with-`default` `stop` bug occurs, none exampl post — need to, exampl read `t.c` goroutin call `t.stop`.)
current implementation, probabl done chang `runonetimer` move `cas` away `timerrunning` invoc `f`.
ad propos process resolv whether this, mention #38945.
made first appear propos minut last week.
imagin way break go program this,
```
t := time.NewTimer(1*time.Second)
time.Sleep(2*time.Second)
t.Stop()
<-t.C
```
would succeed today, clear channel `stop` would start blocking.
would defin case `stop` pull element back channel buffer, return true, mean "stopped" timer (fals mean timer alreadi expired; expir would mean "expir observ channel receiv t.c").
hand, technic race here, guarante snippet _never_ blocks, especi load system. correct snippet, even today, is:
```
t := time.NewTimer(1*time.Second)
time.Sleep(2*time.Second)
if !t.Stop() {
    <-t.C
}
```
exampl would unaffected, stop would pull buffer element back channel return `true`, signal caller noth receive.
could make chang start releas cycl readi roll back real (a oppos hypothetical) problem arose.
thoughts?
like behavior pull valu back channel `stop` return `true`, think actual backward-compatible, depend `len` builtin channel interact memori model.
example, program today report race receiv _is_ guarante never block, would deadlock `stop` clear channel:
```go
package main
import (
        "fmt"
        "time"
)
func main() {
        t := time.NewTimer(1 * time.Second)
        for len(t.C) == 0 {
                time.Sleep(time.Millisecond)
        }
        t.Stop()
        <-t.C
        fmt.Println("ok")
}
```
restrict origin propos guarante valu _sent_ `stop` returns.
sorry, sure understand mean guarante valu sent channel `stop` returns. far see, alreadi guaranteed--mayb documentation, certainli implementation. actual chang suggesting?
@ianlancetaylor, program given run indefinit without report delay times. instead, report nonzero rate delay timer sends.
xeon workstation:
```
example.com$ gotip version
go version devel +b2ce3931 Tue May 26 22:28:45 2020 +0000 linux/amd64
example.com$ gotip run main.go
Timer stopped at 2020-05-27 22:16:46.951252699 -0400 EDT m=+2.886904949 subsequently received time
                 2020-05-27 22:16:46.951252454 -0400 EDT m=+2.886904697.
Timer stopped at 2020-05-27 22:17:00.794561424 -0400 EDT m=+16.730213661 subsequently received time
                 2020-05-27 22:17:00.794559263 -0400 EDT m=+16.730211512.
Timer stopped at 2020-05-27 22:17:00.774413697 -0400 EDT m=+16.710065937 subsequently received time
                 2020-05-27 22:17:00.77440917 -0400 EDT m=+16.710061421.
Timer stopped at 2020-05-27 22:17:03.679525664 -0400 EDT m=+19.615177943 subsequently received time
                 2020-05-27 22:17:03.679522832 -0400 EDT m=+19.615178663.
Timer stopped at 2020-05-27 22:17:06.024962313 -0400 EDT m=+21.960614549 subsequently received time
                 2020-05-27 22:17:06.024960025 -0400 EDT m=+21.960612270.
Timer stopped at 2020-05-27 22:17:06.692670731 -0400 EDT m=+22.628322974 subsequently received time
                 2020-05-27 22:17:06.692669848 -0400 EDT m=+22.628322092.
Timer stopped at 2020-05-27 22:17:22.942118175 -0400 EDT m=+38.877770415 subsequently received time
                 2020-05-27 22:17:22.942117468 -0400 EDT m=+38.877769713.
Timer stopped at 2020-05-27 22:17:22.901857123 -0400 EDT m=+38.837509358 subsequently received time
                 2020-05-27 22:17:22.901855958 -0400 EDT m=+38.837508205.
Timer stopped at 2020-05-27 22:17:27.342696328 -0400 EDT m=+43.278348567 subsequently received time
                 2020-05-27 22:17:27.342693224 -0400 EDT m=+43.278345463.
Timer stopped at 2020-05-27 22:17:28.993568136 -0400 EDT m=+44.929220391 subsequently received time
                 2020-05-27 22:17:28.993571601 -0400 EDT m=+44.929223839.
Received 10 delayed times after 128517449 iterations.
```
cases, failur mode same: point _after_ `stop` returns, channel receiv very-slightly-earli timestamp. is: return `stop` synchron actual send channel.
instead, propos send channel, occur all, ought _happen before_ return `stop`.
thank example. code written per document `time.timer.stop`, work correctli (
see happens. `runonetimer` set statu `timernostatus` call function send valu channel, permit `deltimer` therefor `time.timer.stop` return `false` send value. return `false` reliabl mean valu sent channel, valu may sent `stop` returns.
see easi fix current implementation. can't leav timer `timerrunning` state unlock `pp.timerslock` order run function.
would make sens chang timer `timermodifying` state run callback (which short), `timernostatus` callback completes?
(or would potenti induc starvat `time.ticker` short period?)
send-after-`stop` problem appear also appli `time.ticker`, suppos surpris share underli `timer` implementation.
(code reproduc due playground' `faketime` patch.)
actual bit complic thought. leav timer statu `timerrunning` (or `timermodifying`), timer function anyth touch timer, hang. example, scaveng use timer function `wakescavenger` expect stop timer. would hang wait timer leav `timerrunning` status. netpol code also manipul timer timer function, though think caus problem here.
let' tri separ discuss semant implementation.
doc say:
ensur channel empti call stop, check return valu
drain channel. example, assum program receiv
t.c already:
!t.stop() {
<-t.c
}
propos chang semant make receiv ever happen t.stop returns. would mean assumpt - "assum program receiv t.c already" - t.stop would never return fals anymore. code would longer requir (and left alon would never execut body).
would avoid problem peopl know write fixup code understand subtleti involved. certainli confus enough think years.
that' propos semant change.
also question implement - easi "pull item back buffer" suggest - certainli possible. let' figur agre semant change.
(anoth side-effect would probabl len(t.c) would alway return 0, mean channel would appear unbuffered. never promis buffer docs. buffer tri avoid block timer thread. hack.)
agre _could_ chang semant ensur receiv possibl `stop`, would prefer current behavior originally-propos chang disallow send-after-`stop`.
however, see way without break exampl
program explicitli reli buffer behavior `t.c`: specifically, `len(t.c)` becom nonzero timer fires, buffer valu remain receiv `t.stop()`. neither behavior strictli guarante documentation, anyth document explicitli reserv subject chang — observ sinc cl 4063043 nine(!) year ago.
disallow receiv `stop` must necessarili break one two behaviors. mark buffer non-empti retract buffer valu `t.stop()`, program would block forev subsequ receive. instead made channel unbuff — or, equivalently, hook runtim avoid send goroutin readi receiv — program would loop forev wait `len(t.c)` becom nonzero.
way see make chang semant would declar exampl program alreadi incorrect, reli undocu behavior regardless stabil behavior. could wrong, given long behavior place suspect chang would break real programs.
know program call `len` timer channel?
know specifically, given 9-year interv hyrum' law would surpris exist.
will assum program exist (or declar invalid exist, buffer behavior never documented), prevent receiv seem ok.
above, identifi one possibl way semant chang discuss might break code code use `len` poll whether timer gone off. would make `len` report zero time, simul unbuff channel. code depend `len` sometim non-zero could possibl break.
intuit use `len` channel raci almost never better select default case, there' decent chanc much code use len. test hypothesis, search local corpu go packag length timer channel sift result @bcmills. found use `len` timer channel (1) rare, (2) almost alway incorrect, (3) incorrect, alway fix new semantics.
corpu use collect latest major version modul list go index (index.golang.org) late march. 134,485 modul distinct path corpus. those, 17,021 mention `time.newtimer` `time.newticker`. those, 15 modul (slightli 0.1% 17,021) contain code match `len\(.*\.c\)` `len` oper appli timer ticker channel.
15 modul appli `len` timer ticker channel: one awkward simul non-block select, alreadi remov later commit; one use `len` debug print monitor ticker; remain 13 buggy.
semant chang propos issu would make buggi code correct, assum appli chang `reset` discuss `stop`. probabl also appli chang `time.ticker`' `reset` `stop`.
### use len simul non-block select
#### github.com/packetzoom/logslamm
github.com/packetzoom/logslamm version v0.0.3 output/elasticsearch/elasticsearch.go (april 7, 2016)
contain follow code output/elasticsearch/elasticsearch.go:
func readinputchannel(idx *indexer, receivechan chan *buffer.event) {
// drain channel room
idx.bulkservice.numberofactions() < essendbuff {
select {
case ev := <-receivechan:
idx.index(ev)
}
} els {
log.printf("intern elasticsearch buffer full, waiting")
time.sleep(1 * time.second)
}
}
...
// loop event publish elasticsearch
tick := time.newticker(time.duration(esflushinterval) * time.second)
{
readinputchannel(idx, receivechan)
len(tick.c) > 0 || len(es.term) > 0 {
select {
case <-tick.c:
idx.flush()
case <-es.term:
tick.stop()
log.println("elasticsearch receiv term signal")
break
}
}
}
code seem use `len` check altern non-block `select` two channels. also worth note receiv event rare, tick receiv correspond `idx.flush` may arbitrarili delay block receiv `readinputchannel`. possibl select meant non-blocking.
semant chang propos issu would make code never process ticks, sinc `len(tick.c)` would alway zero. however, latest untag commit (februari 17, 2017), test `len(tick.c)` removed. also, lack commit last three years, even tag updat code, suggest code unmaintain longer used.
### use len logging/debug print
#### github.com/uber/cherami-serv
github.com/uber/cherami-serv version v1.28.1 services/outputhost/messagecache.go (novemb 29, 2017) `logpumphealth` method log inform capac length ticker channel, among others:
func (msgcach *cgmsgcache) logpumphealth() {
logpumphealthonce.do(func() {
msgcache.lcllg.withfields(bark.fields{
...
`redeliverytickercap`: cap(msgcache.redeliveryticker.c),
}).info(`cach pump health capacities`)
})
msgcache.lcllg.withfields(bark.fields{
...
`redeliverytickerlen`: len(msgcache.redeliveryticker.c),
}).info(`cach pump health`)
lg := msgcache.lcllg
:= common.now()
...
msgcache.lastredeliverytickerful > 0 {
lg = lg.withfield(`redeliveryticker`, common.unixnanotime(now-msgcache.lastredeliverytickerfull).toseconds())
}
lg.info(`cach pump health last channel full times`)
}
`updatepumphealth method does:
func (msgcach *cgmsgcache) updatepumphealth() int {
:= common.now()
fullcount := 0
...
cap(msgcache.redeliveryticker.c) <= len(msgcache.redeliveryticker.c) {
msgcache.lastredeliverytickerful =
fullcount++
}
return fullcount
}
log would never trigger anymore, pump health updat would regist channel “full” unbuff (length capac 0).
however, repository' readm say project “deprec maintained.”
### raci use len drain channel stop
#### github.com/freezerburn/go-coroutin
github.com/freezerburn/go-coroutin v1.0.1 src/github.com/freezerburn/coroutine/embed.go:
// guarante timer channel drained.
// despit doc say check return valu stop, possibl stop return fals without
// item channel, also double-check item channel attempt
// drain it.
!e.waittimer.stop() && len(e.waittimer.c) > 0 {
<-e.waittimer.c
}
e.waittimer.reset(duration)
<-e.waittimer.c
use `len` potenti race pend send `stop` stop. correct code today would track whether `e.waittimer.c` receiv alreadi use state place length check. fact, sinc code use `e.waittimer`, timer alreadi fire receiv first execut method contain code. everi time method completes, timer expir read from. first execut differ `e.waittimer` initi `time.newtimer(0)`.
propos semant chang `stop` would make code correct: first call, `e.waittimer.stop` would return true—th `stop` prevent zero-dur timer event sent. subsequ iterations, `e.waittimer.stop` would return false—th timer event alreadi receiv previou call—and `len` would zero, bypass no-longer-necessari drain code.
anoth instanc pattern later file:
!e.receivetimer.stop() && len(e.receivetimer.c) > 0 {
<-e.receivetimer.c
}
e.receivetimer.reset(duration)
select {
case <-e.receiver:
case <-e.receivetimer.c:
}
like `e.waittimer`, `e.receivetimer` initi `time.newtimer(0)`.
top that, code record whether select receiv
`e.receivetimer.c`, must proper interpret `stop` result.
lack memori partli compens raci (buggy) `len` check.
analysi applies: `stop` guarante stop futur send,
either receiv alreadi happened, case `stop` return fals
`len` zero, receiv prevented, case `stop` return true.
either way, code would bypass no-longer-necessari drain code.
current latest commit rewrit code snippet use helper differ (avoid `len` entirely) still buggy:
func resettimer(t *time.timer, time.duration) {
!t.stop() {
// seen case stop return false, item channel, caus receiv
// hang forever.
select {
case <-t.c:
default:
}
}
t.reset(d)
}
analysi applies, sinc non-block select less raci “`len` plu receive” operation. remov race length check receiv elimin race delay timer send. propos semant chang would.
#### github.com/matrixainetwork/go-matrix
github.com/matrixainetwork/go-matrix v1.1.7 p2p/buckets.go (may 20, 2020):
{
select {
case <-timeouttimer.c:
...
!timeouttimer.stop() && len(timeouttimer.c) > 0 {
<-timeouttimer.c
}
timeouttimer.reset(time.second * 60)
case h := <-b.blockchain:
!timeouttimer.stop() && len(timeouttimer.c) > 0 {
<-timeouttimer.c
}
timeouttimer.reset(time.second * 60)
...
}
}
code tri make sure iter select fall timeout case 60 seconds.
part succeeds, receiv `b.blockchain` right moment timer went would fail drain `timeouttimer.c`, caus next iter fall timeout case immediately.
race previou example; propos semant chang appli fix.
#### github.com/cobolbaby/log-ag
github.com/cobolbaby/log-ag 71f7f9f watchdog/watchdog.go:
timer := time.newtimer(delay)
...
{
select {
case e = <-eventchan:
...
// timer may active, fire
!timer.stop() && len(timer.c) > 0 {
<-timer.c //ctri drain channel
}
timer.reset(delay)
case <-timer.c:
...
return
}
}
race; fix.
#### github.com/dcarbone/go-cacheman
github.com/dcarbone/go-cacheman v1.1.2 key\_manager.go:
!lifespan.stop() && len(lifespan.c) > 0 {
<-lifespan.c
}
lifespan.reset(km.idlettl)
race; fix (appear four time file).
#### github.com/myena/consultant/v2
github.com/myena/consultant/v2 v2.1.1 service.go:
!refreshtimer.stop() && len(refreshtimer.c) > 0 {
<-refreshtimer.c
}
refreshtimer.reset(ms.refreshinterval)
race; fix (appear three time file).
#### github.com/smartcontractkit/chainlink
github.com/smartcontractkit/chainlink v0.7.8 core/services/fluxmonitor/flux\_monitor.go:
// stoptim stop clear timer suggest documentation.
func stoptimer(arg *time.timer) {
!arg.stop() && len(arg.c) > 0 {
// residu event timer' channel need cleared.
//
// refer timer.stop' document
//
<-arg.c
}
}
race; fix. cours code suggest documentation, although match (incorrect) link blog post.
code remov without comment v0.8.0.
#### github.com/vntchain/go-vnt
github.com/vntchain/go-vnt v0.6.4-alpha.6 producer/worker.go:
// stop command may happen round timer timeout deal
// timeout event, clean channel roundtim needed.
fals == self.roundtimer.stop() && len(self.roundtimer.c) > 0 {
<-self.roundtimer.c
log.warn("worker.roundtimer.c still expir event, cleaned")
}
race; fix.
#### github.com/ebay/akutan
github.com/ebay/akutan 9a750f2 src/github.com/ebay/akutan/util/clocks/wall.go:
timer.stop()
len(timer.c) > 0 {
<-timer.c
}
...
timer.reset(wake.sub(wall.now()))
race; fix.
#### github.com/piotrnar/gocoin
github.com/piotrnar/gocoin 820d7ad client/main.go:
saveblockchain.stop()
len(saveblockchain.c) > 0 {
<-saveblockchain.c
}
common.blockchainsynchron {
saveblockchain.reset(saveblockchainafter)
} els {
saveblockchain.reset(saveblockchainafternosync)
}
race; fix.
### raci use len drain channel reset
#### github.com/qlcchain/go-qlc
github.com/qlcchain/go-qlc v1.3.5 p2p/sync.go:
len(ss.pulltimer.c) > 0 {
<-ss.pulltimer.c
}
ss.pulltimer.reset(pullreqtimeout)
usual pattern previou section, except call `stop`,
receiv race unstop timer instead die gasp stop timer. race same.
chang `reset` guarante `stop`, name send old timer set (befor `reset`) complet `reset` returns, plain call `reset` without `stop` like code becom correct, even without `if` statement. propos change, `if` bodi would never execute.
### raci use len drain channel reset
#### github.com/chenjie199234/corelib
github.com/chenjie199234/corelib 2d8c16542cbe logger/logger.go:
{
select {
case <-tmer.c:
...
tmer.reset(500 * time.millisecond)
len(tmer.c) > 0 {
<-tmer.c
}
case <-l.update:
...
tmer.reset(500 * time.millisecond)
len(tmer.c) > 0 {
<-tmer.c
}
case <-l.refresh:
...
}
}
like previou exampl drain happen `reset`, make race newli reset timer. bad schedul paus introduc half-second delay goroutin execut timer reset drain would caus legitim timer event discarded.
entir packag remov april 20.
### raci use len drain channel without stop/reset
#### github.com/indeedsecurity/carbonbeat
github.com/indeedsecurity/carbonbeat v1.0.0 app/carbonbeat.go:
ticker := time.newticker(bt.config.period)
{
select {
case <-bt.done:
...
return nil
case <-ticker.c:
//remov tick ticker channel, "catch up"
len(ticker.c) > 0 {
<-ticker.c
}
}
...
}
strictli speaking, code wrong, also useful.
ticker channel buffer length 1.
instant receiv completed, buffer almost certainli empty.
check race next send, unlik lose race.
chang `len` alway return 0 discern impact
code.
#### github.com/indeedsecurity/carbonbeat/v2
github.com/indeedsecurity/carbonbeat/v2 v2.0.2 app/carbonbeat.go contain code.
worth, see buggi code evid peopl struggl use current t.stop t.reset correctli single-goroutin use case make much convinc tri propos change.
discuss ongoing, leav anoth week, seem head like accept. pleas speak think bad idea.
think excel idea bet written least one piec code lacks, needs, fixup code.
actual issu old one?
@rogpeppe, ye certainli subsum one. exampl gave would definit chang see real uses, think code fix would break. earli cycl change.
also, comment said library' job "throw away valu alreadi sent channel". fix suggest make channel (indistinguish from) unbuff instead, valu "alreadi sent".
base discuss above, sound like **like accept**.
one possibl implement would be:
1. find bit channel struct mark timer channels.
2. stop inlin chanlen/chancap.
3. make chanlen/chancap return 0 timer channel even though represent buffer size 1.
4. stop/reset, clear buffer there' someth it.
involv implement (see exampl #8898), simpl chang seem like shortest path semant discussing.
chang consensus, accepting.
chang mention issue: `time: avoid stale receiv timer/tick stop/reset return`
chang mention issue: `cmd/compile: compil cap(ch) call runtime.chancap`
look like may happen go 1.23, finally.
discuss said channel would "appear unbuffered", think realiz time (or forgot) that' liter entir semant change: timer channel synchron aka unbuffered. simplif follow that. (the implement subtle, includ hidden buffer optimization, semant effect simpli timer channel behav unbuffered.)
grace rollout, chang chang #8898 disabl godebug=asynctimerchan=1.
found thread tri track test flake - test tri drain channel `<-timer.c` also provid `default:` flag caus old event fail read. glad behavior chang make difficult subtli wrong thing.
tip, final timer get executed. intended?
```Go
package main
import "time"
import "runtime"
func main() {
	timer := time.NewTimer(time.Second)
	runtime.SetFinalizer(timer, func(c *time.Timer){
		println("done")
	})
	timer.Stop()
	runtime.GC()
	time.Sleep(time.Second)
}
```
```
$ gotv 1.22. run main.go
[Run]: $HOME/.cache/gotv/tag_go1.22.1/bin/go run main.go
done
$ gotv :tip run main.go
[Run]: $HOME/.cache/gotv/bra_master/bin/go run main.go
$ 
```
