unicode/utf16: add appendrun
## background
utf16.encod alway alloc `[]uint16` larg enough fit utf-16 encod sequence, realli ergonom forc one allocation.
## propos
**update**, may 27 2022: propos api chang (see to:
```go
// AppendRune appends the UTF-16 encoding of the Unicode code point r
// to the end of p and returns the extended buffer. If the rune is not
// a valid Unicode code point, it appends the encoding of U+FFFD.
func AppendRune(p []uint16, r rune) []uint16
``` 
---
**update**, may 27 2022: follow function supersed previou `appendrune`.
case extra alloc matters, `unicode/utf16` could provid addit encod function accept pre-alloc (and larg enough) back slice.
signatur would look like this:
```go
// EncodeInto writes into a (which must be large enough) the UTF-16 encoding
// of the Unicode code point sequence s.
func EncodeInto(a []uint16, s []rune) []uint16
```
optionally, order know minimum size back array, `unicode/utf16` could provid addit function count number code unit code point sequence.
would look someth like this:
```go
// Countreturns the number of code units in p.
// Invalid encodings are treated as single runes of width 1 byte.
func Count(s []rune) int {
	n := len(s)
	for _, v := range s {
		if v >= surrSelf {
			n++
		}
	}
	return n
}
```
worth north `utf16.encode` could implement use `utf16.count` `utf16.encodeinto`.
## exampl
specif use case allow `x/sys/windows/mkwinsyscall` gener syscal wrapper accept `string` argument without allocating, least short strings. check comment context.
`utf16.encodeinto` could implement non-alloc wrapper follows:
```go
func Foo(s string) {
	p := []rune(s + "\x00")
	l := utf16.Count(p)
	var a []uint16
	if l < 32 {
		a = make([]uint16, 32)
	} else {
		a = make([]uint16, l)
	}
	a = utf16.EncodeInto(a, p)
	syscall.Syscall6(fnAddr(), 6, 0, uintptr(unsafe.Pointer(&a[0])), 0, 0, 0, 0)
	return
}
```
mayb instead `append` versions, like #50601 #51644 ?
case mayb `count` necessary? could reli `append` growth size buffer correctli (across multipl call `encode`).
> mayb instead `append` versions, like #50601 #51644 ? case mayb `count` necessary? could reli `append` growth size buffer correctli (across multipl call `encode`).
like suggest lot. would match nice utf8.appendrun need `count`, set initi buffer capac enough avoid allocations.
syscal exampl would look like this:
```go
func Foo(s string) {
	p := []rune(s + "\x00")
	a := make([]uint16, 0, 32)
	for _, r := range p {
		a = utf16.AppendRune(a, r)
	}
	syscall.Syscall6(procBCryptGetProperty.Addr(), 6, 0, uintptr(unsafe.Pointer(&a[0])), 0, 0, 0, 0)
	return
}
```
chang mention issue: `unicode/utf16: add appendrune`
prototyp propos cl 409054.
propos ad activ column propos project
review weekli propos review meetings.
â€” rsc propos review group
base discuss above, propos seem like **like accept**.
â€” rsc propos review group
chang consensus, **accepted**. ðŸŽ‰
