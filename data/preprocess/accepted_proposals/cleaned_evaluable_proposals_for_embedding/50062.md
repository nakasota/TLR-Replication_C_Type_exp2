time: add time.zonebound
export `location.lookup()` `location.lookup()` help find dst transitions.
sometim one want find zone transit start ends, alreadi implement non export `func (l *location) lookup(sec int64) (name string, offset int, start, end int64, isdst bool)`
example: need correct '2021-03-28 02:30:00' 'europe/amsterdam', non-exist hour dst transit cet cest, first come valid time.
i.e. requir function take date time dst locat incorrect, correct first follow correct date time.
set time read back may give new time dst transition, like:
expect time.date() chang current behaviour, effici way find dst transit one could easili check dst transit correct one self.
want simpli export current `location.lookup` method. method take return number second unix epoch, export method use `time.time`. export api probabl return indic ambiguity, `time.time` valu exist two differ timezon (e.g., hour 1am 2am repeat typic daylight save time transitions).
want propos use api export? thanks.
propos ad activ column propos project
review weekli propos review meetings.
â€” rsc propos review group
sound like need new method time.tim tell time zone transit either side instant describ time.time? right?
> sound like need new method time.tim tell time zone transit either side instant describ time.time? right?
yes, primari need find time zone transitions, sinc inform alreadi exists, exposed.
thanks.
```Go
// ZoneBounds returns the bounds of the time zone in effect at time t.
// The zone begins at start and the next zone begins at end.
// If the zone begins at the beginning of time, start will be returned as a zero Time.
// If the zone goes on forever, end will be returned as a Time in the very distant future.
// The Location of the returned times will be the same as t.
func (t Time) ZoneBounds() (start, end Time)
--- Comment #6 by martin-sucha ---
Yeah, that might work. I like that `ZoneBounds` is simple. There are a couple limitations of that interface though, see below.
> If the zone goes on forever, end will be returned as a Time in the very distant future.
Should we expose that future time as a constant or add a method to check for it (similar to `IsZero()`) to time.Time? Consider a program that prints the next 10 zone transitions is given a location that goes on forever without transitions, like UTC. That program will need to determine when to stop iterating.
How is the user supposed to iterate backwards in time? Subtract `Duration(1)` from `start` and call `ZoneBounds()` on the result?
So, daylight saving time flag, zone name and offset will be exposed with `Time.IsDST` and `Time.Zone`, right? `IsDST`/`Zone` do lookups currently, is it okay if we first do lookup in `ZoneBounds()` and then again for `IsDST`/`Zone` calls? While we could theoretically cache lookup results in `Time`, I would be cautious about making `Time` bigger.
If we wanted iteration that is O(1) instead of needing to do O(log N) lookup every time, we could cache the zone index, but it would require an additional type. What about something like
```go
type zone struct {
// locat zone part of.
locat *locat
// index current zone location.tx.
// -1 first zone (lookupfirstzone) used.
// 0..len(location.tx)-1 zone start given transit index.
// len(location.tx) use extend string build zone.
index int
// start time zone.
// zero time zone start begin time.
// identifi zone instanc use extend string.
start time
}
// name zone.
func (z zone) name() string
// offset zone east utc.
func (z zone) offset() durat
// start time zone starts.
// zone begin begin time, start return zero time ok false.
func (z zone) start() (start time, ok bool)
// end time next zone starts.
// zone goe forever, end return time distant futur ok false.
func (z zone) end() (end time, ok bool)
// isdst report whether time zone daylight save time.
func (z zone) isdst() bool
// laterzon return next zone.
// later zone, laterzon return (z, false).
func (z zone) laterzone() (later zone, ok bool)
// earlierzon return previou zone.
// previou zone, earlierzon return (z, false).
func (z zone) earlierzone() (earlier zone, ok bool)
// lookupzon describ zone effect t.
// locat time return zone t.location().
func (t time) lookupzone() zone
```
Disadvatages:
* Larger API surface.
Advantages:
* Efficient iteration of zones.
* Easy to add a field to the result in the future if needed.
For a use case like building a VTIMEZONE, we could add methods like:
```go
// isextend return true zone comput extend string.
func (z zone) isextended() bool
// extend return zone extend string.
func (l *location) extend() string
```
However, the name `Zone` might clash with types proposed in #49951. We could use `ZoneIter` instead of `Zone`, but I don't like `ZoneIter` as much as `Zone`.
--- Comment #7 by ianlancetaylor ---
> Should we expose that future time as a constant or add a method to check for it (similar to `IsZero()`) to time.Time?
Fair question.  There is a tension between returning a zero result for the end of time and returning a time in the distant future.  Returning a zero result makes it easy to see that there is no information but harder to write a quick comparison to see whether a time is in range.  Defining a new constant or method extends the API only for purposes of this new method, which seems unfortunate.
> How is the user supposed to iterate backwards in time?
Is this a common operation that needs to be supported efficiently in the low-level time package?
--- Comment #8 by martin-sucha ---
If we are going to expose zone boundaries, we should probably document what a zone boundary is or isn't.
In valid TZif files, it seems that a transition time is when at least one of the following changes (RFC 8536, section 2):
* UT offset
* whether daylight saving time is in effect
* time zone abbreviation
although there is the following in RFC 8536, section 3.2:
> Each value is used as a transition time at which the rules for computing local time may change.
so I'm not sure whether it is guaranteed that something changes.
Also I have no idea how the properties of boundaries look like if we are getting the zone data from another source, for example Windows.
--- Comment #9 by rsc ---
If we wanted to do a scan of all known time zone changes at a given location, then assuming there are N of them, that scan takes O(N log N) with the simple API and O(N) with the complex API. But log N is tiny, since N is two per year. Is it really worth all this new API just to save a small constant factor? It seems hard to believe that it would be.
It seems like in the ZoneBounds API, end needs to be zero if there is no future switch, just so that loops can see a value to terminate with.
--- Comment #10 by rsc ---
@mjonss would the API in https://github.com/golang/go/issues/50062#issuecomment-1006162293 address your use case?
--- Comment #11 by mjonss ---
> @mjonss would the API in [#50062 (comment)](https://github.com/golang/go/issues/50062#issuecomment-1006162293) address your use case?
That should be enough and I agree with keeping it simple. My specific use case is just check the bounds once when the parsing/conversion of a time does not yield the same result (i.e. due to DST transition). But I can also see other use cases needing to loop over a few years.
Also changing `the very distant future` to `zero Time` would make it more complete and still simple to check. So the ZoneBounds() of an UTC location would just return two zero Time.
If performance would be needed, then the data set is also small enough to run once and cache by own implementation.
--- Comment #12 by martin-sucha ---
Also +1 for end to be zero time if the zone goes on forever.
> If we wanted to do a scan of all known time zone changes at a given location, then assuming there are N of them, that scan takes O(N log N) with the simple API and O(N) with the complex API. But log N is tiny, since N is two per year. Is it really worth all this new API just to save a small constant factor? It seems hard to believe that it would be.
That is a good point. I agree that it is not worth adding the complex API.
For the use case of scanning all known time zone changes, there is one piece still missing - a zone with an extend string can repeat transitions forever. Although it seems that it is better to have a method like
```go
// extend return location' extend string time first take effect.
func (*location) extend() (extend string, start time.time)
```
instead of exposing that information as part of the zone lookup. Seems that adding the `Extend()` method or similar could be handled in a separate proposal.
The only remaining question I have is whether we want to add a note to the documentation warning that (some?) zone properties might not change at zone boundaries. For example:
```
// return valu zone isdst might chang zone boundaries,
// subsequ zone requir differ.
```
Does it make sense?
--- Comment #13 by mjonss ---
Since time zones are not stable over time and changes happens frequently, I don't think it makes much sense of iterating over time zone transitions for more than a "few" years (I don't imagine any time zone 'extension' to be left unchanged for more than some 100 years? Hopefully European Union will get rid of theirs eventually...)
--- Comment #14 by rsc ---
The Extend string seems like too much. Those are a cryptic, not terribly well-defined format, and we don't want to expose that as our API for all time.
But adding ZoneBounds seems OK.
--- Comment #15 by rsc ---
It sounds like the current ZoneBounds proposal is:
```
// zonebound return bound time zone effect time t.
// zone begin start next zone begin end.
// zone begin begin time, start return zero time.
// zone goe forever, end return zero time.
// locat return time t.
func (t time) zonebounds() (start, end time)
```
(The difference from iant's comment above is that end is a zero time when there isn't one.)
Do I have that right? Does anyone object to that?
--- Comment #16 by mjonss ---
Looks good to me, no objections.
--- Comment #17 by martin-sucha ---
Looks good to me.
--- Comment #18 by rsc ---
Based on the discussion above, this proposal seems like a **[likely accept](https://golang.org/s/proposal-status#likely-accept)**.
â€” rsc for the proposal review group
--- Comment #19 by rsc ---
No change in consensus, so **[accepted](https://golang.org/s/proposal-status#accepted)**. ðŸŽ‰
