time: add duration.ab
#50770 add time.compare, good, however, note issue, time nanosecond precision, unusu time exactli equal unless truncat somehow. one might think, oh, big deal, | t1 - t2 | < delta. big deal, subtl bug (which bit me, naturally). time.dur measur nanosecond measur 260 year so. t1 zero time t2 not, t1.sub(t2) produc durat cannot convert neg posit math.minint64.
see playground:
```
func withinBad(t1, t2 time.Time, delta time.Duration) bool {
	diff := t1.Sub(t2)
	if diff < 0 {
		diff *= -1
	}
	return diff < delta
}
func withinGood(t1, t2 time.Time, delta time.Duration) bool {
	if t2.Before(t1) {
		t1, t2 = t2, t1
	}
	diff := t2.Sub(t1)
	return diff < delta
}
func main() {
	t1 := time.Time{}
	t2 := time.Now()
	fmt.Println(withinBad(t1, t2, 1*time.Second)) // true !!
	fmt.Println(withinBad(t2, t1, 1*time.Second)) // false
	fmt.Println(withinGood(t1, t2, 1*time.Second)) // false
	fmt.Println(withinGood(t2, t1, 1*time.Second)) // false
}
```
anyhow, get right seem subtl enough worth ad helper method time.time.
think would better provid "absolut subtraction" "difference" method instead (if anything):
```go
// AbsSub returns abs(t-u). Always non-negative. If the result is too large it returns the maximum value.
// FIXME: naming
func (t Time) AbsSub(u Time) Duration
```
allow peopl delta comparison like, someth else.
use case find:
- time rel close togeth
- larger valu mostli clear due passag time (eg, `t1.sub(t0)`).
agre comparison zero time increas likelihood get wrong (the bug/risk non-obvious).
`abssub` ad refer ad `time.sub` peopl want non-neg numbers. risk peopl use new api know exist (`time.time` huge number methods).
observation: `time.time{}.sub(time.now())` return `math.minuint64+1` issue.
..but would break change.
thatâ€™ good suggestion. could call absdiff plain old diff.
sound like today would write:
:= t1.sub(t2); -1*time.minut <= && <= 1*time.minut
suggest instead abl write:
t1.diff(t2) <= 1*time.minut
?
sure would expect diff absolut valu sub, mayb unfamiliar usag elsewhere?
> sound like today would write:
>
> ```
> := t1.sub(t2); -1*time.minut <= && <= 1*time.minut
> ```
problem easi write buggi code instead:
```
d := t1.Sub(t2)
if d < 0 {
  d *= -1
}
if d < 1 *time.Minute { // ...
```
fine name `abssub` instead `diff` implic absolut differ clear enough name.
bit mouth `durationbetween` would descript name distanc function. kind redund name `duration` `between` seem like miss someth
propos ad activ column propos project
review weekli propos review meetings.
â€” rsc propos review group
may easi write buggi code seem _easier_ write correct code (`-1*time.minut <= && <= 1*time.minute`), sinc requir fewer statements. still, understand point footgun lie around sub return math.minint64 common cases.
hacker' delight refer max(x-y, 0) "differ zero", suggest x-i (not |x-y|) typic mean "difference".
perhap instead add duration.abs, defin time.duration(math.minint64).abs() == math.maxint64.
peopl use t.sub(t2).abs().
think `abs` realli address problem `sub` unexpectedli return `math.minint64`, sinc surpris behavior ways. (compar
is: seem propos would address one specif failur mode, leav mani `time.duration` footgun place. long-term, would like see holist solution. (short-term, mayb worth address particular case pointwise? realli know.)
method `duration.absolute() duration` `duration.saturated() bool` would helpful, think use themâ€¦
retrospect, durat `struct{ nanosecond int }` could safe arithmet method instead unsaf `+` etc. sure get though.
current time.dur turn mani infelicities, new, better design packag could perhao help?
even time2go packag point future, would good make improv exist time packag project stuck old time.
idea propos issue:
- time.within(time, duration) bool
- time.abssub(time) durat
- duration.absolute() durat
- duration.saturated() bool
peopl strong sens these? these? none these? feel absolut satur improv safety, definit happen, within conveni mayb happen, abssub sort redund duration.absolut exists, left off.
time low-level package. want dump possibl api it.
sound like address specif problem `func (duration) abs() duration`,
`time.duration(math.minint64).abs() == time.duration(math.maxint64)`.
peopl feel strongli `func (duration) isinf(sign int)` (like math.isinf), could talk too,
probabl keep one abs.
float point number stay satur hit infinity, durat wrap, isinf seem less use unless also ad scaleby, divideby, add, sub #20757. add satur arithmet oper int (don't know issu number that, sure exists). ab probabl enough now, safeti method revisit later.
base discuss above, propos seem like **like accept**.
â€” rsc propos review group
chang mention issue: `time: add duration.abs`
chang consensus, **accepted**. ðŸŽ‰
