io: make nopclos forward writerto call underli reader
beliv clearer code words:
replace:
```go
func NopCloser(r Reader) ReadCloser {
  return nopCloser{r}
}
```
someth like this:
```go
func NopCloser(r Reader) ReadCloser {
  c := nopCloser{r}
  if to, ok := r.(WriterTo); ok {
    return struct{
      nopCloser
      WriterTo
    }{c, to}
  }
  return c
}
```
allow ~1.5x faster read time wrap `bytes.newreader` `bytes.buffer` `io.nopcloser` (actual turn constant time operation, `io.reader` linear time):
```go
package bytes_test
import (
	"bytes"
	"io"
	"testing"
)
func BenchmarkForward4096(b *testing.B){benchmarkForward(4096,b)}
func BenchmarkForward16384(b *testing.B){benchmarkForward(16384,b)}
func BenchmarkForward65536(b *testing.B){benchmarkForward(65536,b)}
func BenchmarkForward262144(b *testing.B){benchmarkForward(262144,b)}
func BenchmarkForward1048576(b *testing.B){benchmarkForward(1048576,b)}
func BenchmarkSimple4096(b *testing.B){benchmarkSimple(4096,b)}
func BenchmarkSimple16384(b *testing.B){benchmarkSimple(16384,b)}
func BenchmarkSimple65536(b *testing.B){benchmarkSimple(65536,b)}
func BenchmarkSimple262144(b *testing.B){benchmarkSimple(262144,b)}
func BenchmarkSimple1048576(b *testing.B){benchmarkSimple(1048576,b)}
var zeros = [1048576]byte{}
func benchmarkForward(i int, b *testing.B) {
	for n := 0; n < b.N; n++ {
		_, err := io.Copy(io.Discard, nopCloserForward(bytes.NewReader(zeros[:i])))
		c(err)
	}
}
func benchmarkSimple(i int, b *testing.B) {
	for n := 0; n < b.N; n++ {
		_, err := io.Copy(io.Discard, nopCloserSimple(bytes.NewReader(zeros[:i])))
		c(err)
	}
}
func c(err error) {
	if err != nil {
		panic(err)
	}
}
type nopCloser struct {
	io.Reader
}
func (_ nopCloser) Close() error {
	return nil
}
func nopCloserSimple(r io.Reader) io.ReadCloser {
  return nopCloser{r}
}
func nopCloserForward(r io.Reader) io.ReadCloser {
  c := nopCloser{r}
  if to, ok := r.(io.WriterTo); ok {
    return struct{
      nopCloser
      io.WriterTo
    }{c, to}
  }
  return c
}
```
```
goos: linux
goarch: amd64
cpu: AMD Ryzen 5 3600 6-Core Processor              
BenchmarkForward4096-12       	 9195832	       136.1 ns/op
BenchmarkForward16384-12      	 8926760	       133.7 ns/op
BenchmarkForward65536-12      	 8760045	       135.2 ns/op
BenchmarkForward262144-12     	 8769903	       130.6 ns/op
BenchmarkForward1048576-12    	 8559370	       131.6 ns/op
BenchmarkSimple4096-12        	 6630315	       179.9 ns/op
BenchmarkSimple16384-12       	 3842174	       318.7 ns/op
BenchmarkSimple65536-12       	 1377452	       855.4 ns/op
BenchmarkSimple262144-12      	  405866	      2820 ns/op
BenchmarkSimple1048576-12     	  109400	     11025 ns/op
```
see surprisingli popular patern:
issu see this, pure `io.reader` ~1.5x time slower `nopcloser`-ify. (that cost tri cast would fail). sinc `nopcloser` creat known type, would hope `nopcloser` get inlin type cast solv compil time, seem happening.
hard argu perform win here.
implement unfortunate.
one possibl would implement make io.copi understand errunsupport come back writerto. could still singl nopclos implementation, would return errunsupport underli reader method.
propos ad activ column propos project
review weekli propos review meetings.
â€” rsc propos review group
seem like make change, would mean two differ possibl underli type interfac return nopcloser. later decid whether make io.copi support errunsupported, would get us back one underli type.
> later decid whether make io.copi support errunsupported, would get us back one underli type.
complet agre good idea.
howev think would less impact think.
would still `cast -> fail` overhead `io.copy`ing, least free `read` base workloads.
base discuss above, propos seem like **like accept**.
â€” rsc propos review group
chang consensus, **accepted**. ðŸŽ‰
