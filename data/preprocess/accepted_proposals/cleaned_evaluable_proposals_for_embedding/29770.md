text/template: allow newlin within action pipelin
issu resurfac -- mention enough time proven value.
hugo mani variad templat functions. one relev exampl would `dict` func accept list key/valu pairs.
current exampl would look like this:
```bash
{{ dict "country" "Norway" "population" "5 millions" "language" "Norwegian" "languageCode" "nb" "weather" "freezing cold" "capitol" "Oslo" "largest_city" "Oslo" "currency"  "Norwegian krone" "dialing_code" "+47" }}
```
would obvious easier read could written someth like this:
```bash
{{ dict 
	"country" "Norway" 
	"population" "5 millions"
	"language" "Norwegian"
	"language_code" "nb"
	"weather" "freezing cold"
	"capitol" "Oslo"
	"largest_city" "Oslo"
	"currency"  "Norwegian krone"
	"dialing_code" "+47" 
}}
```
creat parser error, common problem tri use one "html beautifiers" go templates.
person spent thousand hour insid go templat would say issu really, realli worth it. come background, think help remind mani go applic need user interface, go templat natur choice. one question valu `gofmt` pretti go code, sure ui code treat differently. know @natefinch tinker "go templat formatter" time ago. solut partucular issu would make task enjoyable, thinks.
/cc @regisphilibert
seem reason me. bit confus word title, however. assum want newlin allow whithin pipelin - sure understand delimit play part here.
also wonder there' disadvantag allow newlin cases. can't think right now, written complex pipelin go templates.
here' quot packag godoc:
> except raw strings, action may span newlines, although comment can.
@bep given thought whether action would allow span mani newlines? would restrict pipelines, commands?
/cc @robpik
> bit confus word title, however. assum want newlin allow whithin pipelin - sure understand delimit play part here.
sure "what want" translat "go templat terms", rememb differ command pipe. current item `{{` `}}` separ spaces. also allow newlin separator, would make mani peopl happy.
thanks, understand meant now. think suggest allow newlin within actions, includ pipelin well `if`, `range`, everyth els go `{{` `}}`.
strong +1 this. can't think reason would caus problems, often want templat node span one line.
templat formatter..... tri eventu gave up. stdlib templat parser extrem lossy, order use formatting, dive deep modifi parser lossless, turn heavi lift time had.
@mvdan yes, correct. so, primari "pain case" would exampl below. suspect chang templat lexer/parser, documentation, simpler tri somehow narrow scope.
```
{{ $mymap := someTemplateFunc 
	"country" "Norway" 
	"population" "5 millions"
	"language" "Norwegian"
	"language_code" "nb"
	"weather" "freezing cold"
	"capitol" "Oslo"
	"largest_city" "Oslo"
	"currency"  "Norwegian krone"
	"dialing_code" "+47" 
}}
```
mind you, simplifi things, could limit certain user defin actions: line `{{-`, charact attach open curli could indic content action accept newlines:
```
{{> $mymap := someTemplateFunc 
	"country" "Norway" 
	"population" "5 millions"
	"language" "Norwegian"
}}
```
so, put togeth preliminari patch implement this, quickli ran limit featur current specified. sooner abil creat multilin actions, tri write code like this:
```
{{-
    partial "card" (slice $ (dict
        "title"     $section_page.Title
        "url"       $url       
        "highlight" (gt (len $child_pages) 0)   /* highlight sections with children */
        "content"   ($section_page.Summary | safeHTML)
        "actions"   (slice (dict "label" "Learn More" "url" $url))
    ))
-}}
```
look pretti good, right? only, parse, enabl multi-lin action anyth need liter ascii space trim markers, part comment separ action non-com actions.
think scope featur need expand includ allow trim marker denot use kind whitespac (such linefeed), support inlin comments. former avoid need place invis trail space action format like one above, latter rather self-explanatory.
read line current `text/template/parse` implementation, appear reason requir ascii space reason separ comment action type actual same: limit exist lexer, limit lookahead tight coupl lex state direct manipul scan state.
threw previou attempt patch start over, refactor lexer separ lex state machin scan state (i.e. charact matching, line tracking, etc.). make long stori short, abl implement multilin actions, "ani whitespac good" trim markers, inlin comments, actual significantli speed lexer (at least accord pars benchmark) expand test suit cover scan state independ lex state.
see done before; *lot* work, all, limit realli issu origin use case `text/template` creat for. tool like hugo, dockerize, etc. use templat extension/script languag realli need kind thing. (though want it, *really* want it.)
anyway, written implement already, readi submit changeset (docs, tests, all), thought check see anybodi see problem approach resolv featur request. (in case, example, reason besid lexer limit allow previously!)
warm idea, find hard believ lexer need rewrite. admit fast lexer, interest code pedagog pedigree, deriv lexer talk lexic scan go, import keep correspond talk package, mention talk.
origin motiv single-lin action analog single-lin strings: common mistak leav close token. templat actions, open close token distinct, perhap less like miss close could lead profound misparsing. littl work error handling, complain open token seen look close one, would probabl cover gap well.
disagre two front between-the-lin reading, consid make chang next cycle. assign discov whether lexer truli issu here.
also mark proposal, although believ code chang modest, could signific downstream effects.
lexer actual chang little, outsid next/peek/accept* methods, state need directli chang feature.
refactor take part lexer dealt scan state, pull separ scanner.go file, banish direct manipul .input, .pos, etc. lex.go chang scanner part work requir chang lex.go. realli done tri add whitespac agnostic comment handl exist lexer, kept bump lookahead issu e.g. peek() make imposs backup().
one chang make backup() requir width save caller next(), rather save scan state, lexer back much necessary. need process e.g. left-hand trim marker, suffici match prefix `"- "`; go forward match charact class, back match. order without ad magic-numb pointer arithmet lexer, made lexer could back encapsul way.
essence, slide talk chang would'v affect would one next/peek/backup/accept, fine details. made chang assum ad .input/.po hack lexer would get patch reject ugly. made chang speed not-ugli way took perform off. :wink:
think anyth would consid rewrit lexer invalid video. devil-in-the-detail thing, sure find way around. expect written lexer myself, might confid straight-up scan state manipul instead improv scan abstraction.
lot place lexer current lot math figur advance, place need chang syntax chang (such delimit states), easier (for least) convert math higher-level abstract relat match captured, chang *that*, rather tri figur differ math, given assumpt math base changing. (e.g. left right delimit state util function built assumpt trim delimit fix string space character, rather fix string plu "ani whitespac character").
anyway, see if/when get there, sure. assum bother submit pr?
(tl;dr: lexer state machin fine, need chang much outsid affect states, new syntax need forward/back movement, requir either pointer arithmet better movement abstractions, pick better movement abstractions, choic could certainli made.)
>it' import keep correspond talk package, mention talk.
@robpik watch talk sever time learn lot it. github issu come real pain peopl use go templat make real applications. cannot freez develop packag use exampl implement talk youtube. use pronoun _we_ underlin open sourc project.
> cannot freez develop packag
whoa, nobody' say that. said, someon familiar lexer could probabl work around lack lookahead/lookback pointer arithmet varieti that' alreadi lexer state functions. expect patch ad lot funki pointer arithmet would reject sketchi fragile-looking, ad code smell instead reliev it. (not mention *actually* fragile.)
rob' alreadi assign issu sure way implement feature, hardli think qualifi freez development.
would great have! think must miss something, tell, code chang huge. mostli split case two. probabl combin isspace() case treat `[ \t\n\r]` white space lexspace. add altern `-[ \t\n\r]` trim white space still handl number `{{-3}}` way.
actually, here' small patch work without rewrit lexer (doesn't anyth comments, would simpl extra case lexinsideaction). sure would consid "ugly"...
```
--- a/src/text/template/parse/lex.go
+++ b/src/text/template/parse/lex.go
@@ -97,9 +97,11 @@ const eof = -1
 // space does the job.
 const (
        spaceChars      = " \t\r\n" // These are the space characters defined by Go itself.
-       leftTrimMarker  = "- "      // Attached to left delimiter, trims trailing spaces from preceding text.
-       rightTrimMarker = " -"      // Attached to right delimiter, trims leading spaces from following text.
-       trimMarkerLen   = Pos(len(leftTrimMarker))
+       trimMarkerLen   = Pos(len("- "))
+)
+var (
+       leftTrimMarkers = []string{"- ", "-\n", "-\r", "-\t"} // Alternate left trim markers to account for accepted whitespace
+       rightTrimMarkers = []string{" -", "\n-", "\r-", "\t-"} // Alternate right trim markers to account for accepted whitespace
 )
 // stateFn represents the state of the scanner as a function that returns the next state.
@@ -111,7 +113,7 @@ type lexer struct {
        input           string    // the string being scanned
        leftDelim       string    // start of action
        rightDelim      string    // end of action
-       trimRightDelim string    // end of action with trim marker
+       trimRightDelims []string  // end of action with trim marker
        pos             Pos       // current position in the input
        start           Pos       // start position of this item
        width           Pos       // width of last rune read from input
@@ -215,11 +217,14 @@ func lex(name, input, left, right string) *lexer {
                input:           input,
                leftDelim:       left,
                rightDelim:      right,
-               trimRightDelim: rightTrimMarker + right,
+               trimRightDelims: make([]string, len(rightTrimMarkers)),
                items:           make(chan item),
                line:            1,
                startLine:       1,
        }
+       for i, marker := range rightTrimMarkers {
+               l.trimRightDelims[i] =  marker + right
+       }
        go l.run()
        return l
 }
@@ -248,7 +253,7 @@ func lexText(l *lexer) stateFn {
                ldn := Pos(len(l.leftDelim))
                l.pos += Pos(x)
                trimLength := Pos(0)
-               if strings.HasPrefix(l.input[l.pos+ldn:], leftTrimMarker) {
+               if shouldTrimSpace(l.input[l.pos+ldn:], leftTrimMarkers) {
                        trimLength = rightTrimLength(l.input[l.start:l.pos])
                }
                l.pos -= trimLength
@@ -277,7 +282,7 @@ func rightTrimLength(s string) Pos {
 // atRightDelim reports whether the lexer is at a right delimiter, possibly preceded by a trim marker.
 func (l *lexer) atRightDelim() (delim, trimSpaces bool) {
-       if strings.HasPrefix(l.input[l.pos:], l.trimRightDelim) { // With trim marker.
+       if shouldTrimSpace(l.input[l.pos:], l.trimRightDelims) { // With trim marker.
                return true, true
        }
        if strings.HasPrefix(l.input[l.pos:], l.rightDelim) { // Without trim marker.
@@ -291,10 +296,19 @@ func leftTrimLength(s string) Pos {
        return Pos(len(s) - len(strings.TrimLeft(s, spaceChars)))
 }
+func shouldTrimSpace(str string, trimMarkers []string) bool {
+       for _, marker := range trimMarkers {
+               if strings.HasPrefix(str, marker) {
+                       return true
+               }
+       }
+       return false
+}
+
 // lexLeftDelim scans the left delimiter, which is known to be present, possibly with a trim marker.
 func lexLeftDelim(l *lexer) stateFn {
        l.pos += Pos(len(l.leftDelim))
-       trimSpace := strings.HasPrefix(l.input[l.pos:], leftTrimMarker)
+       trimSpace := shouldTrimSpace(l.input[l.pos:], leftTrimMarkers)
        afterMarker := Pos(0)
        if trimSpace {
                afterMarker = trimMarkerLen
@@ -336,7 +350,7 @@ func lexComment(l *lexer) stateFn {
 // lexRightDelim scans the right delimiter, which is known to be present, possibly with a trim marker.
 func lexRightDelim(l *lexer) stateFn {
-       trimSpace := strings.HasPrefix(l.input[l.pos:], rightTrimMarker)
+       trimSpace := shouldTrimSpace(l.input[l.pos:], rightTrimMarkers)
        if trimSpace {
                l.pos += trimMarkerLen
                l.ignore()
@@ -363,10 +377,10 @@ func lexInsideAction(l *lexer) stateFn {
                return l.errorf("unclosed left paren")
        }
        switch r := l.next(); {
-       case r == eof || isEndOfLine(r):
+       case r == eof:
                return l.errorf("unclosed action")
-       case isSpace(r):
-               l.backup() // Put space back in case we have " -}}".
+       case isSpace(r) || isEndOfLine(r):
+               l.backup() // Put whitespace back in case we have " -}}".
                return lexSpace
        case r == '=':
                l.emit(itemAssign)
@@ -425,7 +439,7 @@ func lexSpace(l *lexer) stateFn {
        var numSpaces int
        for {
                r = l.peek()
-               if !isSpace(r) {
+               if !isSpace(r) && !isEndOfLine(r) {
                        break
                }
                l.next()
@@ -433,7 +447,7 @@ func lexSpace(l *lexer) stateFn {
        }
        // Be careful about a trim-marked closing delimiter, which has a minus
        // after a space. We know there is a space, so check for the '-' that might follow.
-       if strings.HasPrefix(l.input[l.pos-1:], l.trimRightDelim) {
+       if shouldTrimSpace(l.input[l.pos-1:], l.trimRightDelims) {
                l.backup() // Before the space.
                if numSpaces == 1 {
                        return lexRightDelim // On the delim, so go right to that.
```
edit: love string slice trim markers. mayb `shouldtrimspace()` could iter rune marker string rune space call accept() spacechar otherwis check next rune equal? would cut amount chang overall.
took roughli similar approach, parser benchmark perform drop significantly, complex close trim-delimit check run what' effect hottest part lexer (lexinsideaction) can't inlin due size function involved. perform regress got start look possibl refactorings. (well, initi tri make lexer elid empti actions, rather filter parser.)
test exact code, course, suggest run benchmark without it. (comment process like affect benchmark includ any, hottest part lexinsideact event.)
me, differ seem pretti slight, see varianc run both. mayb handl someth correctli approach covered?
original:
```
$go test -benchtime 5s -bench .
goos: linux
goarch: amd64
pkg: text/template/parse
BenchmarkParseLarge-3                199          34254968 ns/op
BenchmarkVariableString-3       37936720               160 ns/op              72 B/op          3 allocs/op
BenchmarkListString-3            1458942              4366 ns/op            1608 B/op         31 allocs/op
PASS
ok      text/template/parse     26.613s
$go test -benchtime 30s -bench .
goos: linux
goarch: amd64
pkg: text/template/parse
BenchmarkParseLarge-3               1142          35654330 ns/op
BenchmarkVariableString-3       225743618              160 ns/op              72 B/op          3 allocs/op
BenchmarkListString-3            8640402              4162 ns/op            1608 B/op         31 allocs/op
PASS
ok      text/template/parse     136.237s
```
chang (and remov test case "{{\n}}"):
```
$go test -benchtime 5s -bench .
goos: linux
goarch: amd64
pkg: text/template/parse
BenchmarkParseLarge-3                163          36138100 ns/op
BenchmarkVariableString-3       35149789               158 ns/op              72 B/op          3 allocs/op
BenchmarkListString-3            1452826              4144 ns/op            1608 B/op         31 allocs/op
PASS
ok      text/template/parse     25.548s
$go test -benchtime 30s -bench .
goos: linux
goarch: amd64
pkg: text/template/parse
BenchmarkParseLarge-3               1204          35624717 ns/op
BenchmarkVariableString-3       227129716              158 ns/op              72 B/op          3 allocs/op
BenchmarkListString-3            8561077              4215 ns/op            1608 B/op         31 allocs/op
PASS
ok      text/template/parse     138.243s
```
interesting. note ran benchmark, usual run three four time time settl stabl timing, use default benchtime. surpris version small drop worst-cas scenarios, sinc four time mani prefix check master branch *per action token*. suppos could also hardwar differ machin test on, best speed master branch 53.9 ms/op, *way* slower machine' ~34.2 ms/op despit exact code. (same base arch, too: linux + amd64.)
case, moot until/unless languag chang approved. (also, said above, possibl somebodi could come better way me, still surpris perf drop small version sinc much work.)
chang mention issue: `text/template: allow newlin insid action delimiters`
@rsc understand correctly, propos accepted, issu state mileston updat accordingly. fix now.
misunderstood, cl 254257 revert go 1.16 released.
