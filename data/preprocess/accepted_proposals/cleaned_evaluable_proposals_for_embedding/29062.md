cmd/go: fail test invok os.exit(0) explicitli
<!-- pleas answer question submit issue. thanks! -->
### version go use (`go version`)?

$ go version
go version go1.11.2 darwin/amd64

### issu reproduc latest release?
yes.
### oper system processor architectur use (`go env`)?
<details><summary><code>go env</code> output</summary><br>
$ go env
goarch="amd64"
gobin=""
gocache="/users/rhysd/library/caches/go-build"
goexe=""
goflags=""
gohostarch="amd64"
gohostos="darwin"
goos="darwin"
gopath="/users/rhysd/.go"
goproxy=""
gorace=""
goroot="/usr/local/cellar/go/1.11.2/libexec"
gotmpdir=""
gotooldir="/usr/local/cellar/go/1.11.2/libexec/pkg/tool/darwin_amd64"
gccgo="gccgo"
cc="clang"
cxx="clang++"
cgo_enabled="1"
gomod=""
cgo_cflags="-g -o2"
cgo_cppflags=""
cgo_cxxflags="-g -o2"
cgo_fflags="-g -o2"
cgo_ldflags="-g -o2"
pkg_config="pkg-config"
gogccflags="-fp -m64 -pthread -fno-caret-diagnost -qunused-argu -fmessage-length=0 -fdebug-prefix-map=/var/folders/9t/jwm1hlr905g_wlnzrmbnb3cr0000gn/t/go-build385579133=/tmp/go-build -gno-record-gcc-switch -fno-common"
</details>
### do?
<!--
possible, provid recip reproduc error.
complet runnabl program good.
link play.golang.org best.
-->
code snip explain issue:
```go
package foo
import (
	"os"
	"testing"
)
type Parsed struct{}
func parseArguments(args []string) (Parsed, error) {
	// parse arguments
	if len(args) == 0 {
		// Show help message
		os.Exit(0)
	}
	// check parsed arguments
	return Parsed{}, nil
}
func TestParse(t *testing.T) {
	_, err := parseArguments([]string{})
	if err != nil {
		t.Fatal(err)
	}
	// test parse result
}
func TestOther(t *testing.T) {
	t.Fatal()
}
```
pleas write code go file run:
```
$ go test
$ echo $?
```
output `0`. mean test ok. however, actual test stop middl execut sinc `os.exit(0)` accident called.
sure bug. may intend behavior. call `os.exit(0)` test accident (for example, due lack understand api), may notic test wrongli run sinc exit successfully. ci also cannot detect it.
### expect see?
imo, `go test` exit non-zero exit statu test exit middl execut `os.exit()` would solv issue.
### see instead?
`echo $?` echo `0` test exit success
smaller repro:
```
$ cat go.mod
module foo.bar
$ cat f_test.go
package foo
import (
        "os"
        "testing"
)
func TestExit(t *testing.T) {
        os.Exit(0)
}
func TestFatal(t *testing.T) {
        t.Fatal()
}
$ go test
ok      foo.bar 0.001s
$ go test -v
=== RUN   TestExit
ok      foo.bar 0.001s
```
agre confusing, sinc `go test` appear happy. `go test -v` look off, sinc none test actual succeed finish.
perhap `go test` could error test binari exit soon. example, `go test -c` run test binary, get output instead `pass` `fail`. sure could implement without introduc even confus edg cases. example, happen test binari panics?
/cc @bcmill @ianlancetaylor
perhap simpl fix would `go test` complain test binari print absolut nothing. think never happen.
@mvdan: fix sound like right one.
test binari provid arbitrari `func main`, right? need print anyth success?
talk `testmain`? print result (`pass`) well.
suppos could implement `testmain` without call `m.run` argument, seem supported.
experi look like mistaken. carri on!
chang mention issue: `cmd/go: fail test binari succe output`
cl:
> testmain func standard librari need fixing,
> return without print anyth mean skip test entir
> packag
concern break user tests? fix stdlib tests, like mani test user code go break.
@randall77 mention `testmain` invok `m.run` (though doc `testing` ask that). also, @mvdan' cl demonstrates, done stdlib:
historically, accept break user program opposit documented. example, see want avoid breakag whenev possible, case best option.
think one cases. fix uncov packag test succeed accident, motiv bug. all, fix broken test two-lin change, think that' reason thing ask user follow docs.
chang mention issue: `doc/go1.14: note test without output fail`
chang mention issue: `revert "cmd/go: fail test binari exit output"`
revert cl due #34791. un-revert decid accept break assumpt #18153, figur way implement chang without break assumptions.
thank take care @bcmills. fundament disagre premis #18153. example, make test brittle, requir run real terminal, arguments:
```
$ cat f_test.go
package foo
import (
        "os"
        "testing"
        "golang.org/x/crypto/ssh/terminal"
)
func TestFoo(t *testing.T) {
        if !terminal.IsTerminal(int(os.Stdout.Fd())) {
                t.Fatal("not a terminal!")
        }
}
$ go test
PASS
ok      test.tld/foo    0.002s
$ go test | cat
--- FAIL: TestFoo (0.00s)
    f_test.go:12: not a terminal!
FAIL
exit status 1
FAIL    test.tld/foo    0.002s
$ go test .
--- FAIL: TestFoo (0.00s)
    f_test.go:12: not a terminal!
FAIL
FAIL    test.tld/foo    0.002s
FAIL
```
`go test -v` argument fails, too.
moreover, make hard (or impossible, suspect) inspect modifi output way, like need here.
reckon propos necessari make proper decis here?
realis origin idea color test output, necessarili make test fail pass depend stdout terminal. still, think wrong chang test' behavior depend whether happen run terminal. user realli want color test outputs, could use test flag, environ variabl like `$term != "dumb"`. least case, get inconsist show above.
might abl use pty, pretti uncomfort assumpt termin handl color codes, etcetera.
observation: realli help much test function print someth *then* exits. can't defer check, os.exit skip defer functions. think there' anyth compar `atexit()`, sure want one added.
mayb test build program intercept os.exit use `linkname`? there' way *that* could go wrong.
certainli fix implement (and got reverted) catch scenarios. intent basic catch honest mistakes, test tri harm things. test tri realli hard harm stuff, could much wors :)
person think simpl rule around "the test binary' output stop unexpectedly" simpler better long run magic thing linkname. probabl need linknam catch common honest mistakes.
exit 0 indic success. test goe way that, convinc second-guess it.
would normal agree, note `os.exit(0)` silent skip rest tests, let `testmain` exit properly, could hide real test failures. issu reason use `os.exit(0)`, unexpect unintend ones.
argu `os.exit` use part `testmain` never within test, cover exampl given origin post here, direct tri take `go test` in.
even choos anyth origin issu here, still strongli oppos `go test` sometim provid test real terminal, though.
thread start go back origin `os.exit` issue, start new propos `go test` termin output
thing could do, seriou problem worth fixing, let packag test inform packag os testxxx function progress os.exit called. would panic call (0 non-zero).
modifi `os.exit` directli seem acceptable, would definit cleaner exhaust solut tri guess happen peek test binary' output. would less magic version @seeb propos
mark `early-in-cycle` three week left freeze. assum plan continu work this, @mvdan, move backlog. not, pleas move unplanned. thank
move propos milestone. like get consensu all.
@bradfitz point often re-exec test binari child process expect use work instead run test exit 0 "test function". chang detect would caus problems. could fix standard librari like other pick idiom too.
"fail test invok os.exit(0) explicitly" break test work today. probabl want break test forc peopl rewrit them.
see way this. seem like continu allow os.exit(0). anyon see way out?
> often re-exec test binari child process expect use work instead run test exit 0 "test function"
that' true, mostli impli parent `cmd/go` process need involv final pass/fail decision. (a test binari run child process gener invok `os.args[0]` rather go back `go test`.)
spitballing, here' one possibl idea: hook `os.exit`, fail process parent pid match explicit pid pass `cmd/go` (either flag environ variable).
> that' true, mostli impli parent cmd/go process need involv final pass/fail decision. (a test binari run child process gener invok os.args[0] rather go back go test.)
consid that, agre that' alway case code written seen.
> spitballing, here' one possibl idea: hook os.exit, fail process parent pid match explicit pid pass cmd/go (either flag environ variable).
sgtm. probabl use environ variable, though, rather flag nois hidden flag.
meet propos gross hack look ppid tri determin you, etc, come anyth portabl & gross. parent pass environ variabl "go_fail_os_exit_if_ppid=1235" seem like portabl & easy.
instead environ variable, could also defin -test.disallowexit0 flag cmd/go pass run tests. subprocess start test command-lin argument pass it. thoughts?
(thi flag would special would correspond cmd/go flag. is, cannot run "go test -disallowexit0".)
base discuss here, sound like could possibl move forward following:
- add new flag packag testing, -test.panicexit0, recogn invok test binaries.
- test package, -test.panicexit0 given, use backdoor os catch os.exit(0).
- os.exit(0) called, panic("os.exit(0) test") instead (we can't use t.fatal might test goroutine, panick make sure show full stack trace call).
- cmd/go, invok test uncondit -test.panicexit0. flag disabl this.
test reinvok test binari set command line, run afoul this.
however, worth note run "go test x" "go test -c x && ./x.test" bit differ been, former panic os.exit(0) latter not. (the former also timeout etc latter not.)
thoughts?
