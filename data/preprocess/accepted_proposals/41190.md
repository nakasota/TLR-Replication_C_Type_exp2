=== Fetching Proposal: MDU6SXNzdWU2OTExNTg5Mjg= ===
Issue URL: https://github.com/golang/go/issues/41190

==== [Issue Title] ====
io/fs: add file system interfaces

==== [Issue Body] ====
In July, @robpike and I posted a [draft design for file system interfaces](https://golang.org/s/draft-iofs-design). That doc links to a video, prototype code, and a Reddit discussion.

The feedback on that design has been almost entirely positive.

A few people raised concerns about the use of optional interfaces, but those are an established pattern in Go that we understand how to use well (informed in part by some earlier mistakes, such as optional interface like http.Hijacker with methods that cannot return an error to signal failure/unavailability).

A few people suggested radical redesigns of the `os.File` interface itself, but for better or worse installed base and the weight of history cautions against such drastic changes.

I propose to adopt the file system interfaces draft design for Go 1.16.

==== [Comments] ====

--- Comment #1 by rsc ---
Accepting this proposal would also let us land the embedded files draft design in Go 1.16, which I've proposed in #41191.

--- Comment #2 by tooolbox ---
> A few people raised concerns about the use of optional interfaces

This is my concern.

It's not that the alternative (attempting to define all FS methods in one huge interface which packages may then implement as no-op) is better.  Rather, my perception is that the ergonomics of this approach are poor enough that it won't achieve broad community adoption and the level of composability and general success that interfaces like `io.Reader` and `io.Writer` have.

For example, it's clear that I will be able to pipe a zip file to `text/template`, and that's good, but I'm concerned about more general composability of filesystems and files.  I can wrap a stack of `io.Reader` with confidence, but with `io/fs` it seems like some middle layer may not have the right optional interfaces and I will lose access to functionality.

In spite of my concerns, it seems like the best approach available to Go at this time, and I anticipate it will be accepted given that the very exciting #41191 depends upon it.

However, I have this inkling that the advent of generics may allow a more powerful/robust/safe abstraction.  Has any thought been given to this, or to how `io/fs` could evolve in a backwards-compatible fashion if/when that occurs?  Again, not to hold up this proposal, but I think I would be more excited if I knew what the future held.

--- Comment #3 by networkimprov ---
The feedback page:
https://www.reddit.com/r/golang/comments/hv976o/qa_iofs_draft_design/?sort=new

I think this API looks promising... and would benefit from a prototype phase.

A lot of feedback was posted, but there's been rather light discussion of the comments, presumably because you can't subscribe to a Reddit thread, and/or many in Go's github-centered community don't frequent Reddit. It would help to see a review and analysis of feedback here, and perhaps a roadmap to likely future features.

Problems were identified with the `FileInfo` interface, ~but not discussed~ and are in discussion #41188. Timeouts and/or interrupts bear consideration.

Landing a prototype in x/ seems like a logical step before stdlib. Go has long been deliberative and conservative about new features. Is this urgent somehow?

FWIW, my Go apps make heavy use of the filesystem, on Windows, MacOS, and Linux.

--- Comment #4 by earthboundkid ---
I think optional interfaces can work **if** there is a way to indicate that even though a method exists on a wrapper, it hasn't been implemented by the underlying wrapped type. Something like `ReadFile(name string) ([]byte, error)` needs to be able to return `ErrNotImplemented` so that the function calling it can say "Oh, well, then let me fallback to `Open()` + `Read()`." The main sin of the existing optional interfaces is that there's no way to signal "I have this method just in case the thing I'm wrapping implements it." This shortcoming really needs to be addressed in the io/fs optional interfaces.

--- Comment #5 by earthboundkid ---
So, for the `ReadFile` top level func, I am proposing this implementation:

```go

func ReadFile(fsys FS, name string) ([]byte, error) {
	if fsys, ok := fsys.(ReadFileFS); ok {
		b, err := fsys.ReadFile(name)
		if err != ErrNotImplemented { // Or errors.Is?
			return b, err
		}
	}

	file, err := fsys.Open(name)
	if err != nil {
		return nil, err
	}
	defer file.Close()
	return io.ReadAll(file)
}
```

--- Comment #6 by rsc ---
Discussion of ErrNotImplemented has moved to #41198.
I've marked @carlmjohnson's two comments above this one
as well as @randall77's comment below this one 
as "off-topic" to try to funnel discussion over there.

--- Comment #7 by randall77 ---
On Thu, Sep 3, 2020 at 10:15 AM Carl Johnson <notifications@github.com>
wrote:

> I think optional interfaces can work *if* there is a way to indicate that
> even though a method exists on a wrapper, it hasn't been implemented by the
> underlying wrapped type. Something like ReadFile(name string) ([]byte,
> error) needs to be able to return ErrNotImplemented so that the function
> calling it can say "Oh, well, then let me fallback to Open() + Read()."
> The main sin of the existing optional interfaces is that there's no way to
> signal "I have this method just in case the thing I'm wrapping implements
> it." This shortcoming really needs to be addressed in the io/fs optional
> interfaces.
>
The other way to handle this is to have a factory for the wrapper that
returns a type with the correct methods on it.

type I interface {
    Foo()
}
type Optional interface {
    Bar()
}

func NewWrapper(i I) I {
    if _, ok := i.(Optional); ok {
        return &wrapperWithBar{i: i}
    }
    return &wrapperWithoutBar{i:i}
}
type wrapperWithoutBar struct {
    i I
}
type wrapperWithBar struct {
    i I
}
func (w *wrapperWithoutBar) Foo() { w.i.Foo() }
func (w *wrapperWithBar) Foo() { w.i.Foo() }
func (w *wrapperWithBar) Bar() { w.i.(Optional).Bar() }

â€”
> You are receiving this because you are subscribed to this thread.
> Reply to this email directly, view it on GitHub
> <https://github.com/golang/go/issues/41190#issuecomment-686632868>, or
> unsubscribe
> <https://github.com/notifications/unsubscribe-auth/ABUSAIFGSNLHB456YB5L6C3SD7FKNANCNFSM4QTHTZEA>
> .
>


--- Comment #8 by rsc ---
@networkimprov, see https://go.googlesource.com/proposal/+/master/design/draft-iofs.md#why-not-in-golang_org_x.
This isn't worth much without the standard library integration. It also can't be used for embed.Files from x.


--- Comment #9 by jimmyfrasche ---
I'd feel more comfortable with this if it included basic combinatory file systems either in io/fs or somewhere official like golang.org/x. They would still have the issue with not understanding nonstandard optional methods but they would at least be guaranteed to keep up with official optional methods.

The two file systems I'm thinking of are an overlay fs and one that can "mount" other file systems in subdirectories of its root. With those two you could stitch multiple fs together easily. 

--- Comment #10 by rsc ---
@jimmyfrasche I don't understand the difference between "an overlay fs" and "one that can mount other file systems in subdirectories of its root." I agree we should provide something like that, and we intend to. But those sound like the same thing to me. :-)



--- Comment #11 by jimmyfrasche ---
I was thinking just:

`func Overlay(fses ...FS) FS` for the former and the latter would satisfy
```go
interface {
  FS
  Mount(dirName string, fs FS) error
}
```
and not have any files other than those mounted.


--- Comment #12 by rsc ---
Got it, thanks @jimmyfrasche: union vs replace.


--- Comment #13 by networkimprov ---
The io/fs integration with stdlib, and embed.Files can all be prototyped in x/

I wasn't suggesting x/ as the permanent home.

EDIT: Also, Readdir() & FileInfo have performance problems and missing features. The replacement APIs need prototypes. A draft is in https://github.com/golang/go/issues/41188#issuecomment-686283661

--- Comment #14 by muirdm ---
I have two comments. I found similar comments in the reddit thread, but didn't see a satisfying discussion/conclusion. Apologies if I missed previous conclusions.

### Wrapping

I think we should consider an official mechanism to wrap fs.FS objects (and probably fs.File objects). For example, I want to wrap an fs.FS to track the total number of bytes read. I need to intercept calls to fsys.Open and calls to fsys.ReadFile, if implemented. I also don't want to lose any other optional interfaces such as fs.GlobFS. Based on my experience with http.ResponseWriter, this is commonly needed, but hard and tedious to do correctly

For a concrete idea to discuss, something like this:

```go
type FSWrapper struct {
  FS
  OpenFunc func(name string) (File, error)
  ReadFileFunc func(name string) ([]byte, error)
  // ... all other extensions ...
}

func (w *FSWrapper) ReadFile(name string) ([]byte, error) [
  rf, ok := w.FS.(ReadFileFS)
  if !ok {
    return nil, errors.ErrNotImplemented
  }

  if w.ReadFileFunc != nil {
    return w.ReadFileFunc(name)
  } else {
    return rf.ReadFileFunc(name)
  }
}
```

Granted there are cases where a generic wrapper would expose extensions you don't want to pass through. Anyway, I think at least the proposal would benefit from discussion or FAQ addressing wrapping.

### Writing

It seems like we are starting with read-only because that is the simplest interface that enables the motivating embed feature. However, in some sense writing is more fundamental because you have to write before you can read (only half joking). I worry writing will be relegated to second class citizenship forever due to optional interfaces. For example, the hypothetical OpenFile extension:

```go
func OpenFile(fsys FS, name string, flag int, perm os.FileMode) (File, error)
```

OpenFile returns an fs.File which has no Write method. It seems a bit strange to always have to type assert to get a writable file. I think the eternal friction between io.Writer and fs.File as proposed will be more painful than starting with a broader proposal.

In particular, I think we should consider:
1. Make "OpenFile" be the core of fs.FS instead of "Open". OpenFile is more fundamental to file systems. We can add "func Open(fsys FS, name string) (File, error)" as a package function to emulate the simplicity of the proposed FS.Read method.
1. Include "Write" in the fs.File interface. Write is as fundamental as Read for file systems.


--- Comment #15 by Cyberax ---
Guys, PLEASE just add context everywhere! It costs nothing to ignore it or add context.TODO() for callers, but it will make life of network filesystem implementers and users much easier. In particular, it's needed for better contextual logging and cancellation.

You're all strictly opposed to thread-local variables, but then why are you designing APIs without a way to pass a context?!?

--- Comment #16 by networkimprov ---
Deadlines and interrupts have been suggested as another way to solve the same problem, without affecting every function signature. It's unlikely that the os package will add dozens of new APIs with `Context`, see also #41054.

[Deadlines comment](https://www.reddit.com/r/golang/comments/hv976o/qa_iofs_draft_design/g2awgme/?utm_source=reddit&utm_medium=web2x&context=3)
[Interrupts comment](https://www.reddit.com/r/golang/comments/hv976o/qa_iofs_draft_design/g24rusp/?utm_source=reddit&utm_medium=web2x&context=3)


--- Comment #17 by Merovius ---
I think the simplest way to solve this is to pass a context on filesystem creation. So instead of having a type implementing `fs.FS` directly, it would have a method `WithContext(context.Context) fs.FS`, which returns a child-instance bound to a given context.

--- Comment #18 by networkimprov ---
Cancelling all pending ops by the stdlib file API (which will implement fs.FS) is not desirable. It probably isn't useful for other FS types, as well. The common case, in my experience, is interrupting any pending ops trying paths within a tree rooted at a certain path. An API for that looks like one of:
```
(f *MyFs) SetDeadline(t time.Time, basepath string) error // if deadline past, interruption is immediate

(f *MyFs) InterruptPending(basepath string) error
```

Note that os.File already supports Read & Write deadlines.

I doubt that `io/fs` wants `context` as a dependency. Where needed, you could easily wire context into an fs.FS implementation to do one of the above.

--- Comment #19 by Cyberax ---
Gah. The deadlines/interrupts design is just horrible. No, it's seriously horrible. The whole idea for not including thread IDs in Golang was to make sure APIs are forced to deal with clients potentially running in multiple goroutines. 

Introducing the per-FS state will defeat this purpose, making the FS object behave more like a TCP connection rather than a dispatcher for an underlying FS. And only one goroutine at a time would be able to use it, otherwise they might step on each others' toes with deadlines. Never mind the badness of introducing a hidden state where it arguably shouldn't even be in the first place.

 What are the actual downsides of simply adding context.Context to every method?

--- Comment #20 by Cyberax ---
> I think the simplest way to solve this is to pass a context on filesystem creation. So instead of having a type implementing `fs.FS` directly, it would have a method `WithContext(context.Context) fs.FS`, which returns a child-instance bound to a given context.

This will require the FS implementation to be a thin wrapper that supplies context to the underlying implementation. Certainly doable, but still ugly.

And it will still introduce dependency on context.Context in the FS code.

--- Comment #21 by tv42 ---
@Cyberax All you need is `f, err := fsys.WithContext(ctx).Open(p)` to make that one open file obey that one context. Easy sharing.

This has been before with `x.IO(ctx)` returning `io.Reader` or such, to keep the `io.Reader` interface. It's a pretty simple layer.

--- Comment #22 by networkimprov ---
So @tv42 that's `(f *MyFs) WithContext(context.Context) *MyFs` ? That's reasonable.

--- Comment #23 by Cyberax ---
> @Cyberax All you need is `f, err := fsys.WithContext(ctx).Open(p)` to make that one open file obey that one context. Easy sharing.

Not unless you want to do FS wrapping, but that's already been mentioned here. To expand this a bit, currently FS is supposed to consist of multiple optional interfaces (such as `ReadFileFS`), and the `WithContext` method's signature will have to use the most basic interface (`FS`).

So your example will actually be: `f, err := fsObject.WithContext(ctx).(ReadFileFS).ReadFile(name)` - it's NOT typesafe at all.

> This has been before with `x.IO(ctx)` returning `io.Reader` or such, to keep the `io.Reader` interface. It's a pretty simple layer.

The whole TCP and the general IO layer in Go is a mess, so it's not at all a good example. Witness the number of questions on Google about cancelling IO operations on TCP connections (via SetDeadline).

--- Comment #24 by Cyberax ---
And let me remind everybody about Go's own style guide: https://github.com/golang/go/wiki/CodeReviewComments#contexts

```
A function that is never request-specific may use context.Background(), but err on the side of 
passing a Context even if you think you don't need to. The default case is to pass a Context; 
only use context.Background() directly if you have a good reason why the alternative is a mistake.

Don't add a Context member to a struct type; instead add a ctx parameter to each method on 
that type that needs to pass it along. The one exception is for methods whose signature must 
match an interface in the standard library or in a third party library.
```

--- Comment #25 by icholy ---
> So your example will actually be: f, err := fsObject.WithContext(ctx).(ReadFileFS).ReadFile(name) - it's NOT typesafe at all.

I think that would be:

``` go
data, err := fs.ReadFile(fsys.WithContext(ctx), "name")
```

Also, what's preventing `WithContext` from returning a concrete type?

--- Comment #26 by networkimprov ---
Re `Context` everywhere, the stdlib file API has dozens of functions, and even if you replicate them all to add a `Context` argument, every package that calls any of them would have to replicate its own API to add `Context`. It's just not viable.

I haven't heard a good argument for why it's wrong to ask pending file ops to return an `InterruptError` in whatever goroutines invoked them.

--- Comment #27 by Cyberax ---
> I think that would be:
> 
> ```go
> data, err := fs.ReadFile(fsys.WithContext(ctx), "name")
> ```

Sure, putting the code inside a helper function will help in this one particular case. But it won't help with the `Stat` interface and other optional interfaces defined in the spec.

> Also, what's preventing `WithContext` from returning a concrete type?

Because it's going to be defined in the interface `Contexter` (or something like it) and it can't have the knowledge of the concrete type.

--- Comment #28 by tooolbox ---
> Because it's going to be defined in the interface Contexter (or something like it) and it can't have the knowledge of the concrete type.

Perhaps this is a silly suggestion, and I know this doesn't help us now, but as I mentioned near the start of this thread, would generics help with this particular issue?

--- Comment #29 by Cyberax ---
> Re `Context` everywhere, the stdlib file API has dozens of functions, and even if you replicate them all to add a `Context` argument, every package that calls any of them would have to replicate its own API to add `Context`. It's just not viable.

This is a _new_ API, so I don't see the problem with adding context to it. Existing stdlib code that needs to touch files can either scrounge up the context from somewhere (for example, the HTTP server code has it) or just put context.TODO().

> I haven't heard a good argument for why it's wrong to ask pending file ops to return an InterruptError in whatever goroutines invoked them.

Your API is not thread-safe. It's perfectly possible to open the same file twice from two different goroutines, but your interruption code will affect both of them.

It's also completely incorrect on Unix, because name doesn't uniquely identify a file, so it's possible to do:

```
fl := fs.Open("file.a")
fs.Move("file.a", "file.b")
fl2 := fs.Open("file.a", O_CREATE)
...
fl.Read(...)
fl2.Read(...)

fs.Interrupt("file.a") // Should we interrupt both reads?
```

--- Comment #30 by Cyberax ---
> Perhaps this is a silly suggestion, and I know this doesn't help us now, but as I mentioned near the start of this thread, would generics help with this particular issue?

No, not in this particular case.
