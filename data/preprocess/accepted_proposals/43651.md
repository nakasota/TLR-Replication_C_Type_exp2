=== Fetching Proposal: MDU6SXNzdWU3ODQ0NDM5Mjk= ===
Issue URL: https://github.com/golang/go/issues/43651

==== [Issue Title] ====
spec: add generic programming using type parameters

==== [Issue Body] ====
We propose adding support for type parameters to Go.  This will change the Go language to support a form of generic programming.

A [detailed proposal document](https://go.googlesource.com/proposal/+/refs/heads/master/design/43651-type-parameters.md) has been published, with input from many members of the Go community.  We are now taking the next step and proposing that this document become a part of the language.

A very high level overview of the proposed changes:

* Functions can have an additional type parameter list that uses square brackets but otherwise looks like an ordinary parameter list: `func F[T any](p T) { ... }`.
* These type parameters can be used by the regular parameters and in the function body.
* Types can also have a type parameter list: `type MySlice[T any] []T`.
* Each type parameter has a type constraint, just as each ordinary parameter has a type: `func F[T Constraint](p T) { ... }`.
* Type constraints are interface types.
* The new predeclared name `any` is a type constraint that permits any type.
* Interface types used as type constraints can have a list of predeclared types; only type arguments that match one of those types satisfy the constraint.
* Generic functions may only use operations permitted by their type constraints.
* Using a generic function or type requires passing type arguments.
* Type inference permits omitting the type arguments of a function call in common cases.

For more background on this proposal, see [the recent blog post](https://blog.golang.org/generics-proposal).

In the discussion on this issue, we invite substantive criticisms and comments, but please try to avoid repeating earlier comments, and please try to [avoid simple plus-one and minus-one comments](https://golang.org/wiki/NoPlusOne).  Instead, add thumbs-up/thumbs-down emoji reactions to comments with which you agree or disagree, or to the proposal as a whole.

If you don't understand parts of the design please consider asking questions in a forum, rather than on this issue, to keep the discussion here more focused.  See https://golang.org/wiki/Questions.

==== [Comments] ====

--- Comment #1 by atdiar ---
Why `any` and not `interface{} `? 

--- Comment #2 by ALTree ---
@atdiar This is explained in the proposal:

> However, it‘s tedious to have to write interface{} every time you write a generic function that doesn’t impose constraints on its type parameters. So in this design we suggest a type constraint *any* that is equivalent to interface{}.

Please read it in full before asking questions about it.

--- Comment #3 by atdiar ---
Yes sorry, I just checked the link and was about to delete my message.
Would still prefer to have the empty interface. How tedious can this really be? Especially since we can define type aliases ourselves... 
Other than that, I'm fine with it. 

--- Comment #4 by hanneshayashi ---
Will this proposal cover channels as well (e.g. func F[T any](p chan T) { ... })?

--- Comment #5 by tsal ---
> Why `any` and not `interface{} `?

an `interface{}` wouldn't make sense here since we're describing a generic trait that needs to be implemented. This is more meta-code and `interface{}` is still concrete - even if it is "generic" in some senses of the word.

I'm also having trouble thinking how you could implement any `interface{}` generic parameters, since you don't know what the interface will actually be - and if you're doing interface type-checking here, it's defeating the entire point of generics (IMO).

--- Comment #6 by coder543 ---
> Will this proposal cover channels as well (e.g. func F[T any](p chan T) { ... })?

[Yes, it seems to cover that.](https://go.googlesource.com/proposal/+/refs/heads/master/design/go2draft-type-parameters.md#channels)

--- Comment #7 by bcmills ---
I remain concerned that this proposal overloads words (and keywords!) that formerly had very clear meanings — specifically the words _type_ and _interface_ and their corresponding keywords — such that they each now refer to two mostly-distinct concepts that really ought to instead have their own names. (I wrote up this concern in much more detail last summer, at https://github.com/bcmills/go2go/blob/master/typelist.md.)

----

Specifically, the word _type_ today is defined as:
> A type determines a set of values together with operations and methods specific to those values.

Under this proposal, I believe that a type would instead be _either_ a set of values with operations, _or_ a set of sets of values, each with _its own_ set of operations.

And today the word _interface_, in the context of Go, refers to a type, such that:
> A variable of interface type can store a value of any type with a method set that is any superset of the interface.

Under this proposal, a variable of interface type can store a value of any type with a method set that is any superset of the interface, _unless_ that interface type refers to a set of sets of values, in which case no such variable can be declared.

----

I'd like to see more detail on the exact wording proposed for the spec, but for now I am against this specific design, on the grounds that the ad-hoc overloading of terms is both confusing, and avoidable with relatively small changes in syntax and specification.

--- Comment #8 by flibustenet ---
```go
func foo[T Stringer](t T) string {
	return t.String()
}
func foo(t Stringer) string {
	return t.String()
}
```
The difference are very subtil. How will you document the best practice when a Go1 interface is enough ?
I mean, how to prevent abuse of generic when both can be used ?

--- Comment #9 by nadiasvertex ---
> Would still prefer to have the empty interface. How tedious can this really be? Especially since we can define type aliases ourselves...

I think interface{} is a mistake. It is a hack to permit something like void * without any semantic cues to help a user understand what is going on. I would have preferred to have "any" as a type in the language from the beginning, even it it was just an alias for interface{} under the covers.

Of course, the new "any" is different than interface{}. It would be nice to have a named type that means "any type by reference" instead of "any type by substitution".


--- Comment #10 by michaelwilner ---
> ```go
> ```go
> func foo[T Stringer](t T) string {
> 	return t.String()
> }
> func foo(t Stringer) string {
> 	return t.String()
> }
> ```
> 
> 
> The difference are very subtil. How will you document the best practice when a Go1 interface is enough ?
> I mean, how to prevent abuse of generic when both can be used ?
> ```

Valid point, in your example, an interface would be the better choice. However, a more apt use case of generics would be `sort`. Operations on slices of arbitrary types would be distinctly less verbose with generics as compared to interfaces. This talk touches on some of the points: [blog.golang.org/why-generics](https://blog.golang.org/why-generics) (disclaimer: syntax in this link is different than this generics proposal, but the points are useful to draw comparison)

--- Comment #11 by JeremyLoy ---
What are the plans for amending the standard library to utilize generics? I see two important tracts of work here.

1. retroactively applying generics to packages like `sort`, `container/list`
2. Creating new packages and libraries that were previously cumbersome without generics; i.e. mathematical set functions, 

--- Comment #12 by coder543 ---
@bcmills

> Specifically, the word type today is defined as:
>
> A type determines a set of values together with operations and methods specific to those values.

That sentence describes a _struct_. An interface is also a kind of _type_ in Go, and it does not determine the set of values or operations that are present, only the set of methods.

The fact that a type is not just a struct is why the syntax in the language is `type foo interface { ... }`, `type foo struct { ... }`, and even `type foo bar` or `type foo = bar`.

A generic type is just as concretely a set of values, operations, and methods as an interface is (which is to say, you an argue that it isn't). So either we should redefine _interface_ to _not_ be a type (by the definition you're quoting), or we should accept that a generic type is also a type, just one that requires type parameters to be resolved before it becomes a concrete type.

If the proposal is misusing the term "type" in place of "type parameter" anywhere, I think that _could_ be valid criticism... but it sounds like you're criticizing some ambiguous/arguably wrong terminology that exists in the Go language spec, which is terminology that is refuted by the language itself, as demonstrated by Go syntax above. If an interface is not a type, we should not prefix the declaration with the word `type`, but we do.

That whole area of discussion seems off topic here, and clarifications to the existing language spec could be proposed somewhere else? I've read through the generic proposal several times and I haven't come away feeling like the terminology used was ambiguous or confusing, and your statements here do not effectively make the case for that either, in my opinion.

--- Comment #13 by fzipp ---
> Of course, the new "any" is different than interface{}.

The new "any" is not different from interface{} as a type constraint. `[T any]` and `[T interface{}]` are interchangeable as per the proposal.

--- Comment #14 by IceWreck ---
> What are the plans for amending the standard library to utilize generics? I see two important tracts of work here.
> 
>     1. retroactively applying generics to packages like `sort`, `container/list`
> 
>     2. Creating new packages and libraries that were previously cumbersome without generics; i.e. mathematical set functions,


Yes, and after generics are implemented, I hope the container package will be expanded to include other common data structures present in c++/java std libs

--- Comment #15 by zephyrtronium ---
> 
> 
> @bcmills
> 
> > Specifically, the word type today is defined as:
> > A type determines a set of values together with operations and methods specific to those values.
> 
> That sentence describes a _struct_. An interface is also a kind of _type_ in Go, and it does not determine the set of values or operations that are present, only the set of methods.

The interface type definition specifies the methods (which are operations) present on values of that interface type. Because values must implement the interface to be used as that interface type, the interface type does indeed determine a set of values (always a superset of other types').

--- Comment #16 by fzipp ---
> ```go
> func foo[T Stringer](t T) string {
> 	return t.String()
> }
> func foo(t Stringer) string {
> 	return t.String()
> }
> ```
> 
> The difference are very subtil. How will you document the best practice when a Go1 interface is enough ?
> I mean, how to prevent abuse of generic when both can be used ?

I'd expect a linter warning: "useless use of type parameter"

--- Comment #17 by coder543 ---
> > @bcmills
> > > Specifically, the word type today is defined as:
> > > A type determines a set of values together with operations and methods specific to those values.
> > 
> > 
> > That sentence describes a _struct_. An interface is also a kind of _type_ in Go, and it does not determine the set of values or operations that are present, only the set of methods.
> 
> The interface type definition specifies the methods (which are operations) present on values of that interface type. Because values must implement the interface to be used as that interface type, the interface type does indeed determine a set of values (always a superset of other types').

If you want to go down that route... the same exact thing applies to the "overloading" of "type" to refer to generic types as well. In order for a value to be substituted for a type parameter, it must implement the interface constraints, and to do that, it must be a concrete type. Therefore, a generic type "does indeed determine a set of values (always a superset of other types)".

It's the same thing. Either an interface is a type (in which case, it's fine for the proposal to use its current terminology), or it's not (in which case it's _not_ okay for the Go language to define interfaces as types).

Either way, someone could propose that the Go language spec is written in a confusing way in the quoted section, but it wouldn't change any outcomes regarding this proposal or the current-day reality of Go.

--- Comment #18 by p-kraszewski ---
Is this proposal related to ongoing development on the [dev.go2go](https://github.com/golang/go/tree/dev.go2go) branch?

--- Comment #19 by DeedleFake ---
>
>
> > @bcmills
> > > Specifically, the word type today is defined as:
> > > A type determines a set of values together with operations and methods specific to those values.
> >
> >
> > That sentence describes a _struct_. An interface is also a kind of _type_ in Go, and it does not determine the set of values or operations that are present, only the set of methods.
>
> The interface type definition specifies the methods (which are operations) present on values of that interface type. Because values must implement the interface to be used as that interface type, the interface type does indeed determine a set of values (always a superset of other types').

In general, methods in Go are tied to type definitions and behave, in a lot circumstances, like any other function except that there's an argument placed before the function name. That's why, unlike most languages, Go allows you to call a method on a `nil` pointer no problem, meaning that you can handle the `nil` pointer case in the method itself instead of elsewhere.

Interfaces are a strange exception to this. Despite the fact that a type is defined, as in `type Example interface { /* ... */ }`, attempting to declare methods on that type will fail, purely because the underlying type is of kind `interface`. This dichotomy has always existed in Go, and it's always kind of bugged me, but it's a very minor thing that's basically _never_ any kind of problem in practice, and I don't really think that the usage of interfaces in this proposal changes that much at all.

--- Comment #20 by ianlancetaylor ---
@p-kraszewski The active development is currently on [dev.typeparams](https://github.com/golang/go/tree/dev.typeparams).

--- Comment #21 by knz ---
Is it possible to create a `chan T` when `T` has constraint `any`? I did not find mention of channels in the section "Operations permitted for any type".

--- Comment #22 by griesemer ---
@p-kraszewski The most up-to-date development is happening on the `dev.typeparams` branch. The `dev.go2go` branch was used to develop a prototype and the [go2go playground](https://go2goplay.golang.org/); general development of that has been suspended in favor of a real implementation in `dev.typeparams`. But we hope to update `dev.go2go` occasionally to keep the go2go playground in reasonably good shape.

--- Comment #23 by DeedleFake ---
> Is it possible to create a `chan T` when `T` has constraint `any`? I did not find mention of channels in the section "Operations permitted for any type".

I think that you're confusing the declaration of a type parameter and the usage. The parameters are declared in function and type declarations and are essentially scoped to those functions and types. For contrived example,

```go
//    declaration       usages
//        v             v    v
func Send[T any](c chan T, v T) {
  c <- v
}
```

Once they're declared, there basically isn't any difference in terms of usage between the type parameters and any other type, so they can be used as the element type of a channel, or the element type of a slice, or an argument to a function, or basically anything else.

--- Comment #24 by steeling ---
How can I use this with clojures? Both for func's that take a generic function as a param, or have one as a return type:

ie:
```go
func Print[T any](s []T) {
	for _, v := range s {
		fmt.Print(v)
	}
}

func FuncGen[T any]() func(s []T) {
	return Print[T]
}

func main() {
	FuncGen()([]string{"Hello, ", "playground\n"})
}
```

--- Comment #25 by knz ---
The section "Operations permitted for any type" in the spec does not seem to suggest I can create a `chan T` if `T` has constraint `any`. That is, under the current _text_ of that section (I did not look at the examples), the following code is invalid:

```go
func foo[T any]() {
  c := make(chan T)
}
```

So my question is: is the code valid? (And the section incomplete?) Or is the section text valid? (And the code example here invalid?)

--- Comment #26 by stigsb ---
> ```go
> func foo[T Stringer](t T) string {
> 	return t.String()
> }
> func foo(t Stringer) string {
> 	return t.String()
> }
> ```
> The difference are very subtil. How will you document the best practice when a Go1 interface is enough ?
> I mean, how to prevent abuse of generic when both can be used ?

govet or golint could help with that.

--- Comment #27 by zikaeroh ---
> 
> 
> > ```go
> > func foo[T Stringer](t T) string {
> > 	return t.String()
> > }
> > func foo(t Stringer) string {
> > 	return t.String()
> > }
> > ```
> > 
> > 
> > The difference are very subtil. How will you document the best practice when a Go1 interface is enough ?
> > I mean, how to prevent abuse of generic when both can be used ?
> 
> I'd expect a linter warning: "useless use of type parameter"

@fzipp That wouldn't be entirely accurate as a warning. Depending on the compiler's devirtualization pass, the two would have different performance characteristics. Assuming the "stenciling" approach for implementing generics, each version of `foo` would be expanded out to each specific type to generate the most efficient code, and the former would be faster as the compiler knows exactly what `String` to call, while in the latter the compiler may potentially box the value into an interface type and then have to look up the correct `String` for the type it gets.

--- Comment #28 by griesemer ---
@knz I suggest you use the [go2go playground](https://go2goplay.golang.org/) to explore [your examples](https://go2goplay.golang.org/p/Vi9VunI9IqG), which work fine. The section "Operations permitted for any type" talks about _values of type parameter type_, not values of types that _contain_ type parameters (such as `chan T`, where `T` is a type parameter). Also, what we have so far is a fairly precise proposal, but it's not a specification yet; please keep that in mind. Thanks.


--- Comment #29 by DeedleFake ---
> The section "Operations permitted for any type" in the spec does not seem to suggest I can create a `chan T` if `T` has constraint `any`. That is, under the current _text_ of that section (I did not look at the examples), the following code is invalid:
> 
> ```go
> func foo[T any]() {
>   c := make(chan T)
> }
> ```
> 
> So my question is: is the code valid? (And the section incomplete?) Or is the section text valid? (And the code example here invalid?)

Your code is valid and the text is valid. The text says

> define and use composite types that use those types, such as a slice of that type

That includes channels. The only place that an `any` constrained type wouldn't work is in the key for a map, which requires that the type be comparable via `==`.

--- Comment #30 by fzipp ---
> > > ```go
> > > func foo[T Stringer](t T) string {
> > > 	return t.String()
> > > }
> > > func foo(t Stringer) string {
> > > 	return t.String()
> > > }
> > > ```
> > > 
> > > 
> > > The difference are very subtil. How will you document the best practice when a Go1 interface is enough ?
> > > I mean, how to prevent abuse of generic when both can be used ?
> > 
> > 
> > I'd expect a linter warning: "useless use of type parameter"
> 
> @fzipp That wouldn't be entirely accurate as a warning. Depending on the compiler's devirtualization pass, the two would have different performance characteristics. Assuming the "stenciling" approach for implementing generics, each version of `foo` would be expanded out to each specific type to generate the most efficient code, and the former would be faster as the compiler knows exactly what `String` to call, while in the latter the compiler may potentially box the value into an interface type and then have to look up the correct `String` for the type it gets.

I don't think the programmer should make the optimisation choice here, but the compiler. The compiler could potentially choose to stencil the regular interface as well. Different compilers may also compile type parameters differently.
