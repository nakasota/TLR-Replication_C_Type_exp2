==== [Issue Title] ====
crypto/tls: add (*tls.Conn).HandshakeContext and add context to ClientHelloInfo and CertificateRequestInfo

==== [Issue Body] ====
## Proposal

I propose an unexported `context.Context` field is added to the `ClientHelloInfo` and `CertificateRequestInfo` `crypto/tls` types. We should also add a `Context() context.Context` method to these types to access this context. Further, we should add a new method, `HandshakeContext(context.Context) error` to the `tls.Conn` struct, which will be used to propagate a context down the handshake call stack. The existing `Handshake() error` would call to the new method with a `context.Background()` context.

Standard library uses of `(*tls.Conn).Handshake()` should be moved over to the new method, where appropriate. For example, it is not clear that it is appropriate to change the existing `Read` and `Write` methods on the `*tls.Conn` to use the new handshake method, but in `(*net/http.Server).serve`, it is clear that moving to the new function would enhance the request lifetime control in the function.

The `context.Context` provided to `HandshakeContext` would only be used for cancellation of the handshake itself, and once the handshake has completed, cancelling the context will have no effect. This is in line with the predecent set by `(*net.Dialer).DialContext`.

## Motivation

In recent Go releases, we've been able to use the handy `GetCertificate` and `GetClientCertificate` methods of the `*tls.Config` to dynamically control certificate management in Go apps. This is fantastic, and has lead to things like https://godoc.org/golang.org/x/crypto/acme/autocert and https://github.com/johanbrandhorst/certify which are somewhat unique to the Go ecosystem.

Unfortunately, one glaring omission from the API is a connection context for cancellation and request scoped variable propagation. This means users have to implement custom timeouts or block their TLS connections forever in case of problems. It also means powerful observability tools like tracing and metrics that make use of the context cannot be used.

## Interaction with net/http

`net/http.Server` provide `BaseContext`, which is used to set a global context for the duration of `(*http.Server).Serve`, and `ConnContext`, which is used on every new connection. The context passed to `(*tls.Conn).HandshakeContext` would necessarily be a child of these contexts, as the existing `Handshake` call is made after these contexts are created. See

* [BaseContext use](https://github.com/golang/go/blob/b371f189dfdfb2454a20ec276de55fe884d6ff9f/src/net/http/server.go#L2897-L2902)
* [ConnContext use](https://github.com/golang/go/blob/b371f189dfdfb2454a20ec276de55fe884d6ff9f/src/net/http/server.go#L2931-L2936)
* [*tls.Conn first tested](https://github.com/golang/go/blob/b371f189dfdfb2454a20ec276de55fe884d6ff9f/src/net/http/server.go#L1782)


==== [Comments] ====

--- Comment #1 by FiloSottile ---
It would help if you could elaborate on the various use cases: what you are trying to do in each situation, what doesn't work at the moment, and how a context would help.

I've in the past wanted to surface details of the ClientHelloInfo to net/http Handlers, so I can see the use case, but I'd like to build a generic solution.

--- Comment #2 by johanbrandhorst ---
My use case specifically is to allow my library (`certify`) to cancel its outgoing requests if the incoming connection is closed. Additionally, it would allow detailed tracing to capture the latency cost of dynamically provisioned TLS certificates, something that is currently hidden inside the TLS handshake time in the standard library. Simply having a context associated with the underlying connection that could be used in outgoing  `net/http` requests would be enough.

--- Comment #3 by bradfitz ---
@johanbrandhorst, sounds like good reasons. For the same reason we didn't add a Context struct field to net/http.Request and used a method instead, we should instead add a Context method to crypto/tls.ClientHelloInfo.

--- Comment #4 by johanbrandhorst ---
OK, I will attempt to implement this.

--- Comment #5 by johanbrandhorst ---
Do the tags need updating?

--- Comment #6 by gopherbot ---
Change https://golang.org/cl/181097 mentions this issue: `crypto/tls, net/http: add context to tls structs`

--- Comment #7 by johanbrandhorst ---
Since the tree has recently opened again, bumping this for another look at the initial implementation. Could we tag this with 1.14? I think this proposal was accepted in https://github.com/golang/go/issues/32406#issuecomment-498709215.

--- Comment #8 by mvdan ---
@bradfitz @FiloSottile could you please clarify whether this proposal is accepted? If so, we can milestone it for 1.14 and review the CL.

--- Comment #9 by bradfitz ---
Looks like it's stuck in the Crypto Proposal Review queue. @FiloSottile owns that meeting.


--- Comment #10 by johanbrandhorst ---
Friendly ping on this. @FiloSottile is there an update on this?

--- Comment #11 by johanbrandhorst ---
Friendly ping.

--- Comment #12 by johanbrandhorst ---
Friendly ping. @FiloSottile anything I can do to help with the Crypto Proposal Review queue?

--- Comment #13 by johanbrandhorst ---
Friendliest of bumps.

--- Comment #14 by johanbrandhorst ---
With 1.14 out, is there a plan to review the crypto proposals?

--- Comment #15 by rsc ---
@johanbrandhorst, crypto proposal review is proceeding fairly well (see all the crypto proposals in the minutes at https://golang.org/s/proposal-minutes), but there are many.



--- Comment #16 by rsc ---
Ping @FiloSottile and @katiehockman.


--- Comment #17 by FiloSottile ---
Hey, sorry for the delay, this one fell off my radar.

Another common problem that would be nice to solve at the same time is propagating info from the callbacks to net/http handlers. Maybe exposing this context also from ConnectionState would work, as it's exposed as Request.TLS? Or should the net/http Request context be a child of the TLS one? (How would that work with Server.BaseContext and Server.ConnContext?)

Another reason to expose it on ConnectionState is that the new VerifyConnection callback gets a ConnectionState as input. All other callbacks should be covered by ClientHelloInfo and CertificateRequestInfo.

Can we get a full API proposal here on the issue, along with details of how it would interact with net/http?

--- Comment #18 by johanbrandhorst ---
Thanks for looping back on this @FiloSottile, I've updated the first post with a full API proposal. It does not support passing data back via the context as it is read only. We would need to make the context an exported field to support this, which was argued against in https://github.com/golang/go/issues/32406#issuecomment-498709215. I'm open to discuss other solutions, or changing the context to be an exported field.

What are your thoughts?

--- Comment #19 by FiloSottile ---
If the TLS context needs to be a child of the ConnContext, how does that happen? I can't see a way for crypto/tls to reach the ConnContext, nor for net/http to set the TLS context.

I unfortunately haven't designed a lot of APIs with Context, so I could use some advice (maybe from @bcmills?) on this proposal.

--- Comment #20 by johanbrandhorst ---
I'm not an expert on the net/http server by any stretch, but I thought we could assign to it here: https://github.com/golang/go/blob/b371f189dfdfb2454a20ec276de55fe884d6ff9f/src/net/http/server.go#L1782, where we have both the `ctx` inherited from ConnContext and the `*tls.Conn`.

--- Comment #21 by FiloSottile ---
Assign it how? The proposal does not expose any way to set the Context.

--- Comment #22 by johanbrandhorst ---
Ah, good point, we would have to expose something like a WithContext to assign a context to the conn.

I will update the proposal.

--- Comment #23 by johanbrandhorst ---
I've added the `(*crypto/tls.Conn).WithContext` method description to the proposal.

--- Comment #24 by rsc ---
ping @filosottile and @katiehockman 

--- Comment #25 by rsc ---
Talked to @FiloSottile.

http.Request.WithContext returns a derived http.Request that now has the context. In the callback you are trying to use, there's no way to return a _new_ tls.Conn, so the tls.Conn.WithContext is a _setter_ - it mutates the receiver instead of returning a derived copy.

So at least in this proposal, WithContext should be named SetContext.

But then the problem is this is the first SetContext we have in the standard library, and it's unclear that's the right path to go down.

/cc @bcmills @Sajmani 


--- Comment #26 by johanbrandhorst ---
I agree with your analysis and that SetContext would set a potentially dangerous precedent. I will re-examine the problem and see if there's a better way of merging the HTTP context into the tls connection.

--- Comment #27 by johanbrandhorst ---
I've updated the proposal to change the use of a `SetContext` method to instead create a new `HandshakeContext` method on the `tls.Conn`. This method would be used to propagate the context down the call stack into the `GetClientCertificate` and `GetCertificate` callbacks. PTAL.

--- Comment #28 by gopherbot ---
Change https://golang.org/cl/246338 mentions this issue: `DO NOT REVIEW: crypto/tls: add HandshakeContext method to Conn`

--- Comment #29 by johanbrandhorst ---
I took a stab at what this would look like here: https://go-review.googlesource.com/c/go/+/246338. Forgive me if it's inappropriate to make this sort of experimental change before a proposal has been accepted.

--- Comment #30 by rsc ---
I admit I am a bit confused about how HandshakeContext would be used in that CL.
I was expecting maybe a new callback that returns a context.
What would the client use of HandshakeContext instead of the old callbacks look like?

