==== [Issue Title] ====
runtime/metrics: add GOMAXPROCS, NumCgoCall, GC CPU time

==== [Issue Body] ====
Hi 
I was testing and using the runtime/metrics package introduced in 1.16 
I'm using go version 1.16.5.  
I didn't find the following metrics that exists in runtime package in the runtime/metrics  package :
- func NumCgoCall() int64
- func (r *MemProfileRecord) InUseBytes() int64
- func (r *MemProfileRecord) InUseObjects() int64

Does it make sense to add them in runtime/metrics pacake?

Does it makes sense to add those values (which are static) as well?

- func Version() string
- func GOMAXPROCS(n int) int
- func NumCPU() int
Thanks a lot, G.



==== [Comments] ====

--- Comment #1 by seankhliao ---
cc @mknyszek 

--- Comment #2 by mknyszek ---
> Hi
> I was testing and using the runtime/metrics package introduced in 1.16
> I'm using go version 1.16.5.
> I didn't find the following metrics that exists in runtime package in the runtime/metrics package :
> 
> * func NumCgoCall() int64
> * func (r *MemProfileRecord) InUseBytes() int64
> * func (r *MemProfileRecord) InUseObjects() int64

`NumCgoCall` could be a good candidate. The other two should already be accounted for as `/gc/heap/objects:objects` and `/memory/classes/heap/objects:bytes` respectively.

> 
> Does it make sense to add them in runtime/metrics pacake?
> 
> Does it makes sense to add those values (which are static) as well?
> 
> * func Version() string
> * func GOMAXPROCS(n int) int
> * func NumCPU() int

`Version` and `NumCPU` aren't quite what the package was made for. It doesn't really make sense to track these values over time, since they're static. Though, simultaneously, I understand how analyzing something like this across a fleet is nice, and it's also nice to have one API to export everything. I'll think about it.

`GOMAXPROCS` on the other hand is probably a good candidate. It can change over time (usually it doesn't, but it can) and it seems like it might be useful to correlate against other metrics. It would cost us very little to support this. Same goes for `runtime/debug.SetGCPercent`.

>   Thanks a lot, G.

Thanks for the suggestions!

--- Comment #3 by rsc ---

This proposal has been added to the [active column](https://golang.org/s/proposal-status#active) of the proposals project
and will now be reviewed at the weekly proposal review meetings.
â€” rsc for the proposal review group


--- Comment #4 by rsc ---
ping @mknyszek. any new thoughts?


--- Comment #5 by mpx ---
Please consider exporting the total time spent perfoming GC as well (`work.totaltime` or similar). It would be more useful than the processed `GCCPUFraction` currently provided by `runtime.Memstats`


--- Comment #6 by mknyszek ---
@mpx I'm already ahead of you on that one. `GCCPUFraction` is intentionally missing from `runtime/metrics` because of issues with it. Instead, I'm hoping to export a distribution of GC CPU utilizations by GC cycle. It's still preprocessed, but given that the API is sample-based rather than event-based, I think it's the best we can do for the moment.

Total work time also seems fine to me, though it doesn't seem quite as useful without a "total CPU time" counter also (sample them together, take a diff to determine GC CPU utilization since the last sample). We could expose something like that, but measuring exact CPU time is unfortunately kind of tough. In the runtime we just make some assumptions that luckily hold true in 99% (maybe more) of cases. It might be useful to export those assumptions anyway, but I think the aforementioned distribution of GC CPU time is more directly useful for monitoring (and includes those assumptions, necessarily, anyway).

Do you have another use-case for total time that I'm not considering?

--- Comment #7 by hub-adda ---
Hi all, thanks for the efforts you invest in that issue. As a telemetry consumer telemetry, we use external libraries to measure the total cpu usage of the process. I'm not sure that this is the right place to discuss it. What are the limitations of the solution you present? 
Thanks Gil

--- Comment #8 by mknyszek ---
Alrighty, from this issue, I think we should add the following metrics:

1. `GOMAXPROCS`
2. Total GC CPU time.
3. `NumCgoCall`.

I don't think there's any point to doing `Version` or `NumCPU` because they're static. Those should just be exported yourself (to whatever system) if you want them. It seems unnecessary to "resample" them regularly via the `runtime/metrics` API, though if you have a good use-case, I'm open to hearing it.

Any objections?

--- Comment #9 by rsc ---

Based on the discussion above, this proposal seems like a **[likely accept](https://golang.org/s/proposal-status#likely-accept)**.
â€” rsc for the proposal review group


--- Comment #10 by mpx ---
@mknyszek For total GC time I'd like to compare it against `rusage` to understand whether a task is GC heavy without needing all the profiling machinery (which is inaccurate/more involved in other ways). I understand we can't sample both simultaneously, but any error should be small, and will become relatively smaller over the lifetime of the process.

Recording a histogram of GC times would be interesting, but I don't have a specific use for it atm.

--- Comment #11 by rsc ---

No change in consensus, so **[accepted](https://golang.org/s/proposal-status#accepted)**. ðŸŽ‰
