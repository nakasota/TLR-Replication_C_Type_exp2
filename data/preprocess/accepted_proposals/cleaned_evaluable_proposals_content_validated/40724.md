==== [Issue Title] ====
cmd/compile: switch to a register-based calling convention for Go functions

==== [Issue Body] ====
I propose that we switch the Go internal ABI (used between Go functions) from stack-based to register-based argument and result passing for Go ~1.16~ 1.17.

I lay out the details of our proposal and the work required in [this document](https://golang.org/design/40724-register-calling).

The ABI specification can be found [here](https://go.googlesource.com/go/+/refs/heads/dev.regabi/src/cmd/compile/internal-abi.md).

This was previously proposed in #18597, where @dr2chase did some excellent prototyping work that our new proposal builds on. With multiple ABI support, we’re now in a much better position to execute on this without breaking compatibility with the existing body of Go assembly code. I’ve opened this new issue to focus on discussion of our new proposal.

/cc @dr2chase @danscales @thanm @cherrymui @mknyszek @prattmic @randall77 

An incomplete and evolving list of tasks:

- [X] Define ABI specification ([CL](https://golang.org/cl/285292), @aclements)
- [X] Add GOEXPERIMENT=regabi and asm macro ([CL](https://golang.org/cl/252258))
- [x] cmd/compile: late call lowering ([CLs](https://go-review.googlesource.com/q/hashtag:%22drchase-late-call%22))
- [x] cmd/compile: implement register arguments (@dr2chase)
    - [x] spill around morestack call ([CL](https://golang.org/cl/279520))
    - [x] add temporary ABI pragma for testing ([CL](https://golang.org/cl/279521))
    - [x] add abstract argument registers ([WIP CL](https://golang.org/cl/260539))
    - [x] implement ABI rules ([CL](https://golang.org/cl/273011))
    - [x] use abstract argument registers
- [x] cmd/compile: implement register returns
    - [x] late return lowering ([CL](https://golang.org/cl/279519), @dr2chase)
    - [x] implement ABI rules ([CL](https://golang.org/cl/273011), @thanm)
- [x] cmd/compile: ABI wrappers ([CL](https://golang.org/cl/270863), [old CL](https://golang.org/cl/259445))
    - [x] cmd/link: mangle wrapper names for ELF ([CL](https://golang.org/cl/289289))
    - [x] cmd/link: mangle wrapper names for PE ([CL](https://golang.org/cl/304432))
    - [x] implement zeroing of X15 in ABI0->ABIInternal wrappers ([CL](https://golang.org/cl/288093))
- [X] cmd/asm: add syntax for runtime packages to reference ABIInternal symbols ([CL](https://golang.org/cl/260477))
    - [x] Mark runtime.{goexit,asyncPreempt}, reflect.{makeFuncStub,methodValueCall} definitions ABIInternal ([CL](https://golang.org/cl/262319))
    - [x] Mark reference to runtime.callbackWrap in sys_windows_amd64.s as ABIInternal ([CL](https://golang.org/cl/305669))
- [x] runtime: fix assembly closure calls (mcall) (@aclements, [CL](https://golang.org/cl/305669))
- [x] reflect: support calling ABIInternal ([CL](https://golang.org/cl/272568))
- [x] reflect: support MakeFunc and method value calls ([CL](https://golang.org/cl/298670))
- [x] go and defer statements
    - [x] cmd/compile: desugar go/defer to zero-argument (@thanm, [CL](https://golang.org/cl/298669))
    - [x] cmd/compile: fix `defer recover()` (@cherrymui, [CL](https://golang.org/cl/304771))
    - [x] cmd/compile: desugar go/defer with results (@cherrymui, [CL](https://golang.org/cl/305550))
- [X] cmd/cgo: decouple cgo callbacks from ABI ([CL](https://golang.org/cl/258938))
- [x] runtime: finalizer support ([CL](https://golang.org/cl/300113))
- [x] runtime: Windows callback support ([CL](https://golang.org/cl/300113))
- [x] cmd/internal/obj: introduce and use `RegEntryTmp` registers in prologue (@mknyszek, [CL](https://golang.org/cl/303314))
- [x] cmd/compile: generate correct ABI0 argument maps for body-less functions (see `WriteFuncMap`) (@dr2chase, [CL](https://golang.org/cl/302072))
- [x] cmd/compile: make `cgo_unsafe_args` generate an ABI0 function (or an ABIInternal-with-no-registers function) (@cherrymui, [CL](https://golang.org/cl/306609))
- [x] runtime: update debug call protocol ([CL](https://golang.org/cl/309169))
- [x] Fix ABI0/ABIInternal confusion in cgo ([CL](https://golang.org/cl/309341))
- [x] Run signature fuzzer and fix bugs (everyone)
- [x] Get all.bash to pass on Linux, Windows, and Darwin (everyone)

High-priority non-critical path
- [x] Export ABI information across package boundaries to eliminate more wrappers (@aclements, [CL](https://golang.org/cl/305274))
- [x] Make `funcPC` always return the "native" PC of a function (maybe also introduce `ABIOther`) (@cherrymui, [CL](https://golang.org/cl/304232))
- [x] Strip unnecessary ABIInternal annotations once `funcPC` is in
- [x] Tracebacks
    - [x] Define extended argument metadata format (in progress, @cherrymui)
    - [x] cmd/compile: produce extended argument metadata (@cherrymui, [CL](https://golang.org/cl/304470))
    - [x] runtime: consume extended argument metadata (@cherrymui, [CL](https://golang.org/cl/304470))
    - [x] cmd/compile,runtime: traceback metadata for spill slot liveness
- [x] DWARF
    - [x] cmd/compile: ensure arguments have appropriate DWARF locations
    - [x] Ensure GDB and Delve can find register arguments
    - ~[ ] cmd/compile: add a DWARF vendor attribute with function argument frame size ([context](https://golang.org/cl/309169))~
- [x] Wrapper mangling for non-critical arches
    - [x] cmd/link: mangle wrapper names for Mach-O ([CL](https://golang.org/cl/307229))
    - [x] cmd/link: mangle wrapper names for xcoff
    - [x] cmd/link: mangle wrapper names for Plan 9
- [x] runtime: simplify go/defer call paths
    - [x] assert that go/defer frames are zero sized ([CL](https://golang.org/cl/306009))
    - [x] replace defer reflectcall with a direct closure call ([CL](https://golang.org/cl/306010))
- [x] cmd/internal/obj: reject splittable ABIInternal functions without morestack spill info (e.g., asm functions) because we can't generate a correct morestack path ([CL](https://golang.org/cl/309789))
- [x] cmd/asm: don't reference `args_stackmap` in ABIInternal functions (because it's for ABI0) ([CL](https://golang.org/cl/309790))
- [x] Port performance-critical assembly to ABIInternal (see [CL 296372](https://golang.org/cl/296372) for valuable functions) ([CL 308931](https://golang.org/cl/308931), [CL 310184](https://golang.org/cl/310184))
- [x] math: fix overhead of assembly->Go calls [CL 310331](https://golang.org/cl/310331)
- [x] Release notes
  - Mention undocumented behavior we've observed applications depending on that may have changed.
    - Using `reflect.ValueOf(fn).Pointer()` to get the PC of an assembly function will now return the PC of the ABI wrapper
  - Performance surprise: calling from assembly to Go is slightly more expensive.
  - Performance surprise: calling an assembly function via a closure is slightly more expensive.
  - Traceback format is much improved

Enabling steps
- [x] Enable regabiwrappers by default on amd64 (Linux, Windows, and Darwin)
- [x] Enable regabidefer
- [x] Enable regabireflect
- [x] Enable regabig
- [x] Enable regabiargs

Testing
- [ ] [Function signature fuzzer](https://github.com/thanm/cabi-testgen) (ongoing)
    - [ ] Static call, closure call, method call, interface call, `reflect.{ValueOf(target),MakeFunc(x, target),Method(x)}.{Call,Interface}`, called from `defer`, called from `go`, called as a finalizer
    - [x] {Big,Small} {argument,result} in {memory,registers} and {not addressed,addressed and not leaked to heap,addressed and leaked to heap}
    - [x] Use `defer` in a test function (check arguments, modify results)
    - [x] Pass pointers-to-stack and pointers-to-heap
    - [x] Cause result to move to heap
    - [x] runtime: add `MoveStackOnNextCall`, assertions for pointer-to-stack/pointer-to-heap, assertions for live/dead (@aclements, [CL](https://golang.org/cl/305330))
    - [x] Integrate runtime testing hook
    - [ ] Clean up fuzzer, and get into tools repo.
- [x] cmd/compile: revive clobberdead ([CL](https://golang.org/cl/301791))
- [x] cmd/compile: add clobberdeadreg ([CL](https://golang.org/cl/302809))

Post-MVP
- [x] Move g from TLS to register ([CL](https://golang.org/cl/289196))
    - [x] Use g register on non-Linux OSes (see [CL](https://golang.org/cl/289718))
- [x] Reserve and use X15 as zero register ([CL](https://golang.org/cl/288093))
    - ~[ ] Should this be X0 for more compact instruction encoding?~
- [ ] Port to other platforms
   - [x] amd64 
   - [x] arm64
   - [ ] mips
   - [x] ppc
   - [ ] s390x
   - [x] risc-v
   - ~[ ] porting guide~
- [x] Eliminate legacy ABI paths for all platforms, even if they're using ABIInternal with 0 registers
- [ ] Eliminate spill slots?
- [ ] Pass pointer-shaped method receiver in context register (#44827)
- [x] runtime: simplify go/defer call paths
    - [x] simplify go/defer paths to assume zero args/results
    - [x] simplify special _defer allocator and remove special _defer cases from mallocgc (because _defer records will be fixed size).
- [ ] cmd/vet: add syntax and checks for register arguments and results in assembly like x+0(FP)
- [ ] cmd/vet: check argument size for ABIInternal functions and fix runtime asm declarations

Cleanup (can be done later)
- [ ] runtime: port all assembly -> Go calls to ABIInternal?
- [x] Eliminate ABIAlias support from cmd/compile, cmd/link, and object format
- [x] remove now-redundant fields from ssa.AuxCall
- [x] rationalize use of LocalsOffset/FrameOffset (for registers that use a link register, e.g. arm64, powerppc).
- [ ] cmd/compile: revisit abiutils.go and clean up the API (also reduce ABIConfig copying)
- [ ] cmd/internal/obj: generate stack maps in obj so we can better compact the morestack/body maps and reduce subtlety?
- [x] cmd/compile,runtime: re-enable passing arguments to `go` in runtime ([context](https://go-review.googlesource.com/c/go/+/298669/comment/68535db6_d8c8f271/))
- [ ] cmd/compile: always attach `ir.Func` to function `ir.Name`s ([context](https://golang.org/cl/305271))
- [x] cmd/compile: support ABIInternal for tail calls ([context](https://golang.org/cl/307234))
- [x] cmd/compile: once wrapping of defers is on for all arch/OS combinations, it should be possible to simplify or remove some of the openDefer processing in ssagen (notablly we could get rid of [openDeferSave()](https://go.googlesource.com/go/+/b56177a3037a035ee7f74e619838b6d853697100/src/cmd/compile/internal/ssagen/ssa.go#4697)
- ~[ ] runtime: think about an ABI-insensitive debugCall~ Delve uses DWARF information
- [ ] Fix up named slots & value association
- [ ] fix `firstpos` in `ssa.go` – sometimes it's late.

==== [Comments] ====

--- Comment #1 by seebs ---
Once upon a time, I was one of several people whose primary work activity for I think two days was tracking down a weird kernel crash, which was ultimately caused by callee-saved registers. Well, the crash was caused by a [FOO_MAX] array being overrun. But the thing where the result of that overrun was to overwrite a single automatic variable, which never had its address taken, five call frames away? _That_ was caused by callee-saved registers.

Which is to say:
> Platform ABIs typically define callee-save registers, which place substantial additional requirements on a garbage collector. There are alternatives to callee-save registers that share many of their benefits, while being much better suited to Go.

+1 +1 +1 +1 +1 +1 [...]

--- Comment #2 by ncw ---
If I'm understanding the proposal correctly, assembler code will continue to be written with the current stack based calling conventions.

I understand the excellent reasoning behind doing this, I'll just note that this is surely going to frustrate assembly code writers not being able to pass and receive args in registers as often assembly code fragments are tiny and the overhead of calling them is massive.

--- Comment #3 by mknyszek ---
@ncw This restriction to `ABI0` for assembly writers isn't necessarily permanent. See https://go.googlesource.com/proposal/+/master/design/27539-internal-abi.md#proposal.

--- Comment #4 by laboger ---
Right now writeBarrier is a special builtin that allows arguments to be passed in registers. Couldn't that same concept be extended to others like memmove and memcpy to avoid call overhead even though they are asm?

--- Comment #5 by aclements ---
@laboger , yes, we're considering special-casing just a few assembly functions. The hottest ones by far are `memmove`, `memclrNoHeapPointers`, and possibly `syscall.Syscall`. The write barrier calling convention is *very* specialized because its context is so unusual and performance-sensitive. We'll probably just switch the others to use the register ABI rather than anything more specialized (and teach the toolchain that those are special even though they're assembly).

--- Comment #6 by mknyszek ---
A comment on the "stack growth" section of the doc, specifically about spilling register state for `morestack` into the guard space for a goroutine (copied from Gerrit):

I worry a little bit about cases where functions marked `nosplit` eventually call into a non-`nosplit` function. If the `nosplit` frames are large (but don't exceed the guard space) we might find out that we don't have any space left. What should we do in this case? Throwing doesn't seem quite right since this works just fine today (though, you have to be careful). Should we have "guard space" and a subset of that as "no, really, this is very guarded" space? That would require extending the guard space a bit further which isn't great...

One alternative is to manage per-goroutine space for this, but that's not great either, since its more memory used per goroutine.

--- Comment #7 by cherrymui ---
Good point. This is especially true for architectures that have a lot registers. Maybe we could decide that some registers are never live across a call?

--- Comment #8 by aclements ---
That's an excellent point. A few possible solutions come to mind:

1. It would be really sad if we had to make more per-goroutine space for this since you almost always have space on the stack. One possibility is to spill to the stack if there's room, and otherwise we keep a pool of allocated "spill space" objects. For that, we could keep just one pre-allocated per P and if the goroutine needs it, it can pull it off the P, spill into it, and then once it's entered the runtime it can allocate a new one (probably getting it from a global allocation pool) and attach it to the P. On return, it can return it to the allocation pool.

2. A similar option would be to have just one spill space per P. Again, use the stack if you can, otherwise spill into the P, enter the runtime, *grow the stack* even if it's just a preemption, and then dump the spilled registers back onto the stack in the right place.

3. We could revisit the nosplit rules. It's often (though not always) a mistake to call from a nosplit function to a non-nosplit function. I'm not sure exactly what this would look like. Maybe a non-nosplit function called from a nosplit function has to have a special prologue? Related: https://github.com/golang/go/issues/21314#issuecomment-346480985. I think the only cases I enumerated in that comment that intentionally call from a nosplit to a non-nosplit function aren't running on a user G stack and thus can't grow it anyway.

--- Comment #9 by gopherbot ---
Change https://golang.org/cl/252258 mentions this issue: `cmd/asm: define a macro for GOEXPERIMENT=regabi`

--- Comment #10 by gopherbot ---
Change https://golang.org/cl/252257 mentions this issue: `cmd/internal/objabi: add regabi GOEXPERIMENT`

--- Comment #11 by gopherbot ---
Change https://golang.org/cl/258938 mentions this issue: `runtime,cmd/cgo: simplify C -> Go call path`

--- Comment #12 by aclements ---
@alexbrainman , I just ran into a bit of a snag on Windows that maybe you can better inform me on. It looks like `syscall.NewCallback` is going to also need an implementation of the Go internal ABI rules and I'm trying to figure out exactly what that needs to look like. (I pinged you because it looks like you last substantially touched that code, but feel free to pass the ping.)

The documentation says "The argument is expected to be a function with one uintptr-sized result. The function must not have arguments with size larger than the size of uintptr." Does this actually mean the arguments (and result) must be an integral, floating-point, or pointer type? Or does it mean, say, `struct { x, y uint16 }` or `struct { x [4]byte }` is allowed, since those are technically no larger than the size of a uintptr? The current implementation permits the latter, though I don't know if it actually works.

If they must be int/float/pointer, then mapping from the Windows ABI to the Go register ABI is relatively straightforward. If compounds are allowed, then this gets much harder.

--- Comment #13 by networkimprov ---
cc @jstarks re the ABI question.

--- Comment #14 by alexbrainman ---
@aclements I reckon there are very few instances of syscall.NewCallback usage. But they are used a lot.

If you want to build Windows GUI, you have to use syscall.NewCallback, because Windows GUI API requires syscall.NewCallback.

Similarly, if you want to build Windows service, you have to use syscall.NewCallback.

These two pretty much cover syscall.NewCallback usage.

For Windows service, you can look in golang.org/x/sys/windows/svc. It uses this RegisterServiceCtrlHandlerEx WIndows API

https://docs.microsoft.com/en-us/windows/win32/api/winsvc/nf-winsvc-registerservicectrlhandlerexw

which requires LPHANDLER_FUNCTION_EX

https://docs.microsoft.com/en-us/windows/win32/api/winsvc/nc-winsvc-lphandler_function_ex

so LPHANDLER_FUNCTION_EX returns DWORD (uint32).

For GUI grep in golang.org/x/exp/shiny - it uses RegisterClass

https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-registerclassw

which uses WNDCLASSW.lpfnWndProc

https://docs.microsoft.com/en-us/windows/win32/api/winuser/ns-winuser-wndclassw

which is WNDPROC

https://docs.microsoft.com/en-us/previous-versions/windows/desktop/legacy/ms633573(v=vs.85)

which returns LRESULT which is LONG_PTR or uintptr (in Go)

https://docs.microsoft.com/en-us/windows/win32/winprog/windows-data-types

Also I recommend you look at github.com/lxn/walk for their syscall.NewCallback usage. This is an ultimate package to create GUI apps. But, I doubt, you will find different usage than golang.org/x/exp/shine. (I did not look myself)

I reckon, that is about it. For Microsoft APIs (maybe google code for syscall.NewCallback or windows.NewCallback).

But some people might use it in their custom / proprietary interface. I am not sure how these are supported by Go. You will be the judge.

Alex

--- Comment #15 by CAFxX ---
IIUC [this example in the microsoft docs](https://docs.microsoft.com/en-us/cpp/build/x64-calling-convention?view=vs-2019#example-of-return-value-4---user-type-result-by-value) shows that compounds are allowed:

```cpp
struct Struct2 {
   int j, k;    // Struct2 fits in 64 bits, and meets requirements for return by value.
};
Struct2 func4(int a, double b, int c, float d);
// Caller passes a in RCX, b in XMM1, c in R8, and d in XMM3;
// callee returns Struct2 result by value in RAX.
```

--- Comment #16 by gopherbot ---
Change https://golang.org/cl/262197 mentions this issue: `go/analysis/passes/asmdecl: add support for ABI selector clauses`

--- Comment #17 by gopherbot ---
Change https://golang.org/cl/262319 mentions this issue: `reflect,runtime: use internal ABI for selected ASM routines`

--- Comment #18 by gopherbot ---
Change https://golang.org/cl/262317 mentions this issue: `cmd/dist,cmd/go: broaden use of asm macro GOEXPERIMENT_REGABI`

--- Comment #19 by gopherbot ---
Change https://golang.org/cl/259445 mentions this issue: `cmd/compile,cmd/link: initial support for ABI wrappers`

--- Comment #20 by gopherbot ---
Change https://golang.org/cl/260477 mentions this issue: `cmd/asm: allow def/ref of func ABI when compiling runtime`

--- Comment #21 by gopherbot ---
Change https://golang.org/cl/262318 mentions this issue: `cmd: go get golang.org/x/tools@d1624618 && go mod vendor`

--- Comment #22 by gopherbot ---
Change https://golang.org/cl/262117 mentions this issue: `cmd/compile: delay expansion of OpArg until expand_calls`

--- Comment #23 by gopherbot ---
Change https://golang.org/cl/249458 mentions this issue: `cmd/compile: avoid generating CSEs; do all aggregates; maintain debug names`

--- Comment #24 by gopherbot ---
Change https://golang.org/cl/263271 mentions this issue: `runtime: fix sub-uintptr-sized Windows callback arguments`

--- Comment #25 by aclements ---
Just an update on this: we were hoping to land this for 1.16, but that was always going to be a bit of a stretch, and at this point we won't be able to make 1.16. Since we're making good progress and have a lot of work in flight, the current plan is to branch when the freeze comes and finish up the work there. Landing this at the beginning of 1.17 isn't the worst thing since that will give it lots of soak time. There's some concern about the risk of landing both this and generics in 1.17, but I believe they will be fairly orthogonal and the nature of the register ABI work is such that we should be able to test it pretty thoroughly and things are likely to fail loudly if there are bugs.

--- Comment #26 by aarzilli ---
> There's some concern about the risk of landing both this and generics in 1.17

1.17 -> 2.0?

--- Comment #27 by rsc ---
It sounds like everyone involved is on board for doing this in Go 1.17. 
Adding to proposal minutes for wider visiblity, but seems headed for likely accept.


--- Comment #28 by mewmew ---
> An incomplete and evolving list of tasks:

@aclements Consider adding a bullet point tracking the implementation of DWARF locations for arguments and results (contained in registers). Having good support for Go calling conventions in GDB and Delve is well worth a tracking bullet point :)

This work is already outlined in https://go.googlesource.com/proposal/+/master/design/40724-register-calling.md

> DWARF locations: The compiler will need to generate DWARF location lists for arguments and results. It already has this ability for local variables, and we should reuse that as much as possible. We will need to ensure Delve and GDB are compatible with this. Both already support location lists in general, so this is unlikely to require much (if any) work in these debuggers.


--- Comment #29 by aclements ---
@mewmew , thanks, I've added some bullets to the list for this. Hopefully there's nothing to actually do here, but you're right it's good to track that we need to make sure this works.

--- Comment #30 by gopherbot ---
Change https://golang.org/cl/258137 mentions this issue: `reflect,runtime: support amd64 register ABI for reflect.Call`
