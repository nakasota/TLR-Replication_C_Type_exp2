=== Fetching Proposal: I_kwDOAWBuf847dWZP ===
Issue URL: https://github.com/golang/go/issues/48409

==== [Issue Title] ====
runtime/debug: soft memory limit

==== [Issue Body] ====
# Proposal: Soft memory limit

Author: Michael Knyszek

## Summary

I propose a new option for tuning the behavior of the Go garbage collector by setting a soft memory limit on the total amount of memory that Go uses.

This option comes in two flavors: a new `runtime/debug` function called `SetMemoryLimit` and a `GOMEMLIMIT` environment variable. In sum, the runtime will try to maintain this memory limit by limiting the size of the heap, and by returning memory to the underlying platform more aggressively. This includes with a mechanism to help mitigate garbage collection death spirals. Finally, by setting `GOGC=off`, the Go runtime will always grow the heap to the full memory limit.

This new option gives applications better control over their resource economy. It empowers users to:
* Better utilize the memory that they already have,
* Confidently decrease their memory limits, knowing Go will respect them,
* Avoid unsupported forms of garbage collection tuning.

## Details

Full design document [found here.](https://github.com/golang/proposal/blob/master/design/48409-soft-memory-limit.md)

Note that, for the time being, this proposal intends to supersede #44309. Frankly, I haven't been able to find a significant use-case for it, as opposed to a soft memory limit overall. **If you believe you have a real-world use-case for a memory target where a memory limit with `GOGC=off` would not solve the same problem, please do not hesitate to post on that issue, contact me on the gophers slack, or via email at mknyszek@golang.org. Please include as much detail as you can.**

==== [Comments] ====

--- Comment #1 by gopherbot ---
Change https://golang.org/cl/350116 mentions this issue: `design: add proposal for a soft memory limit`

--- Comment #2 by mpx ---
Afaict, the impact of memory limit is visible once the GC is CPU throttled, but not before. Would it be worth exposing the current effective GOGC as well?

--- Comment #3 by mknyszek ---
@mpx I think that's an interesting idea. If `GOGC` is not off, then you have a very clear sign of throttling in telemetry. However, if `GOGC=off` I think it's harder to tell, and it gets blurry once the runtime starts bumping up against the GC CPU utilization limit, i.e. what does effective `GOGC` mean when the runtime is letting itself exceed the heap goal?

I think that's pretty close. Ideally we would have just one metric that could show, at-a-glance, "are you in the red, and if so, how far?"

--- Comment #4 by raulk ---
In case you find this useful as a reference (and possibly to include in "prior art"), the [go-watchdog](https://github.com/raulk/go-watchdog/) library schedules GC according to a user-defined policy. It can infer limits from the environment/host, container, and it can target a maximum heap size defined by the user. I built this library to deal with https://github.com/golang/go/issues/42805, and ever since we integrated it into https://github.com/filecoin-project/lotus, we haven't had a single OOM reported.

--- Comment #5 by rsc ---

This proposal has been added to the [active column](https://golang.org/s/proposal-status#active) of the proposals project
and will now be reviewed at the weekly proposal review meetings.
â€” rsc for the proposal review group


--- Comment #6 by rsc ---
@mknyszek what is the status of this? 

--- Comment #7 by mknyszek ---
@rsc I believe the design is complete. I've received feedback on the design, iterated on it, and I've arrived at a point where  there aren't any major remaining comments that need to be addressed. I think the big question at the center of this proposal is whether the API benefit is worth the cost. The implementation can change and improve over time; most of the details are internal.

Personally, I think the answer is yes. I've found that mechanisms that respects users' memory limits and that give the GC the flexibility to use more of the available memory are quite popular. Where Go users implement this themselves, they're left working with tools (like `runtime.GC`/`debug.FreeOSMemory` and heap ballasts) that have some significant pitfalls. The proposal also takes steps to mitigate the most significant costs of having a new GC tuning knob.

In terms of implementation, I have some of the foundational bits up for review now that I wish to land in 1.18 (I think they're uncontroversial improvements, mostly related to the scavenger). My next step is create a complete implementation and trial it on real workloads. I suspect that a complete implementation won't land in 1.18 at this point, which is fine. It'll give me time to work out any unexpected issues with the design in practice.

--- Comment #8 by rsc ---
Thanks for the summary. Overall the reaction here seems overwhelmingly positive.

Does anyone object to doing this?


--- Comment #9 by kent-h ---
> I have some of the foundational bits up for review now that I wish to land in 1.18

> I suspect that a complete implementation won't land in 1.18

@mknyszek I'm somewhat confused by this.  At a high level, what are you hoping to include in 1.18, and what do you expect to come later?
(Specifically: will we have extra knobs in 1.18, or will these changes be entirely internal?)

--- Comment #10 by mknyszek ---
@Kent-H The proposal has not been accepted, so the API will definitely not land in 1.18. All that I'm planning to land is work on the scavenger, to make it scale a bit better. This is useful in its own right, and it happens that the implementation of `SetMemoryLimit` as described in the proposal depends on it. There won't be any internal functionality pertaining to `SetMemoryLimit` in the tree in Go 1.18.

--- Comment #11 by rsc ---

Based on the discussion above, this proposal seems like a **[likely accept](https://golang.org/s/proposal-status#likely-accept)**.
â€” rsc for the proposal review group


--- Comment #12 by rsc ---

No change in consensus, so **[accepted](https://golang.org/s/proposal-status#accepted)**. ðŸŽ‰
This issue now tracks the work of implementing the proposal.
â€” rsc for the proposal review group


--- Comment #13 by gopherbot ---
Change https://go.dev/cl/393401 mentions this issue: `runtime: add a non-functional memory limit to the pacer`

--- Comment #14 by gopherbot ---
Change https://go.dev/cl/353989 mentions this issue: `runtime: add GC CPU utilization limiter`

--- Comment #15 by gopherbot ---
Change https://go.dev/cl/393400 mentions this issue: `runtime: add byte count parser for GOMEMLIMIT`

--- Comment #16 by gopherbot ---
Change https://go.dev/cl/394220 mentions this issue: `runtime: maintain a direct count of total allocs and frees`

--- Comment #17 by gopherbot ---
Change https://go.dev/cl/394221 mentions this issue: `runtime: set the heap goal from the memory limit`

--- Comment #18 by gopherbot ---
Change https://go.dev/cl/393402 mentions this issue: `runtime: track how much memory is mapped in the Ready state`

--- Comment #19 by gopherbot ---
Change https://go.dev/cl/397018 mentions this issue: `runtime/debug: export SetMemoryLimit`

--- Comment #20 by gopherbot ---
Change https://go.dev/cl/397015 mentions this issue: `runtime: remove float64 multiplication in heap trigger compute path`

--- Comment #21 by gopherbot ---
Change https://go.dev/cl/397016 mentions this issue: `runtime: create async work queue to handle runtime triggers`

--- Comment #22 by gopherbot ---
Change https://go.dev/cl/397017 mentions this issue: `runtime: make the scavenger and allocator respect the memory limit`

--- Comment #23 by gopherbot ---
Change https://go.dev/cl/397014 mentions this issue: `runtime: check the heap goal and trigger dynamically`

--- Comment #24 by gopherbot ---
Change https://go.dev/cl/397679 mentions this issue: `runtime: update inconsistent gcController stats more carefully`

--- Comment #25 by gopherbot ---
Change https://go.dev/cl/397678 mentions this issue: `runtime: move inconsistent memstats into gcController`

--- Comment #26 by gopherbot ---
Change https://go.dev/cl/397677 mentions this issue: `runtime: clean up inconsistent heap stats`

--- Comment #27 by gopherbot ---
Change https://go.dev/cl/399014 mentions this issue: `runtime: replace PI controller in pacer with simpler heuristic`

--- Comment #28 by gopherbot ---
Change https://go.dev/cl/398834 mentions this issue: `runtime: rewrite pacer max trigger calculation`

--- Comment #29 by gopherbot ---
Change https://go.dev/cl/399474 mentions this issue: `runtime: redesign scavenging algorithm`

--- Comment #30 by gopherbot ---
Change https://go.dev/cl/403614 mentions this issue: `runtime/metrics: add /gc/cpu/limiter-overflow:cpu-seconds metric`
