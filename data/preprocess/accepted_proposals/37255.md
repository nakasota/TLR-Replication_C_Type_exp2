=== Fetching Proposal: MDU6SXNzdWU1NjYwMDc0NDA= ===
Issue URL: https://github.com/golang/go/issues/37255

==== [Issue Title] ====
os/signal: add NotifyContext function

==== [Issue Body] ====
As previously discussed on issues such as #21521 and #16472, or on several other places handling POSIX signals through context seems to be somewhat useful (and a little bit hard to do correctly?), and I would like to propose a way to handle it by adding a new signal.WithContext function.

There's also an idea to improve the current approach to handling signals (see https://github.com/golang/go/issues/21521#issuecomment-337038699). I didn't give it a try yet, unfortunately. I only found the earlier proposals here after trying to write some code, so I decided to create this new issue anyway to share my idea.

People using some sort of it or talking about the subject:
* https://github.com/henvic/ctxsignal (package I wrote a while ago)
* https://twitter.com/dmitshur/status/1227777318162030592 (thread)
* https://twitter.com/matryer/status/869096368039710720 (thread)
* [Make Ctrl+C cancel the context.Context](https://medium.com/@matryer/make-ctrl-c-cancel-the-context-context-bd006a8ad6ff) (blog post)
* https://github.com/oklog/run/commit/9c53bcd6fefd554246da88d55efcc283aff63659
* https://github.com/FiloSottile/mostly-harmless/blob/22c6a9e08ad95b602b470652ad2d401d8750e264/covfefe/covfefe.go#L118-L139
* https://github.com/shurcooL/home/blob/d0f5a32e4901b05ae9979b1a9e7b67caba549778/main.go#L61-L73
* https://github.com/search?l=Go&p=1&q=context+signal&type=Repositories lists 18 other packages for the same thing.

==== [Comments] ====

--- Comment #1 by gopherbot ---
Change https://golang.org/cl/219640 mentions this issue: `os/signal: add WithContext to control single usage signals easily.`

--- Comment #2 by henvic ---
Also please notice that this change would, unfortunately, require introducing packages time and context as dependencies for package os/signal.

--- Comment #3 by ianlancetaylor ---
Could you describe the new function in this issue, so that we don't have to figure it out from the CL?  Thanks.

--- Comment #4 by henvic ---
The new function receives a parent context and a variadic number of signals that can be used to cancel this context. When a parent context is canceled or when one of the signals is handled, the context is canceled.

Example of handling cancelation of a slow process through SIGTERM and SIGINT:

```go
func main() {
	ctx, cancel := signal.WithContext(context.Background(), syscall.SIGTERM, syscall.SIGINT)
	defer cancel()

	// ...
	slow.Run(ctx)
	cancel()

	// to verify if the slow function was terminated by a signal, we can use:
	var sigErr signal.ContextError
	if errors.As(ctx.Err(), &sigErr) {
		fmt.Printf("slow function terminated by signal %q\n")
	}
}
```

On another side, we have the example shown for https://golang.org/pkg/net/http/#Server.Shutdown that, in my opinion, would not be simplified by this.

--- Comment #5 by robpike ---
Perhaps this should be a function of the context package instead, since it creates a context and it's pretty much all about contexts.

ctx, cancel := context.Signal(context.Background(), syscall.SIGTERM, syscall.SIGINT)

Not sure it's the right idea at all, just throwing it out there.

--- Comment #6 by mattn ---
If several packages handle same signal, and runtime does not handle those contexts equally, context.Signal won't work correctly, I think. If runtime does not handle them,  `context.Signals` is not best way . The os/signal package has the potential feeling for us that it is only used in applications, but the context package is used by everyone. So I'm thinking `signal.WithContext` is better since it make users known that we should do it in only one place. (But I'm also not sure this is right idea)

--- Comment #7 by rsc ---
To be clear, the runtime does already broadcast signals to anyone who has signed up to hear about them, using signal.Notify. So this could be done as a separate package without worrying about other possible uses of os/signal.

context.WithCancelSignal seems like the clearest name, and it would appear right next to context.WithCancel in the docs.

/cc @Sajmani for thoughts


--- Comment #8 by rsc ---
It sounds like maybe we have converged on `context.WithCancelSignal`. I've retitled.
Based on the discussion above, this seems like a **likely accept**.



--- Comment #9 by henvic ---
Great! Thanks for the feedback. I'll try to send a new CL proposing an implementation for a `context.WithCancelSignal` command Monday.

--- Comment #10 by undeconstructed ---
Is there a plan for how this would be documented? Signals are process scoped, so any library using this feature could be problematic. And in a server I would normally catch signals at main level and propagate down, which can be easily/lazily done already by cancelling a single parent context. So using signals for local task cancellation seems only suited for interactive apps. If that's not too controversial, could it be made clear in the docs?

--- Comment #11 by henvic ---
I pushed a new implementation to https://go-review.googlesource.com/c/go/+/219640/1

--- Comment #12 by ianlancetaylor ---
I note that currently according to go/build/deps_test.go context depends only on

    {"errors", "internal/reflectlite", "sync", "sync/atomic", "time"}

This is going to add a dependency of context on os and os/signal, which pulls in a lot more.  I don't know that it matters much, but it seems worth  mentioning.  Is anybody concerned about the additional dependencies?

--- Comment #13 by robpike ---
I was worried too, but if you look at the full lists it doesn't add much transitively. In the current tree:

```
% deps io os os/signal | sort -u
errors
internal/bytealg
internal/cpu
internal/oserror
internal/poll
internal/race
internal/reflectlite
internal/syscall/execenv
internal/syscall/unix
internal/testlog
io
os
runtime
runtime/internal/atomic
runtime/internal/math
runtime/internal/sys
sync
sync/atomic
syscall
time
unsafe
% deps context
errors
internal/bytealg
internal/cpu
internal/oserror
internal/race
internal/reflectlite
runtime
runtime/internal/atomic
runtime/internal/math
runtime/internal/sys
sync
sync/atomic
syscall
time
unsafe
%
```

The only addition would be `io` and `os` themselves, and three internals:`internal/syscall/{unix,execenv}` and `internal/testlog`.

I'm not saying I'm happy about this, but it's arguably OK.





--- Comment #14 by mattn ---
If receiving the signal in goroutine and context.WithCancelSignal, I wonder how this work.

```
package main

import (
	"context"
	"os"
	"os/signal"
	"time"
)

func doSomething(ctx context.Context) {
	// ...
}

func main() {
	s := make(chan os.Signal, 1)
	signal.Notify(s, os.Interrupt)

	ctx := context.WithCancelSignal(s)
	doSomething(ctx)

	go func() {
		<-s
		println("interrupted")
	}()

	var b [1]byte
	os.Stdin.Read(b[:])
	time.Sleep(time.Second)
	println("exit")
}
```



--- Comment #15 by ianlancetaylor ---
One possibility to avoid adding a dependency on os and os/signal is to have the context package reach into the runtime package as the os/signal package already does.  One consideration about depending on the os/signal package is that the os/signal package has an init function that slightly changes how the runtime package handles signals.  But we might be able to get rid of that anyhow.

--- Comment #16 by ianlancetaylor ---
@mattn The proposed `context.WithCancelSignal` function takes a signal as an argument, not a channel.

But assuming you meant to pass `os.Interrupt` to `context.WithCancelSignal`, then on receipt of a signal both 1) the context would be canceled; 2) the signal would be sent on the channel `s`.

--- Comment #17 by mattn ---
Oh, I see.

--- Comment #18 by henvic ---
I'm worried about the number of changes in the signal package too. I'll take a look into the runtime package Friday to see if I understand @ianlancetaylor's idea and to see if I can come up with something.

--- Comment #19 by rsc ---
FWIW, I think we can easily hook this into the runtime package directly (with an internal package if needed) and bypass os and os/signal, to keep the deps lite. The general trend is to avoid os where possible, and all this code only needs the runtime.

No change in consensus here, so accepted.


--- Comment #20 by rogpeppe ---
FWIW putting signal-related behaviour in the `context` package feels wrong to me. Currently the functionality in the context package is entirely about contexts themselves and time. It's a very clean and delimited API. However, signals are a very system-specific concept. The inclusion of `syscall` in the public API makes this quite clear. `context.WithCancelSignal` reads nicely as a name, I'll admit, but it feels like we're mixing concerns inappropriately to me, and I would much prefer the function to go into the signal package itself.

I think this may also be of concern to implementations of Go that run on limited infrastructure. For example in tinygo, the `context` package is currently available but the `os/signal` package is not. Adding this functionality to `context` would mean that only some of the `context` API could be implemented on that platform.

--- Comment #21 by robpike ---
I agree. Not a domain expert but there seems to be a model break going on.

--- Comment #22 by henvic ---
Thanks, @rogpeppe. Your concern sounds solid to me.
Perhaps this should indeed go to the signal package after all (or maybe it has its own issues besides feeling unnatural)?

Any thoughts? /cc @deadprogram

--- Comment #23 by ianlancetaylor ---
@rsc There is disagreement that arose after the proposal moved through likely accepted to accepted.  Should we move back to the proposal stage?

--- Comment #24 by rsc ---
OK, moving proposal back to active (un-accepting).


--- Comment #25 by rsc ---
@rogpeppe, I am a little confused about "the inclusion of syscall in the public API".
The public API would be

    package context
    func WithCancelSignal(ctx Context, ... os.Signal) (Context, func())

It mentions _os_, not syscall. It's true that calls might pass signals defined in syscall, but that will happen regardless.

It seems like the three choices would be:

   - syscall.SomethingContext - syscall imports context, argument can't be os.Signal, would need to be syscall.Signal, more OS-dependent than what was previously accepted.

  - os/signal.SomethingContext - os/signal imports context. argument could be os.Signal

 - os.SomethingContext - os imports context. argument could be os.Signal

It seemed cleaner to keep the context constructors in context. Is there a good argument for os or os/signal to start importing context and turn it around?



--- Comment #26 by Merovius ---
I know that "it feels wrong to me" isn't a great argument, but I agree with @rogpeppe - this felt wrong to me when it was accepted and it still feels wrong. `context` feels, to me, as a relatively pure abstraction and signal-handling like a relatively platform-dependent use-case.

To try a more tangible argument: Say, hypothetically, the [opentracing API](https://godoc.org/github.com/opentracing/opentracing-go) would make it into the stdllib. Would we put [StartSpanFromContext](https://godoc.org/github.com/opentracing/opentracing-go#StartSpanFromContext) into the `context`-package, just because it returns a `Context`? That seems far-fetched. Of course, we wouldn't put the opentracing API into the stdlib as is and whatever *would* make it might well have a more natural answer. But IMO it still illustrates that something might return a context, but still fit more naturally into another package.

Another "argument" is that `signal.WithContext` (or whatever) is naturally implemented as a pretty simple wrapper around `context.WithCancel`, so it at least has no need to share a namespace with the rest of the context package. Of course it also has no need to share a namespace with the signal-package, but at least it seems closer aligned with that concern IMO. 

At the end of the day, both locations seem not fully satisfying to me and as a corollary I can also live with either. But if I was the one who's vague feelings it gets down to, I'd put it into `signal` as well :)

--- Comment #27 by ianlancetaylor ---
If we do decide that os/signal is the right place for this functionality, I think the name should be simply `signal.Context`.

```Go
package signal
func Context(ctx context.Context, ...os.Signal) (context.Context, context.CancelFunc)
```

I don't see how `signal.WithContext` makes sense, and any name that really describes the scenario gets pretty long, as in `signal.CancelContextOnSignal`.  I think `signal.Context` is clear enough.

@robpike Note that you suggested the context package above in https://github.com/golang/go/issues/37255#issuecomment-586801888 and then changed your mind in https://github.com/golang/go/issues/37255#issuecomment-611946231.  Which is fine, just wanted to double check.

--- Comment #28 by robpike ---
@ianlancetaylor I didn't exactly change my mind. If you read those comments again, I think you'll see my position has been tentative at best all along.  @Merovius explains it well, I think. Context is and perhaps should remain an abstraction free of outside dependency.

I want to reiterate though that I am speaking only from the point of view of a general API designer, not as someone who is a heavy user of either the context or signal packages.

--- Comment #29 by rogpeppe ---
> It mentions os, not syscall. It's true that calls might pass signals defined in syscall, but that will happen regardless.

Yes, sorry, my mistake - I read the `syscall` values in the examples and assumed the wrong signature. I think my point still stands though. The `os` package is quite large and system specific, which doesn't seem to fit with the small `context` API to me.

> It seemed cleaner to keep the context constructors in context. Is there a good argument for os or os/signal to start importing context and turn it around?

I think so. Anyone that wishes to add _any_ kind of custom cancellation to a context must provide their own constructor, and I don't see why signal-based cancellation should be any different.
If it's inefficient to do so, then perhaps that's something more general that could be addressed in the context package.

FWIW I support @ianlancetaylor's suggestion of a `signal.Context` function.

--- Comment #30 by rsc ---
@ianlancetaylor @bradfitz and I bikeshedded the name for a while. This is the best we came up with:

```
package signal
func NotifyContext(parent context.Context, signals ...os.Signal) (ctx context.Context, cancel context.CancelFunc)
```

>    NotifyContext returns a copy of the parent context that is marked done
  (it's Done channel is closed) when one of the listed signals arrives,
  when the returned cancel function is called, or when the parent context's
  Done channel is closed, whichever happens first.

> Canceling this context releases resources associated with it, so code should
  call cancel as soon as the operations running in this Context complete.

Thoughts?
