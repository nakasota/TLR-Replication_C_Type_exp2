=== Fetching Proposal: MDU6SXNzdWU5MDc3NzQzNzM= ===
Issue URL: https://github.com/golang/go/issues/46477

==== [Issue Title] ====
spec: generics: permit type parameters on aliases

==== [Issue Body] ====
The generics proposal says "A type alias may refer to a generic type, but the type alias may not have its own parameters. This restriction exists because it is unclear how to handle a type alias with type parameters that have constraints."

I propose this should be relaxed and type aliases allowed to have their own type parameters. I think there's a clear way to handle type aliases with constrained type parameters: uses of the type alias need to satisfy the constraints, and within the underlying type expression those parameters can be used to instantiate other generic types that they satisfy.

I think it's fine to continue allowing `type VectorAlias = Vector` as in the proposal, but this should be considered short-hand for `type VectorAlias[T any] = Vector[T]`. More generally, for generic type `B` with type parameters `[T1 C1, T2 C2, ..., Tn Cn]`, then `type A = B` would be the same as `type A[T1 C1, T2 C2, ..., Tn Cn] = B[T1, T2, ..., Tn]`.

In particular, something like this would be an error:

```
type A[T comparable] int
type B[U any] = A[U]   // ERROR: U does not satisfy comparable
type C B[int]
```

As justification for this, analogous code in the value domain would give an error:

```
func F(x int) {}
func G(y interface{}) { F(y) }  // ERROR: cannot use y (type interface{}) as int
func H() { G(42) }
```

I suspect if `TParams` is moved from `Named` to `TypeName` and type instantiation is similarly changed to start from the `TypeName` instead of the `Type`, then this should work okay.

/cc @griesemer @ianlancetaylor @findleyr @bcmills 

==== [Comments] ====

--- Comment #1 by findleyr ---
If this proposal were accepted, would the following code be valid?

```go
type A[T any] int
type B[U comparable] = A[U]
```

I.e. would it be possible to define an alias which tightens the constraints of the aliased type?

IMO the example in the value domain is more analogous to defining a _new_ named type, which already behaves as expected:

```go
type A[T comparable] int
type B[U any] A[U] // ERROR: U does not satisfy comparable
```

Aliasing seems more analogous to function value assignment, for which we don't redeclare parameters:

```go
func F(x int) {}
var G = F
```

I think you're right about how this could be implemented, but I wonder if it is conceptually coherent. Specifically, I wonder about whether we should think of the declaration as _parameterizing_ the type, or as _defining a parameterized type_, and whether it still makes sense to call the example with additional restrictions above an _alias_.

I'll also note that as you point out, our decisions with respect to the go/types API have real consequences for how easy it would be to relax this restriction on aliases in the future, so it is good to talk about this now. Thanks for raising this issue!



--- Comment #2 by mdempsky ---
> I.e. would it be possible to define an alias which tightens the constraints of the aliased type?

Yes. `U` (type parameter with bound `comparable`) satisfies the constraint `any`, so that's a valid type declaration in my mind. But similarly, trying to instantiate `B[[]int]` would be invalid, because `[]int` does not satisfy `comparable`, even though it satisfies the underlying `any`.

I would expect that the type checker would see `B[[]int]`, resolve `B` to the `TypeName` and check it against the type parameters, and then reject it as invalid, before proceeding to instantiating/substituting its `Type` with the type argument `[]int`.

> Aliasing seems more analogous to function value assignment, for which we don't redeclare parameters:

Note that `var G = F` is really shorthand there for `var G func(int) = F`. You're not allowed to write `var G func(interface{}) = F`, for example, even if you only ever call `G` with `int` arguments.

But this is also why I suggest still allowing `type A = B` as shorthand for explicitly writing out type parameters for the alias declaration.

--- Comment #3 by griesemer ---
There is a [reason](https://github.com/golang/go/issues/46477#issuecomment-852701491) why we didn't do this in the first place.

~~I don't have any principal objections to this proposal. If we accept this, I wonder whether we should still permit the `type A = B` form as it does deviate from the current design which requires that every use of a generic type requires an instantiation.~~

~~I'm inclined to proceed in one of two ways:~~
~~1) Disallow (not implement) the form `type A = B` for Go1.17. It's not crucial and we can always add it later.~~
~~2) Implement this proposal instead of permitting `type A = B`.~~



--- Comment #4 by bcmills ---
I seem to recall @rogpeppe raising a similar point in various conversations.

--- Comment #5 by bcmills ---
@findleyr

> Aliasing seems more analogous to function value assignment, for which we don't redeclare parameters:

Note that we _do_ allow function value assignment to strengthen (but not weaken) a type via assignability, which IMO is analogous to strengthening type constraints on a type declaration.

Consider [this program](https://play.golang.org/p/Pe0x94M0U_X):

```go
package main

import "context"

func cancel() {}

type thunk func()

var f = cancel
var g context.CancelFunc = cancel
```

In that program, `var f = cancel` is shorthand for `var f func() = cancel`.

The declaration `var g context.CancelFunc = cancel` refers to the exact same function value, but with a stronger type (one that is not assignable to `thunk`).

--- Comment #6 by jimmyfrasche ---
It looks like it could fall out of the definition but, to be explicit, partial application would also be useful:
```
type Named[T any] = Map[string, T]
```

--- Comment #7 by mdempsky ---
@griesemer If we proceed with this proposal, I think it could be a nice convenience to keep `type A = B` as short-hand. But as it's not essential, I'd similarly be fine with just removing it altogether. We can always re-add it in the future if appropriate.

And yes, the deviating from the norm of requiring instantiation is what threw me off. I had written some code that was working under the assumption that if I only started from non-generic declarations, then I would never see a non-instantiated type. But that doesn't hold for the `type A = B` form. (Fortunately though, it's not hard to special case this one instance either.)

--- Comment #8 by findleyr ---
@bcmills 

> Note that we do allow function value assignment to strengthen (but not weaken) a type via assignability, which IMO is analogous to strengthening type constraints on a type declaration.

The example from https://github.com/golang/go/issues/46477#issue-907774373 made the analogy of function parameters with type parameters (which makes sense).  In that analogy, we don't allow changing function parameter types when assigning [[example](https://play.golang.org/p/_S0Hr9hE8bb)], i.e. we don't support covariant function assignment.


--- Comment #9 by bcmills ---
> In that analogy â€¦ we don't support covariant function assignment.

Sure, but pretty much the _entire point_ of type parameters is to support variance in types. ðŸ˜‰

--- Comment #10 by neild ---
What is the use case for permitting parameters on type aliases?

--- Comment #11 by griesemer ---
~~@neild The same reason for which type aliases were introduced in the first place, which is to make refactoring across package boundaries easier (or possible, depending on use case).~~

I misread this comment. See [below](https://github.com/golang/go/issues/46477#issuecomment-852716124).

--- Comment #12 by griesemer ---
Going through my notes I remember now why we didn't go this route in the first place: Note that an alias is just an alternative name for a type, it's not a new type. Introducing a smaller set of type arguments (as [suggested](https://github.com/golang/go/issues/46477#issuecomment-852393567) above), or providing stronger type constraints seems counter that idea. Such changes arguably define a new type and then one should do that: declare a new defined type, i.e., leave the `=` away. I note that @findleyr [pointed out just that](https://github.com/golang/go/issues/46477#issuecomment-852358031) in the 2nd comment on this proposal.
This would mean that the respective methods also have to be redefined (likely as forwarders) but that seems sensible if the type constraints are narrowed or partially instantiated.

In summary, I am not convinced anymore that this is such a good idea. We have explored the generics design space for the greater part of two years and the devil really is in the details. At this point we should not introduce new mechanisms until we have collected some concrete experience.

I suggest we put this on hold for the time being.

--- Comment #13 by neild ---
@griesemer I don't see what the refactoring case is for changing the constraints of a type. As you say, an alias is just an alternative name for a type, but an alternative name with altered constraints is a subtler concept that I struggle to see the use for.

I may be missing something. A concrete example of when you'd use this would be useful.

--- Comment #14 by griesemer ---
@neild Agreed - I misread your comment as "what is the use of allowing alias types for generic types" - my bad. See my [comment](https://github.com/golang/go/issues/46477#issuecomment-852701491
) just before your reply.


--- Comment #15 by mdempsky ---
> I don't see what the refactoring case is for changing the constraints of a type.

Under this proposal, you can do more with parameterized type aliases than just change the constraints. E.g., see https://github.com/golang/go/issues/46477#issuecomment-852393567 for using type parameters to provide default arguments to other generic types. I called out the constraint change to clarify the semantics, not because I expect that's something people are likely to do in practice.

I anticipate analogous to how we added type aliases to facilitate large-scale refactorings while maintaining type identity, we're going to face situations where generic types need to be refactored to add, remove, or change parameters while also maintaining type identity. Having parameterized type aliases would facilitate that. I think if just "declaring a new defined type" was always an adequate solution, we could have skipped adding type aliases too.

I think it's fine though if Go 1.18 doesn't have parameterized type aliases. But I at least think we should try to ensure the go/types APIs are forward compatible with adding parameterized type aliases.

--- Comment #16 by findleyr ---
@bcmills 

> Sure, but pretty much the entire point of type parameters is to support variance in types. ðŸ˜‰

FWIW, I don't follow this argument. We still support variance in types no matter what we decide about this proposal, just like we allow variance in function arguments whether or not we allow covariant assignment of function values. I think we're dipping in and out of the 'meta' realm.  The point I was trying to make is that if we're trying to argue by analogy with the value domain, wrapping a function is more like defining a new named type (or perhaps more correctly like struct embedding), and aliasing is more like assignment.  Since we don't allow covariant assignment for functions, it's arguably a bit inconsistent to allow covariant assignment for "meta functions" (if that's how we think about generic declarations).

@griesemer 

> This would mean that the respective methods also have to be redefined (likely as forwarders) but that seems sensible if the type constraints are narrowed or partially instantiated.

Or use embedding, which might be more analogous to wrapping a function in the value domain.

> I suggest we put this on hold for the time being.

Independent of whether we relax the restriction on aliases, this proposal indirectly makes the point that it matters whether we think of the "type" as generic or the "declaration" as generic, both in the current APIs and for future extensions of the language. For example, thinking of the type _declaration_ as generic allows relaxing this restriction on aliases. Thinking of the function _type_ as generic allows for generic interface methods and generic function literals. If we put this proposal on hold, we will still need to make API decisions that affect its feasibility.

--- Comment #17 by mdempsky ---
[re: value vs type domain analogies]

I want to clarify that I made this analogy initially to help explain how I intuit the relationships here. Go's values and types operate sufficiently distinctly and irregularly that I think trying to read too far into the analogy is going to hit rough edges and become more philosophical than actionable. E.g., the value domain has no analog to defined types and type identity, because it's impossible to create a copy of a Go value that's distinguishable from the original. (Emphasis: I'm talking specifically about *values* here, not variables.)

Certainly we should revisit these discussions when it comes time to add dependent types to Go 3 though. :)

--- Comment #18 by rogpeppe ---
> Note that an alias is just an alternative name for a type, it's not a new type.

I'm not sure that this is entirely true. What about this, which is currently allowed?

```
type S1[V any] struct { .... }

type S2 = S1[int]
```

`S2` neither an alternative name for an existing type _nor_ an entirely new type. More of a composite type, perhaps. Also, it does have _some_ identity of its own (its name is [used when it's embedded](https://github.com/golang/go/issues/21866))

> Introducing a smaller set of type arguments (as suggested above), or providing stronger type constraints seems counter that idea. Such changes arguably define a new type and then one should do that: declare a new defined type, i.e., leave the `=` away

Sometimes defining a new type isn't possible. For example, if a type is specifically mentioned in a type signature, it's not possible to use a new type - you _have_ to use the same type as the original. Also, the fact that all methods are lost when you define a new type is a real problem and embedding doesn't always work either.

For non-generic code, it might usually be possible to define a fully-qualified type alias like `S2` above, but in generic code that's often not possible because a type parameter might be free.

An example:

Say some package defines an `OrderedMap` container that allows an arbitrary comparison operation for keys:

```
package orderedmap

type Map[K any, V any, Cmp Comparer[K]] struct {
    ...
}

func (m *Map[K, V, Cmp]) Clone() *Map[K, V, Cmp]

func (m *Map[K, V, Cmp]) Get(k K) (V, bool)

type Comparer[K any] interface {
    Cmp(k1, k2 K) int
}
```

I want to implement a higher level container in terms of `orderedmap.Map`. In my implementation, only the value type is generic:

```
package foo

type Container[V any] struct {
}

func NewContainer[V any]() *Container[V] {
    ...
   var m *orderedmap.Map[internalKey, V, keyComparer]
}

type internalKey struct {
    ...
}

type keyComparer struct{}

func (keyComparer) Cmp(k1, k2 internalKey) int {
    ...
}
```

In the above code, whenever I wish to pass around the `orderedmap.Map[internalKey, V, keyComparer]` type, I have to do so explicitly in full. This could end up very tedious (and annoying to change when refactoring the code). It would be nice to be able to do:

```
type internalMap[V any] = orderedmap.Map[internalKey, V, keyComparer]
```

Then we can avoid duplicating the type parameters everywhere.

Defining a new type wouldn't be great here - you'd either have to explicitly forward all the methods (if you did `type internalMap[V any] orderedmap.Map[...]`) or reimplement some of the methods (if you did `type internalMap[V any] struct {orderedmap.Map[...]}`).

In short, I'm fairly sure that generic type aliases are going to be a much requested feature when people start using generics in seriousness, and that they're definitely worth considering now even if they're not implemented, so that the type checker isn't implemented in a way that makes it hard to add them later.

--- Comment #19 by rsc ---

This proposal has been added to the [active column](https://golang.org/s/proposal-status#active) of the proposals project
and will now be reviewed at the weekly proposal review meetings.
â€” rsc for the proposal review group


--- Comment #20 by beoran ---
I think we have to consider what exactly an alias is in Go language:

> Alias declarations
An alias declaration binds an identifier to the given type.
AliasDecl = identifier "=" Type .
Within the scope of the identifier, it serves as an alias for the type. 

Since an alias is an identifier, that is,  in essence, a name, it does not make sense for such a name to have  type parameters. An alias is simply a name for a type, not a type in itself. And names should not be parameterizable. 

If it is desirable to define a new generic type based on an other generic type, this should be done using different syntax than a type alias.

Therefore I, respectfully oppose this proposal.

--- Comment #21 by mdempsky ---
> I think we have to consider what exactly an alias is in Go language:

We're discussing amending the Go language spec here, so I think referring to the current wording is somewhat begging the question. If we decide to amend the spec to allow type-parameterized aliases, then I think it's within scope to amend those sentences too.

> If it is desirable to define a new generic type based on an other generic type, this should be done using different syntax than a type alias.

We have existing syntax for type aliases and for type parameters, and conveniently they're compatible. I don't see why we'd want to use a *new* syntax for type-parameterized aliases.

--- Comment #22 by beoran ---
Well, the reason I refer to the current spec is because that explains what the current concept of am alias is. If we were to change the spec, the concept of what an alias is will also change quite radically. An alias will not be just a name for a type anymore. And I feel this will make Go quite a bit harder to learn. 

Furthermore, I would say that the changing  concept of an alias as a name to something else is at least not conceptually backwards compatible. With this proposal an alias is not just a name any more, but also a way to define types. Since the concept of this proposal is different, i feel the syntax should be different as well. Maybe just using := in stead of = for example.

--- Comment #23 by jimmyfrasche ---
This would not let you define any new types: it would let you give a name to a subfamily of a family of types.

--- Comment #24 by rsc ---
What is the concrete benefit that this would bring?
And is it necessary to have in Go 1.18, or should we wait until a future release?


--- Comment #25 by beoran ---
@jimmyfrasche I don't know what "let you give a name to a subfamily of a family of types." even means. There is no such concept as "a family of types" AFAIK in Go. Definitely confusing, hence my opposition to it. And certainly we can wait until 1.18 and see if this turns out to be necessary after all. 

--- Comment #26 by mdempsky ---
> What is the concrete benefit that this would bring?

The concrete benefit is it gives a way to evolve code bases that use parameterized types. The same concern as why we added type aliases in the first place.

Otherwise, what happens when you have a large code base that relies on type `type Foo[T any] ...` and then you realize you need to change the type parameter list? How do you 3-step migrate code to use `Bar[T, int]` instead without breaking type identity in the process?

> And is it necessary to have in Go 1.18, or should we wait until a future release?

I don't think they need to be available in Go 1.18, as there's no code yet to migrate. But as @findleyr points out (https://github.com/golang/go/issues/46477#issuecomment-853044132), it does affect the go/types API (i.e., https://github.com/golang/go/issues/47916).

--- Comment #27 by beoran ---
@mdempsky I have to admit that this feature would be the only way to do clean refactoring as you describe. However, I think it should be only used for that. Otherwise we may get this confusing notions of "families of types". An "normal alias" and a "generic alias" should be seen as two separate features, because they do something fundamentally different.

--- Comment #28 by jimmyfrasche ---
@beoran I'll try to clarify my terminology.

A generic type `F[T any]` isn't a type: you can't have a value of type `F`. You can have a value of type `F[int]` or type `F[string]` and so on. One way to talk about this is to say that `F` is the family of types `F[int]`, `F[string]`, and so on for every `T` that satisfies `F`'s constraints.

If we allow `type Fint = F[int]` that's not creating a new type it's giving a name to `F` instantiated with `int`.

Similarly `type Fc[T comparable] = F[T]` isn't creating a new type or even a new generic type: it's describing the members of the family `F` where `T` is further restricted to the comparable types. All the types in `Fc` are still types in the family `F`, so `Fc` can be described as a subfamily of `F`.

That does expand what are now called type aliases beyond what they do today but all existing type aliases would still work exactly the same. If a new syntax were for given for "generic aliases", regular type aliases would be the special case where there are no type parameters involved, so then you'd have two ways to create a type alias. That seems more confusing than expanding the existing mechanism.

--- Comment #29 by beoran ---
Thanks for that explanation. What I understood from it is that in Go, a generic type is not a type. Which does make the name "generic type" a bit unfortunate. Anyway, as you say, only fully-specified instances of generic types are types themselves. I  also don't know if I like the name "type family", but your explanation does clarify it somewhat. 

Now that I see the value of this for refactoring, I am not opposed anymore to the proposal as such, provided that is is well explained and based on well-documented concepts. If the concept of type family will be used as the foundation for these aliases, then the this concept of type families should be added to the Go specs and documentation in the appropriate places.

--- Comment #30 by griesemer ---
One aspect that hasn't been discussed yet is the ability to add methods to a type through aliases. Presumably, the following declarations would be valid under this proposal:
```
type T[P any] struct{ ... }
func (T[P]) m() { ... }

type A0 = T[int]
func (A0) m0() { ... }

type A1[P C] = T[P]
func (A1[P]) m1(x P) { ... }

type A2[P C, Q D] = T[P]
func (A2[P, Q]) m2(x P, y Q) { ... }
```
`A0` would be identical to `T[int`, and `A1[P]` would be identical to `T[P]` for a suitable `P`. What about `A2`? Presumably it would not be permissible to add type parameters because otherwise different `A2[P, Q]` (with different `Q`) would be identical  to `T[P]` (which in turn would mean those different `A2[P, Q]` would be identical to each other which seems odd given that the method `m2` might depend on the 2nd type parameter).

Similarly, what about
```
type A3[P any] = T[int]
func (A3[P]) m3(x P) { ... }
```
Different `A3` instantiations can't possibly all be identical to `T[int]` since the `m3` method will be different for each `P`.

It seems that a parameterized alias declaration would not be allowed to introduce new type parameters, and constraints for type parameters could only be tightened, not loosened. With that later rule, there may be a co/contra-variant issue coming into play as well: for instance, if `A1` is an alias for `T` (above), `A1` is still not "completely" identical to `T` because we cannot simply use an `A1[Arg]` where a `T[Arg]` is permitted because the constraint for the `A1` type argument may be tighter than for the `T` type argument. This also means that we can't just drop type arguments in an alias. We have to keep them, and they have to have the same constraints.

If that is all true, then the only thing that can be achieved is a renaming of the type parameters, but then we might as well leave things alone.


