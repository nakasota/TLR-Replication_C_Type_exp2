=== Fetching Proposal: MDU6SXNzdWU5NTk5OTUyNjA= ===
Issue URL: https://github.com/golang/go/issues/47528

==== [Issue Title] ====
cmd/vet: warn when errors.As target has type *error

==== [Issue Body] ====
<!--
Please answer these questions before submitting your issue. Thanks!
For questions please use one of our forums: https://github.com/golang/go/wiki/Questions
-->

### What version of Go are you using (`go version`)?

<pre>
$ go version
go version go1.16.6 darwin/arm64
</pre>

### Does this issue reproduce with the latest release?
yes

### What did you do?

Wrote this code https://play.golang.org/p/16cU0kc8Lku and wondered why the errors matched.
```
var Err = errors.New("sentinel")
err := errors.New("foo")
if errors.As(err, &Err) {
  fmt.Println("why?")
}
```

Discussion in https://groups.google.com/g/golang-nuts/c/MaYJy_IRbYA/m/uCHV6P87EQAJ?utm_medium=email&utm_source=footer

### What did you expect to see?

Of course the code above is wrong, yet I didn't spot it. It would be nice if this kind of programming error could be detected:
- add a `govet` check that flags using plain `error`s with `errors.As` or
- @merovius suggested  `errors.errorString` should implement `As()` and return `false`, unless the pointers match. 

I'm unsure if the latter is possible. It would strictly break BC (and the function's description). On the other hand ist should only change behaviour in cases that seem invalid from the start?

==== [Comments] ====

--- Comment #1 by Merovius ---
> I'm unsure if the latter is possible. It would strictly break BC (and the function's description).

I don't think it break the functions description. It is the purview of any error type to implement `As()` the way it sees fit.

It does change the behavior of `errors.New`, but I don't think there is any API contract about the returned error implementing or not implementing other methods than `Error`. So, I would argue it changes behavior, but it doesn't break compatibility - if a user relies on the current behavior, they rely on undocumented implementation details.

Lastly, even if it *was* breaking compatibility, there is a clear exception in the Go 1 compatibility contract for fixing bugs. It is the clear intent of `errors.New` to return unique sentinel errors. The current behavior of `errors.As` when used with such an error is clearly a bug.

We can still have a vet check to warn about it, but I think the bug should be fixed either way.

--- Comment #2 by andig ---
> I don't think it break the functions description.

I was referring to:

> An error matches target if the error's concrete value is assignable to the value pointed to by target, or ...

The value here is assignable as types match. Having sentinel errors assignable in turn is more because we can't have `const` errors in Go...


--- Comment #3 by Merovius ---
But the complete paragraph is

> An error matches target if the error's concrete value is assignable to the value pointed to by target, or if the error has a method As(interface{}) bool such that As(target) returns true. In the latter case, the As method is responsible for setting target.

The existence of the `As` optional interface is specifically for cases like this, so that error types can overwrite the pure "assignability" behavior.

--- Comment #4 by Merovius ---
Well, [this is surprising behavior to me](https://play.golang.org/p/yAsXnTYvK-b). I would've expected `As` to be tried first, but it seems [it's only used as a fallback](https://cs.opensource.google/go/go/+/refs/tags/go1.16.6:src/errors/wrap.go;l=95).
With `errors.As` as it is right now, implementing `As` actually doesn't do anything in this case. I wonder why it is written that way.

--- Comment #5 by andig ---
That does indeed seem to contradict the wording of `errors.As`.

--- Comment #6 by bcmills ---
Perhaps `cmd/vet` should be changed to warn when the second argument to `errors.As` is statically known to have type `*error`?

That is pretty much guaranteed to indicate a bug, because it is _trivially_ true that the first argument (of type `error`) â€œis assignable to the value pointed to byâ€ a second argument of type `*error`.

--- Comment #7 by bcmills ---
CC @timothy-king 

--- Comment #8 by neild ---
> That does indeed seem to contradict the wording of errors.As.

The relevant wording is: "An error matches target if the error's concrete value is assignable to the value pointed to by target"

In this case, the target has type `*error` so the concrete value is trivially assignable to `*target`. A vet check for this case seems like a good idea, since there is never a reason to pass an `*error` as the second parameter of `errors.As`.

--- Comment #9 by Merovius ---
@neild I'm not really trying to nitpick wording, but I think it is unexpected that an error might have an `As` method which is not called if the error is assignable. I would imagine it to work like `json.Unmarshaler`, where the default behavior is simply overwritten by the optional interface.

--- Comment #10 by Merovius ---
(If I *were* to nitpick wording, I'd argue that "X is the case if A or B. In the latter case, the method As is responsibleâ€¦" seems to imply to me, that `As` should be called if B is true to determine the outcome of the conversion, regardless of whether or not A is also true)

--- Comment #11 by Merovius ---
@bcmills Yes, @andig also suggested that check, though I didn't understand what he was saying at first. I do think it's a good idea. I still find the current behavior of `As` surprising.

--- Comment #12 by bcmills ---
I think the current behavior is appropriate, if for no other reason than that pre-`errors` users of various APIs would use type-assertions to check whether an error is of a given type. Only falling back to the custom `As` method if the value is not assignable keeps `As` more consistent with those users, and makes it more of a drop-in replacement for a type assertion.

--- Comment #13 by neild ---
It was (for better or worse) an intentional choice that `Is` and `As` methods can't override the default behavior.

--- Comment #14 by Merovius ---
Fair enough. I find it very strange, but I guess I'm too late for that discussion.

Then perhaps the issue should be re-titled again, as the `go vet` check is apparently the only useful thing we can do here.

--- Comment #15 by gopherbot ---
Change https://golang.org/cl/339889 mentions this issue: `go/analysis/passes/errorsas: warn if errors.As target is *error`

--- Comment #16 by rsc ---

This proposal has been added to the [active column](https://golang.org/s/proposal-status#active) of the proposals project
and will now be reviewed at the weekly proposal review meetings.
â€” rsc for the proposal review group


--- Comment #17 by bcmills ---
Would it make sense to apply the same warning to pointers to empty interface types, too?
They are trivial in essentially the same way, in that they cause `errors.As` to decay to a nil-check.

--- Comment #18 by neild ---
Warning on `*interface{}` doesn't seem like it would have any false positives, but I suspect it's unlikely to show up in practice.

--- Comment #19 by rsc ---

Based on the discussion above, this proposal seems like a **[likely accept](https://golang.org/s/proposal-status#likely-accept)**.
â€” rsc for the proposal review group


--- Comment #20 by rsc ---

No change in consensus, so **[accepted](https://golang.org/s/proposal-status#accepted)**. ðŸŽ‰
This issue now tracks the work of implementing the proposal.
â€” rsc for the proposal review group


--- Comment #21 by andig ---
The proposal is accepted and has an open CL. Any chance to move the CL forward?

--- Comment #22 by gopherbot ---
Change https://go.dev/cl/403034 mentions this issue: `go/analysis/passes/errorsas: update testdata for new warning`
