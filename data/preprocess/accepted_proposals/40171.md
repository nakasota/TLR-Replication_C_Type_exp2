=== Fetching Proposal: MDU6SXNzdWU2NTUzMjMyMTE= ===
Issue URL: https://github.com/golang/go/issues/40171

==== [Issue Title] ====
crypto: import fiat-crypto implementations

==== [Issue Body] ====
The fiat-crypto project (https://github.com/mit-plv/fiat-crypto) generates formally-verified, high-performance modular arithmetic implementations, useful for crypto primitives like Curve25519, Poly1305, and the NIST ECC curves that are used within the Go standard library. They're currently working on a Go backend.

BoringSSL has imported their implementations for Curve25519 and P-256: https://boringssl.googlesource.com/boringssl/+/master/third_party/fiat/

At https://go-review.googlesource.com/c/crypto/+/242177, I've uploaded a WIP CL that imports their Curve25519 implementation (w/ minor tweaks), and demonstrates a significant performance improvement over the current "generic" implementation. (The existing amd64 assembly implementation is still considerably faster though.)

This proposal is to import and make use of those implementations.

Open questions:

1. Which algorithms should be imported? BoringSSL only imports two. Should we import more?

2. Do we import both 32-bit and 64-bit implementations? We could import just one implementation and still get a performance speedup (e.g., 386 sees a -10% performance boost with curve25519_fiat_64.go, and amd64 sees a -30% boost with curve25519_fiat_32.go), but they do better still with the CPU-appropriate implementations (-30% for 386 w/ 32-bit, and -61% for amd64 w/ 64-bit).

3. How should the code be imported? E.g., should it be separated into a third_party or vendor directory with its own LICENSE file like how BoringSSL does it?

/cc @agl @FiloSottile 

==== [Comments] ====

--- Comment #1 by mdempsky ---
fiat-crypto's 64-bit P-224 implementation is about 2x as fast as Go's existing portable, constant-time P-224 implementation on amd64. Their 32-bit implementation is about the same speed on 386.

I expect P-256 will be similar to Curve25519 (i.e., existing assembly implementations are faster, but still worth measuring), but using fiat-crypto for P-384 and P-521 should be both much faster and provide a constant-time implementation (unlike the current, generic math/big code).

--- Comment #2 by mdempsky ---
@agl @FiloSottile Ping.

While here, I'll point out the fiat-crypto implementation also speeds up curve25519 on ppc64le:

    name               old time/op   new time/op   delta
    ScalarBaseMult-32    152µs ± 1%     92µs ± 4%  -39.82%  (p=0.000 n=17+20)

    name               old speed     new speed     delta
    ScalarBaseMult-32  210kB/s ± 0%  347kB/s ± 2%  +65.27%  (p=0.000 n=17+17)

(I don't have any ARM workstations to readily benchmark on.)

--- Comment #3 by rsc ---
I do have some concerns about adding new license notice requirements in the libraries, because those transitively apply to every Go binary anyone builds (that imports net/http at least).

I would feel much more comfortable about this if we could get the code contributed under CLA so that the Go license notice would cover it.


--- Comment #4 by mdempsky ---
@JasonGross Do you think we can get fiat-crypto's Go code contributed under Google's CLA? The normal process is documented at https://golang.org/doc/contribute.html#cla.

--- Comment #5 by rsc ---
Ping @JasonGross. We'd be happy to use this code but don't want to impose new notice requirements on every Go binary.


--- Comment #6 by JasonGross ---
Ah, sorry, I meant to follow up on this earlier.  As discussed on https://github.com/openssl/openssl/pull/12201#discussion_r472664494, MIT unfortunately doesn't permit signing CLAs on projects that it holds copyright to. :-/

--- Comment #7 by rsc ---
@JasonGross, thanks for replying. I certainly understand MIT not wanting to complete CLAs.

An alternative solution to our problem of imposing new notice requirements on every Go binary would be if the generator _outputs_ could be licensed under a non-attribution license such as [MIT-0](https://spdx.org/licenses/MIT-0.html) or a source-code-attribution-only license such as [BSD-1-Clause](https://spdx.org/licenses/BSD-1-Clause.html).

Do you think that is a possibility?

--- Comment #8 by JasonGross ---
That seems quite likely.  Let me chat with me colleagues and see if it's feasible.

--- Comment #9 by rsc ---
Thanks very much.


--- Comment #10 by JasonGross ---
@rsc We're in the process of re-licensing under user's choice, MIT OR BSD-1-Clause.  However, it seems that BSD-1-Clause is not listed under https://pkg.go.dev/license-policy, even though MIT-0 and BSD-0-Clause are.  Is this an oversight?  Will BSD-1-Clause in fact be sufficient?

--- Comment #11 by ianlancetaylor ---
BSD-1-clause should be fine for our purposes.  Thanks very much for tackling this.

I don't know why it's not listed in pkg.go.dev.  Maybe it's just not very common.  CC @jba .

--- Comment #12 by jba ---
Looking into it.

--- Comment #13 by rsc ---
BSD-1-Clause will be fine, thanks.


--- Comment #14 by rsc ---
Based on the discussion above, this seems like a **likely accept**.


--- Comment #15 by JasonGross ---
I've gotten approval from everyone and have prepared https://github.com/mit-plv/fiat-crypto/pull/881.  Hopefully we'll get it merged in the next couple of days.

--- Comment #16 by JasonGross ---
The code has now been relicensed under MIT OR BSD-1-Clause OR Apache-2.0

--- Comment #17 by ianlancetaylor ---
Thanks!

--- Comment #18 by rsc ---
Thanks so much @JasonGross!

Accepted.


--- Comment #19 by FiloSottile ---
Thank you @JasonGross and everyone! Excited for this to move forward.

We can start by importing the P-384 and P-521 implementations, which currently are bad enough that they'd get the most benefit, and then move to the other fields.

The next step is figuring out a reproducible process to generate the code, and get the output clean enough to pass code review (so we are not tied forever to the code generator, if need be). Happy to help with that in the coming weeks.

--- Comment #20 by mmcloughlin ---
Regarding code generation from fiat-crypto, [ecckiila](https://gitlab.com/nisec/ecckiila) might be useful to look at. This was [used for P-384 and P-521 in NSS 3.55](https://developer.mozilla.org/en-US/docs/Mozilla/Projects/NSS/NSS_3.55_release_notes).

--- Comment #21 by JasonGross ---
Note, by the way, that we currently [test our Rust Crate on our CI against crypto tests in Dalek](https://github.com/mit-plv/fiat-crypto/blob/90fc0d0ad5eaee6f654684061da75cb996140a11/.github/workflows/rust.yml#L20-L23), and we [test our generated C code against BoringSSL tests](https://github.com/mit-plv/fiat-crypto/blob/90fc0d0ad5eaee6f654684061da75cb996140a11/.github/workflows/c.yml#L35-L36).  Currently our [Go CI only checks that the code compiles](https://github.com/mit-plv/fiat-crypto/blob/90fc0d0ad5eaee6f654684061da75cb996140a11/.github/workflows/go.yml#L23-L24), but we'd love to extend it with any sort of integration tests you think might make sense.

Note also that if you want to include the code generator in your process (rather than just fetching our checked-in generated code), our CI is probably a pretty decent place to start, as we regenerate all the code from scratch on every CI run to make sure that we're aware of any changes to the generated code.

And, of course, I'm happy to help with and support any changes you want made to the generated code itself.

--- Comment #22 by odeke-em ---
I am kindly moving this to Go1.17, as there hasn’t been much action since October 2020.

--- Comment #23 by mdempsky ---
Since Go 1.17 development should be opening up again in the near future, it seems like a good time to discuss how to move forward here.

Would it make sense for the fiat-crypto project to provide a Go module that can be vendored into the standard library, analogous to the rust crate they provide? Or is it preferred for the Go project to own running the generators and checking in the generated code somewhere?

--- Comment #24 by JasonGross ---
If the deployment of the Go module can be automated in the way the Rust crate currently is, I'm happy to merge a PR that does that (and do any additional registration steps necessary).

--- Comment #25 by mdempsky ---
@JasonGross I think it would just require creating a `go.mod` file (e.g., `go mod init github.com/mit-plv/fiat-crypto/fiat-go/src` in your fiat-go/src directory), and then users can just import "githtub.com/mit-plv/fiat-crypto/fiat-go/src" and the Go command knows how to fetch your source.

It would require that the code directory is buildable with `go build ./...` though. Currently, https://github.com/mit-plv/fiat-crypto/tree/master/fiat-go/src has source files from a bunch of different Go packages grouped together (e.g., curve25519_32.go is package fiat_25519, but p224_32.go is fiat_p224). Is it reasonable to split those into separate subdirectories for each package? Alternatively, generating them all in the same package (e.g., `package fiat`) is probably fine too, as the linker can easily omit any unused code.

One last detail is the APIs need to be exported from the package (i.e., start with an uppercase letter), at least the functionality expected to be used by end users. Conventionally, Go uses mixed caps identifiers (e.g., `MixedCaps` or `mixedCaps`). There's typically some leeway allowed for generated code (esp. since this package probably wouldn't be used directly by end users, but instead via higher-level standard library APIs), but to the extent that it's possible to reasonably follow those conventions, I think that would be appreciated.

Happy to chat further if you have more questions. Also, @FiloSottile may have more opinions on how this should be integrated, as owner of Go's crypto packages.

--- Comment #26 by JasonGross ---
I'm nearly done with a PR to adjust the casing conventions.  Two questions there: What's the convention for package names?  Is the convention for type identifiers the same as for function identifiers?

I'm not sure what to do about the packages, though.  In particular, right now the 32-bit and 64-bit implementations have identical identifier names, but live in different file names.  (This is useful, for example, in C, where you can just `#include` a different file depending on the machine architecture and otherwise write the same code.)
I'm happy to either put everything in the same package, or put everything in directories according to the package (does the directory have to be named identically to the package?), whichever is desired.

--- Comment #27 by JasonGross ---
@mdempsky Could you review https://github.com/mit-plv/fiat-crypto/pull/907 and let me know if the name adjustments seem good?

--- Comment #28 by egonelbre ---
@JasonGross few things that stood out to me:

* Package names are usually lowercase. Instead of `Fiat25519` it would be `fiat25519`. And each package is in a separate folder.
* The func names don't need to duplicate the package name, so `Fiat25519Carry` can be `Carry`, since it's already in the package `fiat25519`. The fully qualified name would then be `fiat25519.Carry`.

--- Comment #29 by egonelbre ---
PS: it's worthwhile to wait for @mdempsky-s comments, since he has probably a better vision how to integrate this than me.

--- Comment #30 by mdempsky ---
@JasonGross Thanks, I'll comment on that PR.
