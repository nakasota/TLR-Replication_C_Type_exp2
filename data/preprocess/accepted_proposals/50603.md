=== Fetching Proposal: I_kwDOAWBuf85BweJ8 ===
Issue URL: https://github.com/golang/go/issues/50603

==== [Issue Title] ====
cmd/go: stamp the pseudo-version in builds generated by `go build`

==== [Issue Body] ====
**NOTE**: The accepted proposal is https://github.com/golang/go/issues/50603#issuecomment-2181188811.

-  - -
cmd/go embeds dependency version information in binaries, which is very useful. [From Go 1.18 onwards](https://golang.org/issue/37475), cmd/go also embeds VCS information in binaries, which makes it even more useful than it was before.

As #37475 mentions, people place version information in binaries using `-ldflags='-X foo=bar'`, which requires an additional build wrapper. The new VCS stamping feature of cmd/go should alleviate the need for external wrapper, but I am afraid it comes short.

The version information, in the sense of [Go's pseudo version](https://go.dev/ref/mod#pseudo-versions) is not recorded for the main module when doing `go build`:

```
: emerald:ver; go build
: emerald:ver; go version -m hello | grep 'mod.*hello'
	mod	mgk.ro/hello	(devel)	
: emerald:ver; 
```

The version is recorded as expected when doing `go install`:

```
: emerald:ver; go install robpike.io/ivy@latest
go: downloading robpike.io/ivy v0.1.124
: emerald:ver; go version -m `which ivy` | grep 'mod.*ivy'
	mod	robpike.io/ivy	v0.1.12	h1:qI7dnEiXhorB+za07W6qX3sG+IvBK4EUl38vUHAf53Q=
: emerald:ver; 
: emerald:ver; 
```

I am afraid this limitation of cmd/go will continue to force people to use external build wrappers that set `-ldflags`, which is rather unfortunate.

I am not the first to want main module version information in binaries, this has been already asked for in various issues, for example in #29814, which was closed as a duplicate of #37475, but it really wasn't a duplicate, as #37475 is about VCS information, and #29814 is about semantic versioning. Other examples of people asking for this feature are mvdan/sh#519 and https://github.com/golang/go/issues/29228#issuecomment-449554128 where various workarounds were proposed.

Speaking of workarounds, the only workaround that I know that currently works would be to create a local module proxy and pass `GOPROXY` to `go install`, but that is an extremely high-overhead workaround, and `go install` is not a replacement for `go build` anyway, since `go install` comes with some rather severe limitations regarding how vendoring works and what you can put in go.mod, and `go install` doesn't support controlling `GOBIN` when cross-compiling.

I realize that Git tags are a local concept, and by doing the "wrong" git operations one could come up with a different pseudo-version for the same source code. I am afraid I don't have any solution or suggestion regarding this git misfeature, except to note that even in this case the hash information is recorded correctly, and in every case by the virtue of having access to the local source code the programmer can always do *some local operation* that has the potential to cause a version mislabeling. Git is just more prome to do this *by accident*, but the ability is there, always.

I don't have any stats to back this up, but from my experience most corporate source code is built by `go build`, not `go install`, and it would be great if somehow Go's notion of versioning would be stamped by `go build`.

CC @bcmills @mvdan @rsc 

==== [Comments] ====

--- Comment #1 by mvdan ---
At least speaking personally, for cases like https://github.com/mvdan/sh/issues/519, my intent is to show something like `devel ${GIT_SHA}` when someone does a local Go build out of a git checkout. If someone is manually cloning and building, as opposed to the advertised and easier `go install url@latest`, I imagine they know what a git hash is. So what 1.18 is currently shipping with is enough for my needs.

It's true that something *like* a proper module version might be more useful; a git commit hash doesn't give any hint as to how old a version is, whereas a semver version prefix or a timestamp can give a starting point. So, in principle, I agree with you: 1.18 is a big step forward, but it's still unfortunate that the main module version remains as `(devel)` for local builds.

However, in practice, I still agree with Jay's comment in https://github.com/golang/go/issues/29228#issuecomment-755332642; we shouldn't make such a "locally inferred version" look like a normal version, because it's reasonably likely to be wrong or cause confusion with users.

> in every case by the virtue of having access to the local source code the programmer can always do _some local operation_ that has the potential to cause a version mislabeling.

Could you give some examples? I can only think of very unlikely scenarios, such as manually corrupting the module download cache after downloading some dependencies. That cache is read-only by default, and `go mod verify` exists to double-check the contents too.

With the main module in a git checkout, I can think of multiple scenarios which seem more likely:

* What if I've made a commit or tag but not pushed it?
* What if I've edited some files and not committed them?
* What if two people on two computers make the same tag with different code - would they end up with the same exact module version for different software? If one of them pushes their tag to the internet, would the other's computer be affected by the mismatch?

I think that, if we are to implement something like this, the versions must be somehow different from the canonical and unique versions that get computed from fully published commits and tags. This would make it very clear that the versions are inferred from local state, and not guaranteed to be correct. As a simplistic example, imagine that tagging `v1.2.3` locally results in a build whose main module version is `devel v1.2.3`, but when pushed and `go install`ed, gets the version `v1.2.3`.

--- Comment #2 by mvdan ---
> we shouldn't make such a "locally inferred version" look like a normal version, because it's reasonably likely to be wrong or cause confusion with users.

To add a more concrete example: if we made the change proposed here, and locally inferred versions looked like fully published versions, I would have a harder time trusting the output of `shfmt -version` when my users report bugs. I would have to update the issue template to also ask: did you build from a modified git checkout?

--- Comment #3 by 4ad ---
> Could you give some examples? I can only think of very unlikely scenarios, such as manually corrupting the module download cache after downloading some dependencies. That cache is read-only by default, and go mod verify exists to double-check the contents too.

I was thinking of the case where since Go itself doesn't expose *its own* concept of a version to the program, the users themselves are forced to create their own concepts of a version, either through things like `VERSION` files, or through some build wrappers. By definition, any such concept is under user's control, and the user can and will make mistakes. In fact, from experience, users try to naively use git tags for this which then fail for precisely the reasons you just explained.

Let me rephrase my point. Go can't enforce any useful properties for the user's notion of a version because it doesn't know about it, and as such if we make `userVersion==moduleVersion`, the fact that Go can't enforce any properties is neither better nor worse for the user. The user is on the hook for doing the right thing in both cases. In one case the user must properly maintain their `VERSION`, and in the other case the user must properly maintain their git checkouts.

The user does gain something in the latter case though. They don't have to create build wrappers.

> With the main module in a git checkout, I can think of multiple scenarios [which might fail ... ] I think that, if we are to implement something like this, the versions must be somehow different from the canonical and unique versions that get computed from fully published commits and tags. [...] As a simplistic example, imagine that tagging v1.2.3 locally results in a build whose main module version is devel v1.2.3, but when pushed and go installed, gets the version v1.2.3.

I very much agree with this, with one caveat. If the locally checked-out version is *identical* to a published release, I would expect the version to match the release. If the locally checked-out version can not be guaranteed to match any release, then yes, it should be published with something like `devel v1.2.3` (which matches what Go does, but why not `v1.2.3-devel` or `v1.2.3-unknown`, which is semver-compatible?).

Unfortunately, I can't imagine how this would work without internet access, and quite often a prerequisite of automated systems running `go build` is to not go to the Internet.


--- Comment #4 by 4ad ---
Hold on, another thought. If we *always* add the commit hash, and some other metadata to the main module version for local builds, essentially *always* making them a fully qualified Go pseudo-version, then they will always be different from the published version, so there's no potential for confusion there.

Even better, in semver terms these builds will sort *before* the published version, which is probably what people want.

For this, what I said earlier about 

> If the locally checked-out version is identical to a published release, I would expect the version to match the release.

can no longer be true, but perhaps that is ok as long as we come up with a documented and stable convention that describes versioning for local builds (as opposed to just dumping a "devel" in the metadata field).


--- Comment #5 by bcmills ---
The main caveat here, I think, is unpublished tags. If I create a local, unpublished tag for, say, `v1.1000.0`, then my pseudo-versions will be `v1.1000.0-0.2022…`, but everyone else's pseudo-versions may be on an arbitrarily lower version (say, `v0.8.3-0.2022…`.

That may or may not be a significant issue, though: if we always use a pseudo-version, we'll at least have the commit hash as a common point of reference even if the base versions differ.

--- Comment #6 by mvdan ---
@4ad right, a local build can't always know what is or isn't published, as requiring a network roundtrip takes us back to square one.

Your idea of trying to stick to semver, and always using some form of pseudo-version which includes a hash, sounds good. With one caveat, though: the commit hash isn't enough to make the version unambiguous, because I can have infinite kinds of uncommitted changes that do not change the HEAD commit hash.

@bcmills good point about tags still messing with pseudo-versions, but at least if we always include a timestamp and *some* form of unique hash, then I think we're good. With the caveat above about uncommitted changes :)

--- Comment #7 by mvdan ---
We do have another hash available to us, though, which changes whenever any input Go code changes: the build IDs used for the build cache. I seem to recall that one such ID is embedded into binaries, too.

Not ideal, as such a hash also includes build parameters like GOOS or -tags, which don't normally affect versions. But at least it fixed the problem with uncommitted files in VCS.

--- Comment #8 by 4ad ---
Yes, uncommitted changes should be explicit in the pseudo-version, but I think we can suffix `+`, just as we do with Go itself, no?

--- Comment #9 by seankhliao ---
the new buildinfo already records whether the workspace is clean with `vcs.modified=true|false`

--- Comment #10 by seankhliao ---
we could use one of `+local` (for clean builds) or `+dirty` (uncommitted changes, implies local) as the semver build id, attached to a pseudoversion which should make the situation clear enough?

So main will always have a version like
```
vX.Y.Z-timestamp-commit+local
vX.Y.Z-timestamp-commit+dirty
```

--- Comment #11 by hyangah ---
What is the main motivation of encoding the local version in pseudo-version style rather than keeping those extra info (timestamp?) as extra metadata fields - if it's not guaranteed that they are always available in the origin or proxies?

It seems like the `vcs.time` is already there in the build info metadata.

---
BTW, I feel like the main module's version isn't sufficient to describe a tool's behavior in certain cases - `go` version used to `go build`, third-party tools dependencies, and `go build`'s behavior change (`go.work` left over somewhere accidentally?) can affect a tool's behavior. So when triaging issues, I hope we develop best practice using `go version -m` or richer build info dump rather than relying on the main module version string. 

--- Comment #12 by 4ad ---
> What is the main motivation of encoding the local version in pseudo-version style

The main motivation is that `go install` does it, and many people expect to have a notion of a program's version available and want it, and because they don't have it with `go build`, they rely on build wrapers or other workarounds, which are undesirable in the broader Go ecosystem.

> encoding the local version in pseudo-version style **rather than** keeping those extra info (timestamp?) as extra metadata fields

Emphasis mine.

It's not *rather than*, It doesn't *replace* the existing metadata fields. If you want to read the metadata, you should read it from those fields instead of parsing the pseudo-version. However, that metadata is useful in disambiguating builds produced by `go build` from published releases. Presumably we could come with some other kind of metadata for the same purpose, but since pseudo-versions are a de-facto standard in the Go ecosystem, why not reuse it?

> I feel like the main module's version isn't sufficient to describe a tool's behavior in certain cases - go version used to go build, third-party tools dependencies, and go build's behavior change (go.work left over somewhere accidentally?) can affect a tool's behavior.

This sounds like an argument to always use the build ID as the version suffix instead of the VCS hash.

> So when triaging issues, I hope we develop best practice using go version -m or richer build info dump rather than relying on the main module version string.

I hope so too, but again, I think that discussion is out of scope for this thread, which is more about bringing `go build` in line with `go install` and providing a solution for users that avoids build wrappers.


--- Comment #13 by rsc ---

This proposal has been added to the [active column](https://golang.org/s/proposal-status#active) of the proposals project
and will now be reviewed at the weekly proposal review meetings.
— rsc for the proposal review group


--- Comment #14 by maja42 ---
As a kind of experience report, I'm using custom build-scripts for years, solely to embed version information of the main module into the executable. When building, I attach the following information:

```
type BuildInfo struct {
	// Major, Minor, Patch contain the semantic version components.
	// In case of an unofficial build, this version is from a previous commit on the same branch.
	Major, Minor, Patch int
	// If true, a version-tagged commit was built.
	OfficialBuild bool

	// CommitHash is the full hash of the git commit.
	// Note that the actually built source-code is different if LocalChanges is true.
	CommitHash string
	// CommitTimestamp is the timestamp of the git commit.
	// Note that the actually built source-code is different if LocalChanges is true.
	CommitTimestamp time.Time
	// BuildTimestamp contains the timestamp when the project was built.
	BuildTimestamp time.Time

	// LocalChanges specifies if the project directory differed from the commit due to local (uncommitted) changes.
	LocalChanges bool
}
```

With this kind of information, I'm able to build version-strings however I like. Usually I try to match go's pseudo-version strings, but when I need to stay compatible with the version-scheme from other, non-go projects, I can do so as well.

```
// VersionString returns the project's semantic version number without a leading 'v'.
// Patterns:
//    <major>.<minor>.<patch>
//        Built from an officially tagged commit (without local changes)
//    0.0.0-<buildTime>
//        Unofficial build. There are no tagged commits yet.
//    <major>.<minor>.<patch*>-<buildTime>
//        Unofficial build. The commit was not tagged, or there were local changes.
//        The used patch-version is +1 compared to the last tagged commit.
//    The build timestamp (yyyymmddhhmmss) is the UTC time when the application was built / ctgover generated the version number.
func (b *BuildInfo) VersionString() string {
	preRelease := ""
        patch := p.Patch
	if !b.OfficialBuild {
		buildTime := b.BuildTimestamp.Format("20060102150405")
		preRelease = "-" + buildTime
                patch++
	}
	return fmt.Sprintf("%d.%d.%d%s", b.Major, b.Minor, patch, preRelease)
}	
```

The version is printed when the application is started with a `-version` command-line flag. But I guess go-tools could/should show the same version string.

I don't have anything against adding a build ID, but it wouldn't really solve my problem. My use cases are:

- Identify the source-code / git-commit that was built
- Identify the application's version (for example to detect available updates)
- Identify when the application was built (quickly find out if it super old)
- Compare if two applications are the same, and which one is newer

The previously raised issue that git-tags might only be local was never really an issue in my experience. Version-tags aren't made lightheartedly and are always immediately pushed to the server in the projects I work on. 

I really hope we can this kind of information into a go-executable one day, because I would finally be able to get rid of all my build- and tool-scripts.

--- Comment #15 by rsc ---
It sounds like @mvdan and @bcmills have some hesitation around the fact that these pseudo-versions would not correspond to any publicly available version, even though they _look_ like those. That does seem like a reason not to do this.

We now have Git VCS info separately in the builds (as of Go 1.18; try go version -m). Do we need to add a second way to record that information?


--- Comment #16 by 4ad ---
> It sounds like @mvdan and @bcmills have some hesitation around the fact that these pseudo-versions would not correspond to any publicly available version, even though they look like those.

We can make it unambiguously distinct, for example instead of `v1.2.4-0.20191109021931-daa7c04131f5` we could use `v1.2.4-0.unpublished.20191109021931-daa7c04131f5` or something like that.

> We now have Git VCS info separately in the builds (as of Go 1.18; try go version -m). Do we need to add a second way to record that information?

No, we certainly only need one way to encode VCS info. The suggestion to put VCS info in the metadata field of the pseudo-version was to match the `go install` behavior, but putting something else there, for example the build id is probably better. ~~The build id also works, and is meaningful when you might not have VCS info, like from a tarball, which is a pretty common case where you'd use `go build` for.~~ Scratch that idea, without VCS we can't detect the version either.


--- Comment #17 by ChrisHines ---
> We can make it unambiguously distinct, for example instead of `v1.2.4-0.20191109021931-daa7c04131f5` we could use `v1.2.4-0.unpublished.20191109021931-daa7c04131f5` or something like that.

With replace statements in go.mod and the new workspace mode in Go 1.18 it is possible to build Go programs that include local versions of modules besides the main module. For those modules the go tool also lists `(devel)` for their version.

The new build vcs metadata only helps identify the main module. Adding vcs metadata for all local modules seems valuable and not currently supported. The format suggested above by @4ad would be more informative than `(devel)`. Maybe also including a `dirty` flag if there are uncommitted local edits.



--- Comment #18 by rsc ---
> The new build vcs metadata only helps identify the main module. Adding vcs metadata for all local modules seems valuable and not currently supported. 

This may be true, but the concern above seems to be adding vcs metadata that _looks_ like a pseudo-version. It need not, and it probably should not. We can always add that separately; maybe that should be a different proposal. (I think this is the first comment to bring up VCS info for replaced modules that point to other local repos.)


--- Comment #19 by mvdan ---
A thought: if we're only concerned about having a reliable way to _always_ get _some_ useful version for the main module, I think it could be an API of its own, like `debug.MainVersion() string`. It could first try to get the main module version from https://pkg.go.dev/runtime/debug#ReadBuildInfo, otherwise fall back to VCS information, and otherwise fall back to something that should always work, such as the binary's build ID.

I personally will be implementing logic like that to replace `-ldflags=-X=main.version=...` in my projects, where I use a default of `var version = "(devel)"`. And I think it should be useful to other projects as well, at least as a good starting point.

Another option, if we want this to also work for library modules, would be `debug.OwnVersion`, which would do the equivalent but for the module containing the package that's making the function call. Perhaps that would cover @ChrisHines's needs. I maintain some libraries and I admit that reliably knowing my own version could help in terms of logging or capturing debug information.

If the above sounds interesting, I'll happily develop the idea further and create a new proposal. I realise it's not the same as this proposal, but I also think it could be a different solution to the same end-user problem :)

--- Comment #20 by kortschak ---
@mvdan I would very much like to see something like that to replace the boiler place build lines that exist in code at work.

--- Comment #21 by 4ad ---
We use the semantic version of the binaries in order to compute API compatibility between different binaries. I am afraid that if your `debug.MainVersion()` doesn't always return some string that is compatible with semver, we will still have to resort to `-ldflags=-X=...`.

Now, one might object to using the binary version in this way and perhaps recommend using a separately maintained API version instead that is separate from the binary version. I would tend to agree except this is outside my control. I do not have the operational liberty to change this.

--- Comment #22 by mvdan ---
@4ad the "VCS fallback" mentioned in my proposed API could still resemble a pseudo-version, in the sense that it could give you some semver information related to the last known compatible VCS tag. The reason I think it's less likely to cause confusion with real and published pseudo-versions is that the API docs could explicitly warn users against assuming that the version is a valid module version.

Put another way, my worry with the original proposal here is that, currently, the module versions embedded into binaries are documented and likely assumed to be valid and published. Changing that could be confusing or silently break programs, whereas a new API can avoid the "module version" terminology altogether, and isn't changing existing behavior that could break any programs.

--- Comment #23 by 4ad ---
I see, yes. That would work for us, provided there's a way to retrieve it from outside the binary (i.e. without running the binary).

--- Comment #24 by mvdan ---
> provided there's a way to retrieve it from outside the binary

Do you mean via a cmd/go command that takes a path to a binary, or via a Go API that takes the path?

--- Comment #25 by 4ad ---
I'd be ok with either, I would prefer it to be in `cmd/go`, so I wouldn't have to write another tool, but as long as there's an API I can use, I'm happy.


--- Comment #26 by hyangah ---
If I check out a tagged version of source code, let's say `rsc.io/quote@v1.5.2` and `go build` from the cloned, unmodified 
 repo, what will be the pseudo-version like? `v1.5.2`, `v1.5.3-....`, `v1.5.2-...`? 
 
If that is not `v1.5.2`, do we want the `go` command to report an error if someone tries to `go install` with the special pseudo-version? Or, should the go module proxy serve data as if it's like a normal pseudo-version?

--- Comment #27 by mvdan ---
It would be a "fake local" version similar to a pseudo-version; we haven't defined what the format of that would be yet. I think we're all in agreemnet that it shouldn't look like a real pseudo-version, meaning that the format should be distinctly different, such as by containing a special suffix. That would then allow `go install` or the module proxy to outright reject using those module versions, because they're not valid module versions.

--- Comment #28 by bcmills ---
@hyangah, we do have some logic today to convert versions with `+build` metadata to canonical pseudo-versions.¹

I suspect we would reuse that same logic, so a checkout from `v1.5.2` would probably show as a `v1.5.3-0.…` pseudo-version.

¹https://cs.opensource.google/go/go/+/master:src/cmd/go/internal/modfetch/coderepo.go;l=482-492;drc=fa4d9b8e2bc2612960c80474fca83a4c85a974eb

--- Comment #29 by mpx ---
Currently `BuildInfo.Main.Version` can be trusted since it is only set for pristine builds pulled from a repo (otherwise `(devel)`). Currently these pristine builds more or less require module proxy infrastructure (a significant barrier for many, especially private developers/repos).

I'd prefer to keep a single definition for the version stored in `BuildInfo.Main.Version` (known version pulled from a repo). I think it would be better to provide an easy way to build a pristine private module without needing module proxy infrastructure. Eg:

`go install -local mymod/cmd/foo@v1.0.0`

This would keep the version definition the same and enable many developers who develop private modules locally to output pristine module builds. It does make it easier for someone to "fake" a version with a local tag, but this is already possible for sufficiently motivated developers. I'd prefer to optimise for easy of use.

--- Comment #30 by rsc ---
@bcmills can you summarize the arguments for and against doing this?

