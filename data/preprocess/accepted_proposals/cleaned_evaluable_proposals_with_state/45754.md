==== [Issue Title] ====
flag: add TextVar to handle types that implement encoding.TextUnmarshaler

==== [Issue Body] ====
The [`encoding.TextMarshaler`](https://pkg.go.dev/encoding#TextMarshaler) and [`encoding.TextUnmarshaler`](https://pkg.go.dev/encoding#TextUnmarshaler) interfaces are the de-facto way for a type to self-report that it can serialize to/from some humanly readable text format.

The easiest ways to tie the `flag` package to `encoding.TextUnmarshaler` is to:
1. use [`flag.Func`](https://golang.org/pkg/flag/#Func) to declare an anonymous function that calls some unmarshal function under the hood. This approach takes >3 lines, but unfortunately does not display the default value in the usage documentation.
2. declare a type that implements [`flag.Value`](https://golang.org/pkg/flag/#Value) and then use [`flag.Var`](https://golang.org/pkg/flag/#Var). This approach requires declaring 1 types and 2 methods and is generally more than 10 lines of cost.

Both ways have detriments (either too long or drops default values being printed).

I propose adding:
```go
// TextVar defines a flag with a specified name, default value, and usage string.
// The argument p points to a variable in which to store the value of the flag.
// The flag accepts a value according to encoding.TextUnmarshaler.UnmarshalText.
// The default value type must be the same as the pointed at variable type.
func TextVar(p encoding.TextUnmarshaler, name string, value encoding.TextMarshaler, usage string)
```
along with the equivalent method on the `FlagSet` type.

Example usage would be:
```go
var t time.Time
flag.TextVar(&t, "start_time", time.Now(), "Time to start processing at.")
```
or
```go
var n big.Int
flag.TextVar(&n, "n", big.NewInt(3853882583591558728), "Run integer factorization for this number")
```

Of note, this is approach only requires a single line (other than the variable declaration) and works with any type that implements `encoding.TextMarshaler` and `encoding.TextUnmarshaler`.

There is a type safety loss where the `p` argument and `value` argument may not be the same concrete type. Generics could resolve this problem.

---

Within the standard library, there are 5 types that implement the interfaces:
* [`"math/big".Float`](https://golang.org/pkg/math/big/#Float)
* [`"math/big".Int`](https://golang.org/pkg/math/big/#Int)
* [`"math/big".Rat`](https://golang.org/pkg/math/big/#Rat)
* [`"net".IP`](https://golang.org/pkg/net/#IP)
* [`"time".Time`](https://golang.org/pkg/time/#Time)

Each one could conceivably be useful to apply with the `flag` package.

According to the latest version of all modules, there are ~14k types that implement `encoding.TextUnmarshaler` out of ~8.2M types total. While this only accounts 0.2% of all types, it's still a non-trivial number of implementations.

==== [Comments] ====

--- Comment #1 by gopherbot ---
Change https://golang.org/cl/313329 mentions this issue: `flag: add TextVar function`

--- Comment #2 by mvdan ---
This is clever. I've often found people reaching for third-party flag libraries just for the sake of having more types built-in and not having to implement `flag.Value` manually.

This could also nudge more libraries towards implementing `TextMarshaler` and `TextUnmarshaler`, and I think that's a good thing. The encoding package is rarely used directly, and I think some Go developers aren't even well aware of this "text encoding" interface. Those libraries would rarely go out of their way to implement `flag.Value` directly, but implementing the two text methods is much more reasonable and reusable.

--- Comment #3 by icholy ---
I could have used this today when adding a flag to control the [logrus.Level](https://pkg.go.dev/github.com/sirupsen/logrus#Level) of a service.

--- Comment #4 by rsc ---
/cc @robpike 

--- Comment #5 by rsc ---

This proposal has been added to the [active column](https://golang.org/s/proposal-status#active) of the proposals project
and will now be reviewed at the weekly proposal review meetings.
â€” rsc for the proposal review group


--- Comment #6 by robpike ---
Seems reasonable to me. Might be able to forestall some future requests.

--- Comment #7 by rsc ---

Based on the discussion above, this proposal seems like a **[likely accept](https://golang.org/s/proposal-status#likely-accept)**.
â€” rsc for the proposal review group


--- Comment #8 by rsc ---

No change in consensus, so **[accepted](https://golang.org/s/proposal-status#accepted)**. ðŸŽ‰
