=== Fetching Proposal: MDU6SXNzdWU4NzU5NDA2MzU= ===
Issue URL: https://github.com/golang/go/issues/45955

==== [Issue Title] ====
slices: new package to provide generic slice functions

==== [Issue Body] ====
### **Note**: Discussion is now at https://github.com/golang/go/discussions/47203.

This proposal is for use with #43651. We propose defining a new package, `slices`, that will provide functions that may be used with slices of any type.  If this proposal is accepted, the new package will be included with the first release of Go that implements #43651 (we currently expect that that will be Go 1.18).

This description below is focused on the API, not the implementation. In general the implementation will be straightforward.  The description has been updated from the original proposal several times based on the discussion.

```
// Package slices defines various functions useful with slices of any type.
// Unless otherwise specified, these functions all apply to the elements
// of a slice at index 0 <= i < len(s).
package slices

import "constraints" // See #45458 

// Equal reports whether two slices are equal: the same length and all
// elements equal. If the lengths are different, Equal returns false.
// Otherwise, the elements are compared in index order, and the
// comparison stops at the first unequal pair.
// Floating point NaNs are not considered equal.
func Equal[T comparable](s1, s2 []T) bool

// EqualFunc reports whether two slices are equal using a comparison
// function on each pair of elements. If the lengths are different,
// EqualFunc returns false. Otherwise, the elements are compared in
// index order, and the comparison stops at the first index for which
// eq returns false.
func EqualFunc[T1, T2 any](s1 []T1, s2 []T2, eq func(T1, T2) bool) bool

// Compare compares the elements of s1 and s2.
// The elements are compared sequentially starting at index 0,
// until one element is not equal to the other. The result of comparing
// the first non-matching elements is the result of the comparison.
// If both slices are equal until one of them ends, the shorter slice is
// considered less than the longer one
// The result will be 0 if s1==s2, -1 if s1 < s2, and +1 if s1 > s2.
func Compare[T constraints.Ordered](s1, s2 []T) int

// CompareFunc is like Compare, but uses a comparison function
// on each pair of elements. The elements are compared in index order,
// and the comparisons stop after the first time cmp returns non-zero.
// The result will be the first non-zero result of cmp; if cmp always
// returns 0 the result is 0 if len(s1) == len(s2), -1 if len(s1) < len(s2),
// and +1 if len(s1) > len(s2).
func CompareFunc[T any](s1, s2 []T, cmp func(T, T) int) int

// Index returns the index of the first occurrence of v in s, or -1 if not present.
func Index[T comparable](s []T, v T) int

// IndexFunc returns the index into s of the first element
// satisfying f(c), or -1 if none do.
func IndexFunc[T any](s []T, f func(T) bool) int

// Contains reports whether v is present in s.
func Contains[T comparable](s []T, v T) bool

// Insert inserts the values v... into s at index i, returning the modified slice.
// In the returned slice r, r[i] == the first v.  Insert panics if i is out of range.
// This function is O(len(s) + len(v)).
func Insert[S constraints.Slice[T], T any](s S, i int, v ...T) S

// Delete removes the elements s[i:j] from s, returning the modified slice.
// Delete panics if s[i:j] is not a valid slice of s.
// Delete modifies the contents of the slice s; it does not create a new slice.
// Delete is O(len(s)-(j-i)), so if many items must be deleted, it is better to
// make a single call deleting them all together than to delete one at a time.
func Delete[S constraints.Slice[T], T any](s S, i, j int) S

// Clone returns a copy of the slice.
// The elements are copied using assignment, so this is a shallow clone.
func Clone[S constraints.Slice[T], T any](s S) S

// Compact replaces consecutive runs of equal elements with a single copy.
// This is like the uniq command found on Unix.
// Compact modifies the contents of the slice s; it does not create a new slice.
func Compact[S constraints.Slice[T], T comparable](s S) S

// CompactFunc is like Compact, but uses a comparison function.
func CompactFunc[S constraints.Slice[T], T any](s S, cmp func(T, T) bool) S

// Grow grows the slice's capacity, if necessary, to guarantee space for
// another n elements. After Grow(n), at least n elements can be appended
// to the slice without another allocation. If n is negative or too large to
// allocate the memory, Grow will panic.
func Grow[S constraints.Slice[T], T any](s S, n int) S

// Clip removes unused capacity from the slice, returning s[:len(s):len(s)].
func Clip[S constraints.Slice[T], T any](s S) S
```

==== [Comments] ====

--- Comment #1 by randall77 ---
`Remove` and `RemoveSlice` are presumably in place?
Other in-place operations have `InPlace` in the name, but that's to distinguish them from the non-in-place versions.

Not sure if adding `InPlace` to `Remove` and `RemoveSlice` is worth it. But mentioning in-place-ness in the docs wouldn't hurt.


--- Comment #2 by cespare ---
```
// Cut removes j-i elements from s starting at index i, returning the modified slice.
...
func RemoveSlice[T any](s []T, i, j int) []T
```

Did you intend for this to be `Cut` or `RemoveSlice`?

--- Comment #3 by cespare ---
In general I think a `slices` package will be necessary. Functions like `Equal`, `Insert`, and `Remove` will be especially welcome improvements over the current boilerplate.

I have two concerns about the list of functions here:

1. **Too much bloat to start with.** I think we should err on the side of being too minimal and add new functions in future releases as they prove worthwhile. For instance, I think that `CompareFunc` will be rarely used and doesn't obviously pull its weight here.
2. **Too much emphasis on a functional programming style using higher-order functions.** My experience with languages like JS and Java (and quite a few others which were more C-like in their initial incarnations and added a lot of higher-order function stuff later) is that there is an unfortunate dichotomy between writing `for` loops and using higher-order functions.

   Code which heavily uses the latter looks very different on the page from the former, impeding readability.

   The higher-order function style also tends to be much slower, so when writing a loop there's a decision burden every time between saving a line or two and writing fast code. (TIMTOWTDI is not really the Go ethos.) And programmers usually prefer concision, so the net result is often slow, HOF-heavy code.

   The HOF style of code is also a bit clunky with Go's current function literals; adding many more HOFs will create pressure to add new syntax (#21498).

   In summary, I feel like this nudges the language in a non-Go-like direction. A thing that I really like about Go is that, for many tasks, I just write a plain, clear `for` loop which gets compiled to the obvious machine code. I don't look forward to a future where the prevailing style is to replace each `for` loop with a sufficiently clever `slices.Reduce`.

With these ideas in mind, I'd divide this list of functions into three groups.

**Clearly worthwhile in a v1 of `slices`:**

* `Equal`
* `Compare`
* `Index`
* `Contains`
* `LastIndex`
* `Insert`
* `InsertSlice`
* `Remove`
* `RemoveSlice`
* `Resize`

**Borderline:**

* `EqualFunc`
* `ContainsFunc`
* `Map`
* `Filter`
* `FilterInPlace`

**Not worth it:**

* `CompareFunc`
* `IndexFunc`
* `LastIndexFunc`
* `Reduce`
* `MapInPlace`

--- Comment #4 by ianlancetaylor ---
@cespare I meant `RemoveSlice`.  Thanks.  Updated.

--- Comment #5 by ianlancetaylor ---
@randall77 Thanks, updated the comments.

--- Comment #6 by mnasruul ---
AW

--- Comment #7 by IceWreck ---
Why not `container/slices` and later if needed `container/maps` ?

Anyways this package would be a welcome addition because its a pain (boilerplate wise) to implement common data structures in Go compared to C++ and this would slightly reduce that boilerplate

--- Comment #8 by sfllaw ---
Should this new package mention https://github.com/golang/go/wiki/SliceTricks in its documentation? Should SliceTricks document the new package? How does this wiki page fit into the revised ecosystem?

--- Comment #9 by sfllaw ---
~`Index` has in-band error signalling, which is strange? Isn't it less surprising to return `(i int, exists bool)`, to mirror maps?~

--- Comment #10 by mvdan ---
@sfllaw see https://golang.org/pkg/strings/#Index, bytes.Index, etc.

--- Comment #11 by sfllaw ---
Hmm, good point!

--- Comment #12 by fzipp ---
@ianlancetaylor `MapInPlace[type D, S]` uses the old syntax. It should be `MapInPlace[D, S any]`.

--- Comment #13 by komuw ---
@ianlancetaylor did you mean?;
```diff
-func MapInPlace[type D, S](dst []D, src []S, f func(S) D)
+func MapInPlace[D, S](dst []D, src []S, f func(S) D)
```

--- Comment #14 by Merovius ---
One think to point out is that the `Map` and `MapInPlace` could be unified under `MapAppend[D, S any](dst []D, src []S, f func(S) D)`, which appends to `dst` - `Map` would be equivalent to passing `nil` for `dst` and `MapInPlace` would be passing `dst[:0]`. Similar for `Filter`. Not saying we should, just that we could. And I find `InPlace` a slightly weird bikeshed color for `Map`, where `D` and `S` can be different, thus the mapping is never "in place".

Personally, I'm a bit concerned about `Index` and especially `Contains`. IMO they suggest that unordered slices are a suitable data structure for sets. Anecdotally, using `x in y` for a Python `list` was the single most common mistake I had to deduct points for [edit] in an algorithms and datastructure class. Really need to hire a copy-editor [/edit]

I'd be less concerned if there was the equivalent thing for sorted slices as well, so that people at least be made to think about it. Though that would probably live in `sort`.

--- Comment #15 by extrasalt ---
Would flatten and flatMap also be included? 

I can think of cases where a map would produce a slice of slices and that might need flattening

--- Comment #16 by DylanMeeus ---
I think this is a good idea, and it opens the door to including more functions by default in the future. Functions like these are going to either be provided by the standard library, or we'll end up with multiple "third party" libraries which do these things all in their own way, which will be used by a ton of projects anyway. Especially when people migrate from other languages (Java, C#, ..) they will look for such functions.   

Providing this out of the box would be in-line with how Go provides other frequently used constructs natively (like handling json data).  

--- Comment #17 by sluongng ---
```
// Resize returns s with length c. If the length increases, the new trailing
// elements will be set to the zero value of T.  The capacity of the returned
// slice is not specified.
func Resize[T any](s []T, c int) []T
```

Not obvious what would be the behavior in case where `len(s) > c`. Would the returning slice be a truncated `s`, taking the first c elements or will `s` be returned as-is?

```
// Map turns a []T1 to a []T2 using a mapping function.
func Map[T1, T2 any](s []T1, f func(T1) T2) []T2

// Filter returns a new slice containing all elements e in s for which keep(e) is true.
func Filter[T any](s []T, keep func(T) bool) []T

// MapInPlace copies the elements in src to dst, using a mapping function
// to convert their values. This panics if len(dst) < len(src).
// (Or we could return min(len(dst), len(src)) if that seems better.)
func MapInPlace[type D, S](dst []D, src []S, f func(S) D)

// FilterInPlace modifies s to contain only elements for which keep(e) is true.
// It returns the modified slice.
func FilterInPlace[T any](s []T, keep func(T) bool) []T
```

I wonder it's might worth to provide some interface that would return a lazily-evaluated value here? As the chaining of Map and Filter is very common in Java Stream API.
So I wonder if we gona need a separate CL for something like `Promise[T any]`.

```
// Insert inserts v into s at index i, returning the modified slice.
// In the returned slice r, r[i] == v.  This panics if !(i >= 0 && i <= len(s)).
// This function is O(len(s)).
func Insert[T any](s []T, i int, v T) []T

// InsertSlice inserts si into s at index i, returning the modified slice.
// In the returned slice r, r[i] == si[0] (unless si is empty).
// This panics if !(i >= 0 && i <= len(s)).
func InsertSlice[T any](s, si []T, i int) []T

// Remove removes the element at index i from s, returning the modified slice.
// This panics if !(i >= 0 && i < len(s)).  This function is O(len(s)).
// This modifies the contents of the slice s; it does not create a new slice.
func Remove[T any](s []T, i int) []T

// RemoveSlice removes j-i elements from s starting at index i, returning the modified slice.
// This can be thought of as a reverse slice expression: it removes a subslice.
// This panics if i < 0 || j < i || j > len(s).
// This modifies the contents of the slice s; it does not create a new slice.
func RemoveSlice[T any](s []T, i, j int) []T
```

I don't agree with usage of panic here.
Perhaps returning an `err` or there should be an `Optional` type/struct that can be either a value or an error.
Might be worth implementing these in a separate CL instead of the initial CL.


--- Comment #18 by sanggonlee ---
These seem like they would make our lives slightly easier, but I thought one of the philosophies of Go was that operations not in `O(1)` runtime shouldn't hide their complexity? I thought that was the main reason there were no simple commonly used abstractions like map, filter, etc in Go.
Although I suppose the runtime of these functions are quite universally understood by most developers...

--- Comment #19 by bcmills ---
One slice operation I've found myself writing frequently is “return the same slice with its cap reduced to length”.

#38081 was declined partially on the grounds that it could be written more clearly as a generic function (https://github.com/golang/go/issues/38081#issuecomment-610628025). I think such a function belongs in the `slices` package.

--- Comment #20 by bcmills ---
I agree with @cespare that some of the functional APIs here seem premature, especially given the lack of a concise lambda.

I would add that functional languages tend to rely heavily on covariance, which Go lacks. That makes functions like `Reduce` and even `Map` much less useful than the corresponding functions in functional programming languages, especially when compared to the `for` loops we can already write. (I looked at `Map` in particular https://github.com/bcmills/go2go/blob/master/map.go2, but found it [quite awkward](https://github.com/bcmills/go2go/blob/86572be39534504b2f51a65a137fb087562c8496/map.go2#L32-L40) compared to the typical functional `map`.)

On the other hand, `Map` and `Reduce` would be much more clearly useful if we had some way to express “assignable to” as a constraint, which I believe would be [a coherent addition](https://github.com/bcmills/go2go/blob/master/assignable.md) to the existing design. It's not obvious to me changing those functions to use such a constraint would be backward-compatible, so I think they should be omitted until we have more hands-on experience with generic functional programming in Go.


--- Comment #21 by empath-75 ---
If you're going to do map/filter/reduce doesn't it make more sense to design a more generic interface first, and then implement it for slices?  There are a lot more datastructures than slices that could benefit from such a thing.

--- Comment #22 by bcmills ---
I agree with @sluongng that the behavior of `Resize` seems unclear. I also don't really understand its purpose — can't we already resize a slice using the built-in slice operator?

I think a `Clone` method that returns a copy of a slice (up to its length) without accepting a length parameter — analogous to the `bytes.Clone` proposed in #45038 — would be much clearer for _decreasing_ a length.

For _increasing_ a length, I wonder if it would be clearer to provide a function that increases the _capacity_ instead, analogous to [`(*bytes.Buffer).Grow`](https://beta.pkg.go.dev/bytes#Buffer.Grow):

```go
// Grow returns s with capacity at least c.
// If cap(s) >= c already, Grow returns s as-is.
func Grow[T any](s []T, c int) []T
```

Then, increasing the _length_ of the slice is trivial:
```go
	s := slices.Grow(s, n)[:n]
```

That might also address @mdempsky's use case in proposal #24204 (see https://github.com/golang/go/issues/24204#issuecomment-738871874), since “allocate a new `[]T` with capacity at least `c`” could be written as:
```go
	s := slices.Grow([]T{}, c)
```

--- Comment #23 by earthboundkid ---
The code I was writing [yesterday](https://github.com/carlmjohnson/crockford/commit/77b9c2b0a82040ccdd27b0d9fcf65b49cec81917) would have benefited from the existence of slices.Grow.

I am also strongly in favor of the Append idiom rather than InPlace. Append is already used throughout the standard library, whereas InPlace has no current uses.

--- Comment #24 by arroo ---
one thing I have found useful on more than one occasion from JS's `Reduce` implementation is including the index as an argument to the provided function. 
so it would be:
```
func Reduce[T1, T2 any](s []T1, initializer T2, f func(T2, T1, int) T2) T2
```

--- Comment #25 by bcmills ---
The `Slice` variant of `Insert` seems like too much duplication to me. We have only one `append` in the language, not separate `append` variants for one element and multiple elements — why should `Insert` be any different?

If we make `Insert` analogous to `append`, that gives the signature:
```go
func Insert[T any](s []T, i int, v ...T) []T
```
which seems like it handily covers the use-cases for both the proposed `Insert` and `InsertSlice`.

--- Comment #26 by bcmills ---
I think the signature for `RemoveSlice` may be surprising. I would intuitively expect it to accept a length instead of a second index.

That being the case, I think a function named `RemoveN` that explicitly accepts a length would be clearer — it's a bit more awkward for the “two indices” case, but it would be much more natural for many cases and _also_ a lot less likely to be misread:

```go
// RemoveN removes n elements from s starting at index i, returning the modified slice.
// This panics if i < 0 || n < 0 || i+n > len(s).
// This modifies the contents of the slice s; it does not create a new slice.
func RemoveN[T any][s []T, i, n int) []T
```

(The `N` suffix already has a precedent in the standard library in `strings.SplitN`.)

--- Comment #27 by gaal ---
It may be desirable for the standard library to offer a convention around simple error handling.

With the proposed package, the programmer can map an []int to a []string: `Map(in, strconv.Itoa)`. But they cannot map a []string to a []int. The programmer could write a wrapper `struct{ res T1; err error }` and adapt any f to one that uses the wrapper, but that is tedious and inefficient.

I think a common usage would benefit from:

```go
// MapErr turns a []T1 to a []T2 using a mapping function.
// If an error is encountered during mapping, mapping stops and the first error is returned.
func MapErr[T1, T2 any](s []T1, f func(T1) (T2, error)) ([]T2, error)
```

This puts some pressure on also defining the execution order / concurrency, but I imagine the standard slices library would not attempt to process anything concurrently here.

I'm not sure about the spelling and how far this should be taken (Filter benefits from the same treatment, but what about the others?). But if we do nothing, people will end up writing their own generic Map functions, which echoes the situation around custom set libraries.

--- Comment #28 by earthboundkid ---
I can see the use case for MapErr, but when would you need FilterErr? You have a function that returns bool, error—why? ISTM more likely that you might need a trivial `return err == nil` wrapper for the filter, but even that's a little weird. I can't recall having written any code like that with a for-loop.

--- Comment #29 by bcmills ---
That said, I wonder if something more analogous to `strings.Replace` could cover the more advanced use-cases of both `Remove` and `Insert`:

```go
// Replace replaces the elements at s[i:j] with the elements of si.
// This modifies the contents of the slice s when possible; it only creates
// a new slice if len(si) > j - i.
func Replace[T any](s []T, i, j int, si []T)
```

Then:
```go
	w = slices.Insert(w, i, v)
	x = slices.InsertSlice(x, xs, i)
	y = slices.Remove(y, i)
	z = slices.RemoveSlice(z, i, j)
```
could all be expressed as:
```go
	w = slices.Replace(w, i, i, []T{v})
	x = slices.Replace(x, i, i, xs)
	y = slices.Replace(y, i, i+1, nil)
	z = slices.Replace(z, i, j, nil)
```

--- Comment #30 by bcmills ---
@gaal, I think functions that are not pure transforms would be more clearly expressed as part of a general-purpose iterator library, rather than trying to make the `slices` library interact with things other than slices proper.

(I have a draft of such a package, written under the Go license, in https://github.com/bcmills/go2go/blob/master/iterate/iterate.go2.)
