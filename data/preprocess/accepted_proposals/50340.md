=== Fetching Proposal: I_kwDOAWBuf85A4WxY ===
Issue URL: https://github.com/golang/go/issues/50340

==== [Issue Title] ====
sort: add Find

==== [Issue Body] ====
I have never used `sort.Search` to build a sorted list (slice). It's too expensive and there are better ways. However, I use it often to do what its name suggests: search.

The API is designed for the growth case, which is fine and general, but the general (growth) case is rare, perhaps very rare, and handling the return value is clumsy†.

 I suggest adding another  function, say `sort.Contains`, that just says yes or no to the question of presence of the element. Here is sort.Search's use for the pure search case, right from the documentation:

```
i := sort.Search(len(data), func(i int) bool { return data[i] >= x })
        if i < len(data) && data[i] == x {
        	// x is present at data[i]
        } else {
        	// x is not present in data,
        	// but i is the index where it would be inserted.
        }
```

Besides the messy handling, that extra comparison has always bothered me.

Here is what that would look like with the proposed function:

```
 if sort.Contains(len(data), func(i int) bool { return data[i] >= x }) {
      	// x is present at data[i]
}
```

This seems so much more intuitive and semantically lightweight. If you needed the index - but why would you if you weren't going to insert there? - you could go back to the existing `Search` function.

It should be very simple to implement by having both `Search` and `Contains` call a helper that reports presence, and returning the appropriate result, or by just writing `Contains` itself - like `Search`, it's very short.

I already filled in the proposal questionnaire here: https://github.com/golang/go/issues/45624


† And poorly documented, but that is fixable.

==== [Comments] ====

--- Comment #1 by robpike ---
By the way, even in the event type parameters cause a rethink of this package, a lighter-weight `Contains` function would be nice to have.

--- Comment #2 by DeedleFake ---
How would this work? I was under the impression that the reason for the secondary `data[i] == x` check is because the `f` function doesn't necessarily provide enough information to be sure if the value at `i` is actually the one being searched for or not. Since `sort.Contains()` doesn't actually return `i`, how would you be sure if the value was correct or not?

~~I'm also curious what the better way to build a sorted slice is that you mentioned. I _have_ used `sort.Search()` to do so, many times. The only way I can think of that's even equivalent would be to build a heap and then pop the whole thing once you're done adding stuff to it, but just off the top of my head both seem to be `O(n * log(n))` to me.~~

Edit: Actually, I think that the heap method _would_ be better as it doesn't require as many copies, and potentially allocations, when adding elements thanks to not having to insert into the middle of a slice. It _does_ use interfaces if using `container/heap`, though, which is a whole different type of overhead.

--- Comment #3 by robpike ---
Whatever else it might do, it can do another test. It only has <= but two calls of that will tell it == (NaNs aside, but we're already on thin ice with NaNs. They're not even numbers.)

In case it's not clear from what I wrote above, that final test (or two) may be necessary, but I want the function to do it, not the caller.

--- Comment #4 by DeedleFake ---
As proposed, there's no way for the function to determine actual equality. The function only takes the index to check against and, therefore, knows nothing about the value actually being checked. For example, given `f` is `func(i int) { return data[i] >= 3 }`, consider the the slices `[]int{1, 2, 3, 4}` and `[]int{1, 2, 4, 5}`. `f(i)` returns the exact same values for all indices in both cases, but the value is actually only present in one of the slices. Unless I'm somehow just completely missing something here, the API proposed does not seem capable of determining for sure whether or not the value being searched for is actually in the slice.

> It only has <= but two calls of that will tell it ==

It _doesn't_ have `<=`, though. It only has `x <=`. The `x` is built in to the function passed in. Without the ability change the order of the two things being compared, it can't be used to determine equality.

The only mention that the proposal seems to make for separately determining equality is

> It should be very simple to implement by having both Search and Contains call a helper that reports presence, and returning the appropriate result, or by just writing Contains itself - like Search, it's very short.

but it's not clear what exactly that would look like. It sounds like you're saying that `sort.Contains()` needs a second function passed to it, maybe `func(i int) bool`, that it will call to determine the final equality. If so, that would work, but I don't see a whole lot of advantage over the existing `sort.Search()`, and having to pass two closures to `sort.Contains()` seems _more_ cumbersome to me, not less.

This

```go
present := sort.Contains(
  len(data),
  func(i int) bool { return data[i] >= x },
  func(i int) bool { return data[i] == x },
)
if present {
  // x is present in data
}
```

doesn't seem much better to me than this

```go
i := sort.Search(len(data), func(i int) bool { return data[i] >= x })
if (i < len(data)) && (data[i] == x) {
  // x is present at data[i]
}
```

Edit: It occurs to me that this is fairly straightforwards with generics:

[Playground Link](https://go.dev/play/p/gAJfg_2w15g?v=gotip)

```go
func Contains[T any, S ~[]T](s S, x T, less func(v1, v2 T) bool) bool {
	i := sort.Search(len(s), func(i int) bool { return less(x, s[i]) }) - 1
	return (i >= 0) && !less(s[i], x)
}
```

This is limited to slices, but that probably covers 99% of cases. A more complicated one that covers other cases is also possible, but probably not worth the trouble.

Edit 2: Fix an instance of `return condition ? true : false`. Sigh... That's what I get for writing code at 2:00 A.M.

--- Comment #5 by robpike ---
I had forgotten the challenge of moving the equality check away from the caller. I hadn't thought it through - even though I remember talking to @griesemer about the challenge when he was designing it. Mea ignoramica.

But that affects only the mechanism, not my desire, which is to simplify the API. I like your solution, at least as a discussion point. I can't help feel there's a clean API trying to be found. C's bsearch isn't all that nice to use either, though.


--- Comment #6 by robpike ---
There's even this nice (untested) possibility for the simplest and possibly commonest case, if we can choose a different name for it.

```
func Lookup[T constraints.Comparable, S ~[]T](s S, x T) bool {
	i := sort.Search(len(s), func(i int) bool { return x <= s[i] })
	return i < len(s) && x==s[i]
}
```

--- Comment #7 by mlevieux ---
I'm probably about to say something completely wrong, but isn't the problem solved by asking for a function able to report for multiple states? Like here we're focusing on a closure like `func (i int) bool`, but we could totally go for `func (i int) int` that'd be a comparator function so -1 on <, 0 on == and 1 on >. So `sort.Contains` would take this function and return true if it could compare some value for equality, false otherwise. This makes writing the closure longer and probably a little-less readable. But it also has the advantage of letting the caller define the equality relations according the use case, which is not possible through the use of `constraints.Comparable`.

--- Comment #8 by rsc ---

This proposal has been added to the [active column](https://golang.org/s/proposal-status#active) of the proposals project
and will now be reviewed at the weekly proposal review meetings.
— rsc for the proposal review group


--- Comment #9 by rsc ---
It sounds like we agree that sort.Search is hard to use, but there's not an obvious replacement. In particular, anything that can report an exact position has to take a different function (a 3-way result like strings.Compare, or multiple functions).

For sake of argument, we could do:

```
func Find(n int, cmp func (i int) int) int
```

where the `cmp` function returns <0, 0, or >0 to say whether the item being sought is less than, equal to, or greater than element at position i.

(In comparison, sort.Search's f reports whether the item being sought is less than the element at position i; that is, it's Less(item, elem[i]), whereas Find takes Cmp(item, elem[i]).)

Is that something we should consider adding?


--- Comment #10 by rsc ---
When we do resolve this discussion, perhaps we should revisit https://github.com/golang/go/issues/47619#issuecomment-915428658.


--- Comment #11 by robpike ---
@rsc I am in favor of adding a function with the signature you suggest, and happy with the name.

--- Comment #12 by rsc ---
Sounds like people are generally in favor of adding sort.Find.
It looks like we'd need to add slices.BinaryFind and slices.BinaryFindFunc as well.
The difference between Search and Find in all cases would be that Find returns -1 when the element is not present,
whereas Search returns the index in the slice where it would be inserted.

Do I have that right? Does anyone object to adding Find (and slices.BinaryFind and slices.BinaryFindFunc)?


--- Comment #13 by rogpeppe ---
I am at least partially responsible for the design of the original API and I also take Rob's view that it's needlessly awkward in the common case (it's also annoying because it's backward from most of the rest of the sort package's API - you have to think in terms of greater-than rather than less-than, but that's another matter).

> where the `cmp` function returns <0, 0, or >0 to say whether the item being sought is less than, equal to, or greater than element at position `i`.

I think I'd find it be more intuitive to say that `cmp` returned whether the _element_ is <0, 0 or >0 than the item being sought ("how does element `i` compare to what I'm looking for?"), but that would probably be an unwarrantable difference in approach from `sort.Search`.

What would the signature of `BinaryFind` look like? I'm thinking something like:

```
func BinaryFind[T any](x []T, item T, func(T, T) int) int
```

for example:

```
BinaryFind([]string{"a", "b", "c"}, "b", strings.Compare)
```

Maybe a good reason to add a `time.Time.Compare` method:

```
BinaryFind([]time.Time{...}, t, time.Time.Compare)
```


--- Comment #14 by ianlancetaylor ---
I think the analogous slices signatures would be

```Go
func BinaryFind[E comparable](s []E, E) int
func BinaryFindFunc[E any](s []E, func(E) int) int
```

It's a reasonable question to ask whether `BinaryFindFunc` should instead be

```Go
func BinaryFindFunc[E any](s []E, v E, func(E, E) int) int
```

I'm not sure.  I think the main argument for the latter would be that we can pass functions like `bytes.Compare`, as you suggest.

--- Comment #15 by rogpeppe ---
> I think the analogous slices signatures would be
> 
> ```go
> func BinaryFind[E comparable](s []E, E) int
> func BinaryFindFunc[E any](s []E, func(E) int) int
> ```
> 
> It's a reasonable question to ask whether `BinaryFindFunc` should instead be
> 
> ```go
> func BinaryFindFunc[E any](s []E, v E, func(E, E) int) int
> ```
> 
> I'm not sure. I think the main argument for the latter would be that we can pass functions like `bytes.Compare`, as you suggest.

The main reason from my point of view is that the item that's being searched for is rarely a constant, so the former always in practice requires the caller to create a closure that refers to that value, which is unwieldy and not really that much easier to use than `sort.Find` would be, I  think.

Example calls:

```
	i = sort.Find(len(xs), func(i int) int {
		return strings.Compare(x, xs[i])
	})
	i = slices.FindFunc1(xs, func(y string) int {
		return strings.Compare(x, y)
	})
	i = slices.FindFunc2(xs, x, strings.Compare)
```

The latter is the clear winner, I think - it's shorter and easier to get right. With the closure versions,
you have to remember the order of the comparison - `strings.Compare(y, x)` would
be just as possible, but a function of the form `func(T, T) int` has a natural ordering.

I suspect it might end up more efficient too, because `FindFunc` is unlikely to be inlined, so
the closure wouldn't be inlined, so there would be an extra indirect function call on each comparison AFAICS.



--- Comment #16 by rsc ---
The three-argument FindFunc (FindFunc2 above) would be different from the other Funcs we have, like IndexFunc. It doesn't make sense to me to diverge from those.

Should we leave BinaryFindFunc out until we are more sure it's needed?


--- Comment #17 by DeedleFake ---
I feel like the `FindFunc2()` signature is just a workaround for the unwieldy nature of simple closures. Maybe something like that should be reconsidered in the context of #21498? A shorter syntax would make that entirely unnecessary, in my opinion.

--- Comment #18 by rogpeppe ---
> The three-argument FindFunc (FindFunc2 above) would be different from the other Funcs we have, like IndexFunc. It doesn't make sense to me to diverge from those.

I'd suggest that `FindFunc` is different from `IndexFunc` in that `IndexFunc` is only rarely used to find a locally defined value.

A quick scan of a random corpus of a few million lines of code turned up 20 uses of `IndexFunc`, of which only one used a closure to define the value being searched for. All the rest were similar to `strings.IndexFunc(s, unicode.IsSpace)` - that is, the predicate function was independently defined only in terms of its argument.

One of the nice things about `IndexFunc` is that it can be used with many existing "out of the box" functions (`unicode.IsSpace` being just one example). With `FindFunc1` above, that's not the case - you will always need to define your own closure, and there's always to possibility of getting the argument ordering wrong and the potential subtle bugs that could arise as a result:
```
i = slices.FindFunc1(xs, func(y string) int {
	return strings.Compare(y, x)   // WRONG!
})
```

On the other hand, with a two-argument form, many existing functions and methods can be used as they are:

```
slices.FindFunc2(byteSlices, byteSlice, bytes.Compare)
slices.FindFunc2(ipAddrs, ipAddr, netip.Addr.Compare)
slices.FindFunc2(semvers, version, semver.Compare)
slices.FindFunc2(bigInts, i, (*big.Int).Cmp)
```

I'd argue that passing a compare function is more natural than passing a single argument function, has less potential for subtle bugs, and makes better use of existing available functions and methods.

I don't believe this is about closures being unwieldy. Even if closures were more syntactically lightweight, you'd still need to remember to pass the arguments to the underlying comparison function (and there will usually _be_ an underlying comparison function, I suspect) in the right order.

--- Comment #19 by rogpeppe ---
One other thing that's worth clarifying: currently `sort.Search` is guaranteed to find the smallest value such that `f(i)` is true, which means if there are multiple exact matches, it will always return the earliest one.

With `sort.Find`, we could potentially return immediately when the compare function returns 0. That's more efficient but a bit inconsistent with `sort.Search`. Personally I don't think that matters (if someone really needs the very first instance in a run, they can still use `sort.Search`), but opinions might well vary. WDYT?


--- Comment #20 by ianlancetaylor ---
I think `sort.Find` should be defined as returning any arbitrary index for which the comparison function returns zero.

--- Comment #21 by rsc ---
Okay, so it sounds like we all agree on sort.Find.

slices.Anything is a bit harder. It sounds like maybe the signature should be different from sort.Find.
Also BinaryFind is not a real thing like binary search is.

Perhaps slices.BinarySearchFunc should change to be the FindFunc2 we've been talking about. 
Specifically, right now we have:

```
slices.BinarySearch(slice []T, target T)
slices.BinarySearchFunc(slice []T, less func(value T) bool)
```

and maybe we should change it to:

```
slices.BinarySearch(slice []T, target T)
slices.BinarySearchFunc(slice []T, target T, cmp func(T, T) int)
```

That would line up well with what other languages do and it avoids the problems @rogpeppe points out.
And we'd be back down to having just one.

Thoughts?


--- Comment #22 by ianlancetaylor ---
CC @eliben 

--- Comment #23 by eliben ---
I agree with decoupling the interfaces the `sort` and `slices` packages. The former works on abstract indices, whereas the latter works on actual slices.

The changes to `slices` sound alright to me; to be clear, there's no change to `BinarySearch`, but there is change to the semantics of `BinarySearchFunc`, from the current semantics of taking `ok func(Elem) bool` where it finds and returns the smallest index `i` at which element `ok` returns `true` for element `i`. The new semantics will be taking `cmp func(T, T) int` and returning the smallest index `i` at which `cmp` returns 0?

I don't have a preference w.r.t. `sort` package, other than to express that having both `Search` and `Find` functions with subtly different semantics in it somewhat confusing.

--- Comment #24 by rogpeppe ---
> The new semantics will be taking `cmp func(T, T) int` and returning the smallest index `i` at which `cmp` returns 0?

I believe as per [this comment](https://github.com/golang/go/issues/50340#issuecomment-1029354632) the new semantics will be returning the first (arbitrary) index `i` encountered for which `cmp` returns 0.

--- Comment #25 by rsc ---
It sounds like people are happy with https://github.com/golang/go/issues/50340#issuecomment-1034071670, with the clarification that sort.Find and slices.BinarySearchFunc can return any index for a value that compares equal. 

It also sounds like we should change slices.BinarySearch, which currently says:

> BinarySearch searches for target in a sorted slice and returns the smallest index at which target is found.

It sounds like we should allow any arbitrary index there too, for consistency. The "smallest" text was inherited from sort.Search.

(sort.Search itself must return the smallest index, because it doesn't have a three-way compare. Otherwise returning N would always be a valid implementation of sort.Search.)

--- Comment #26 by eliben ---
> It sounds like we should allow any arbitrary index there too, for consistency. The "smallest" text was inherited from sort.Search.

That's fine.

I'll just say that the "smallest index" has a nice parallel with what `BinarySearch` does when the target is *not* found, which is return the potential insertion index. On the other hand, `BinarySearchFunc` does not provide this guarantee (and will instead return `n` when not found). This discrepancy was also inherited from `sort.Search*`







--- Comment #27 by rogpeppe ---
One possibility for the future: define a generic `Compare` function to make it trivial to use regular comparable types with `slice.BinarySearchFunc` etc:

```
func Compare[T constraints.Ordered](a, b T) int {
    switch {
    case a < b:
        return -1
    case a > b:
        return 1
    }
    return 0
}
```

I haven't got a great idea for where it might live though.
   

--- Comment #28 by rogpeppe ---
On reflection, maybe it might live happily in `sort`.
`sort.Compare` reads reasonably, I think. We could also define `sort.Less`:

```
func Less[T constraints.Ordered](a, b T) bool {
    return a < b
}
```

Then both functions are available to be dropped in wherever a compare or less-than function is required.

--- Comment #29 by rsc ---
We haven't talked about return values for the generic versions, which raises an interesting question about whether sort.Find should return two values.

To start, there is a new `sort.Find(n int, cmp(i int) int)` for which `cmp` is like the `less` in `sort.Search` but returns 0 for equal, and therefore `Find` returns -1 when the element is not there at all.

But then we wanted to figure out what the implications of adding sort.Find are for the rest of the library, specifically for the generic package slices, and there are two questions.

**Question 1**
Today, `slices.BinarySearch(slice []T, target T) int` returns the position where target would be inserted if target is not there. 
Perhaps BinarySearch should be changed to return -1 instead, since it does know whether target is present?
(sort.Search has no concept of target)
Or should it return a pair of values (index int, found bool)?

**Question 2**
Today, `slices.BinarySearchFunc` takes a less function, which we've established is awkward, hence sort.Find.
Perhaps instead it should take a cmp function, as in:

    slices.BinarySearchFunc(slice []T, target T, cmp func(T, T) int) int

If we do this, then it too should probably return -1, or a pair.

These prompt: 

**Question 3**

Should sort.Find return a pair (index int, found bool)?

There is a nice symmetry to having all three return the pair, and then it is much harder to confuse sort.Search behavior with these, because the return count is different.



--- Comment #30 by eliben ---
I'd be really happy to see consistency between `sort.Find` and the two generic functions. As for -1 vs. returning a pair, I think -1 makes more sense because:

* The index is useless on its own if `found = false`; this is unlike other cases like the two-return map find where the default value can be used regardless of `found`.
* Many functions in the standard library similarly return -1 on "not found" instead of a pair, e.g. `strings.Index` and the like

So, my preference would be:

Question 1: -1 sounds good
Question 2:  `cmp` function instead of `less` sounds good, and return -1 for consistency with `BinarySearch`
Question 3: return -1 as well, for consistency with others




